# 2. ä¸‹æº–å‚™

xv6ã«è‡ªä½œãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã‚’ç§»æ¤ã™ã‚‹ã«ã‚ãŸã£ã¦ã€ã„ãã¤ã‹ä¸‹æº–å‚™ã‚’ã—ã¦ãŠãã¾ã™ã€‚

## 2.1. å‹å®šç¾©ã®è¿½åŠ 

è‡ªä½œãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã§å¤šç”¨ã—ã¦ã„ã‚‹ãƒ“ãƒƒãƒˆå¹…æŒ‡å®šã®æ•°å€¤å‹ï¼ˆ`uint8_t`ã‚„`uint32_t`ï¼‰ãªã©ã®å‹å®šç¾©ã‚’è¿½åŠ ã—ã¦ãŠãã¾ã™ã€‚xv6ã§ã¯å‹å®šç¾©ã‚’`kernel/types.h`ã«é›†ç´„ã—ã¦ã„ã‚‹ã®ã§ã€ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½åŠ ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“ kernel/types.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...

typedef uint64 pde_t;
+
+#if defined(_STDIO_H)
+#define MKFS
+#endif
+
+#if !defined(MKFS)
+
+#define NULL ((void *)0)
+
+typedef char int8_t;
+typedef unsigned char uint8_t;
+typedef short int16_t;
+typedef unsigned short uint16_t;
+typedef int int32_t;
+typedef unsigned int uint32_t;
+typedef long long int64_t;
+typedef unsigned long long uint64_t;
+
+typedef int64_t ssize_t;
+typedef uint64_t size_t;
+
+typedef int64_t intptr_t;
+typedef uint64_t uintptr_t;
+
+#endif
```
</details>

> [!NOTE]
> xv6ã‚’èµ·å‹•ã™ã‚‹ãŸã‚ã«`make qemu`ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€ãƒ¦ãƒ¼ã‚¶ãƒ©ãƒ³ãƒ‰ã®å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«ãªã©ã‚’æ ¼ç´ã—ãŸãƒ‡ã‚£ã‚¹ã‚¯ã‚¤ãƒ¡ãƒ¼ã‚¸ï¼ˆ`fs.img`ï¼‰ã‚’ä½œè£½ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ï¼ˆ`mkfs`ï¼‰ãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŠã‚ˆã³å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚
>
> ã“ã®`mkfs`ã¯ã€xv6ã§ã¯ãªããƒ›ã‚¹ãƒˆã§å®Ÿè¡Œã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã‚ã‚‹ãŸã‚ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã¯ãƒ›ã‚¹ãƒˆç’°å¢ƒã®ãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã™ã€‚ãƒ›ã‚¹ãƒˆç’°å¢ƒã®ãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ãŒèª­ã¿è¾¼ã¾ã‚Œã‚‹ã¨ã€ã“ã“ã§è¿½åŠ ã—ã¦ã„ã‚‹å‹å®šç¾©ã¨ã®è¡çªãŒç™ºç”Ÿã—ã¦ã—ã¾ã†ãŸã‚ã€`mkfs`ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã®ã¿è¿½åŠ ã—ãŸå‹å®šç¾©ãŒèª­ã¿è¾¼ã¾ã‚Œãªã„ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚


## 2.2. ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›ã®æ”¹è‰¯

### 2.2.1. ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›

xv6ã®ã‚«ãƒ¼ãƒãƒ«å†…ã‹ã‚‰ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã¸æ–‡å­—åˆ—ã‚’å‡ºåŠ›ã™ã‚‹ã«ã¯`printf()`ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

```c
printf("Hello, world!\n");
```

æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®`printf()`ã¨åŒç­‰ã®é–¢æ•°ã§ã™ãŒã€ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡å­—åˆ—ã®ã‚µãƒãƒ¼ãƒˆãŒé™å®šçš„ã§ã™ã€‚

- ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹å¤‰æ›æŒ‡å®šå­ã¯ `%d`, `%ld`, `%lld`, `u`, `lu`, `llu`, `%x`, `lx`, `llx`, `%p`, `%s` ã®ã¿
- ãƒ•ãƒ©ã‚°æ–‡å­—ã‚„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å¹…ã€ç²¾åº¦ãªã©ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„

ã‚«ãƒ¼ãƒãƒ«å†…ã§ä½¿ç”¨ã™ã‚‹`printf()`ã®ã‚³ãƒ¼ãƒ‰ã¯`kernel/printf.c`ã«å«ã¾ã‚Œã¦ã„ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/printf.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```c
// Print to the console.
int
printf(char *fmt, ...)
{
  va_list ap;
  int i, cx, c0, c1, c2, locking;
  char *s;

  locking = pr.locking;
  if(locking)
    acquire(&pr.lock);

  va_start(ap, fmt);
  for(i = 0; (cx = fmt[i] & 0xff) != 0; i++){
    if(cx != '%'){
      consputc(cx);
      continue;
    }
    i++;
    c0 = fmt[i+0] & 0xff;
    c1 = c2 = 0;
    if(c0) c1 = fmt[i+1] & 0xff;
    if(c1) c2 = fmt[i+2] & 0xff;
    if(c0 == 'd'){
      printint(va_arg(ap, int), 10, 1);
    } else if(c0 == 'l' && c1 == 'd'){
      printint(va_arg(ap, uint64), 10, 1);
      i += 1;
    } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
      printint(va_arg(ap, uint64), 10, 1);
      i += 2;
    } else if(c0 == 'u'){
      printint(va_arg(ap, int), 10, 0);
    } else if(c0 == 'l' && c1 == 'u'){
      printint(va_arg(ap, uint64), 10, 0);
      i += 1;
    } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
      printint(va_arg(ap, uint64), 10, 0);
      i += 2;
    } else if(c0 == 'x'){
      printint(va_arg(ap, int), 16, 0);
    } else if(c0 == 'l' && c1 == 'x'){
      printint(va_arg(ap, uint64), 16, 0);
      i += 1;
    } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
      printint(va_arg(ap, uint64), 16, 0);
      i += 2;
    } else if(c0 == 'p'){
      printptr(va_arg(ap, uint64));
    } else if(c0 == 's'){
      if((s = va_arg(ap, char*)) == 0)
        s = "(null)";
      for(; *s; s++)
        consputc(*s);
    } else if(c0 == '%'){
      consputc('%');
    } else if(c0 == 0){
      break;
    } else {
      // Print unknown % sequence to draw attention.
      consputc('%');
      consputc(c0);
    }

#if 0
    switch(c){
    case 'd':
      printint(va_arg(ap, int), 10, 1);
      break;
    case 'x':
      printint(va_arg(ap, int), 16, 1);
      break;
    case 'p':
      printptr(va_arg(ap, uint64));
      break;
    case 's':
      if((s = va_arg(ap, char*)) == 0)
        s = "(null)";
      for(; *s; s++)
        consputc(*s);
      break;
    case '%':
      consputc('%');
      break;
    default:
      // Print unknown % sequence to draw attention.
      consputc('%');
      consputc(c);
      break;
    }
#endif
  }
  va_end(ap);

  if(locking)
    release(&pr.lock);

  return 0;
}
```
</details>

### 2.2.2. æ”¹è‰¯ç‰ˆã®ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›

xv6ã®ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›ã¯ç°¡ç´ ã™ãã‚‹ãŸã‚ã€ã‚ˆã‚Šå¤šãã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡å­—åˆ—ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹å®Ÿè£…ã«å·®ã—æ›¿ãˆã¾ã™ã€‚ä»Šå›ã¯ã€ŒJOSã€ã¨ã„ã†ã€xv6ã¨åŒã˜ãMITã®6.828ã‚³ãƒ¼ã‚¹ã§åˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹æ•™è‚²ç”¨ã®OSã‹ã‚‰ã‚³ãƒ¼ãƒ‰ã‚’æ‹å€Ÿã—ã¾ã™ã€‚

+ Lab1 - MIT 6.828 (2018): https://pdos.csail.mit.edu/6.828/2018/labs/lab1/
+ Gitãƒªãƒã‚¸ãƒˆãƒª: https://pdos.csail.mit.edu/6.828/2018/jos.git

> [!NOTE]
> JOSã®ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¯xv6ã¨åŒæ§˜ã«MITãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã§ã™ã€‚

ä¸Šè¨˜ã®Gitãƒªãƒã‚¸ãƒˆãƒªã‹ã‚‰æŠ½å‡ºã—ãŸ2ã¤ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã€xv6ã®ä½œæ¥­ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¸è¿½åŠ ã—ã¾ã™ã€‚

> [!IMPORTANT]
> ä¸‹è¨˜ã®ã‚³ãƒ¼ãƒ‰ã‚’ãã®ã¾ã¾ã‚³ãƒ”ãƒ¼ï¼†ãƒšãƒ¼ã‚¹ãƒˆã—ã¦ãã ã•ã„ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/printfmt.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```c
// Stripped-down primitive printf-style formatting routines,
// used in common by printf, sprintf, fprintf, etc.
// This code is also used by both the kernel and user programs.

#include <stdarg.h>

#include "types.h"
#include "riscv.h"
#include "defs.h"
#include "error.h"

/*
 * Space or zero padding and a field width are supported for the numeric
 * formats only.
 *
 * The special format %e takes an integer error code
 * and prints a string describing the error.
 * The integer may be positive or negative,
 * so that -E_NO_MEM and E_NO_MEM are equivalent.
 */

static const char * const error_string[MAXERROR] =
{
  [E_UNSPECIFIED] = "unspecified error",
  [E_BAD_ENV] = "bad environment",
  [E_INVAL] = "invalid parameter",
  [E_NO_MEM]  = "out of memory",
  [E_NO_FREE_ENV] = "out of environments",
  [E_FAULT] = "segmentation fault",
  [E_IPC_NOT_RECV]= "env is not recving",
  [E_EOF]   = "unexpected end of file",
  [E_NO_DISK] = "no free space on disk",
  [E_MAX_OPEN]  = "too many files are open",
  [E_NOT_FOUND] = "file or block not found",
  [E_BAD_PATH]  = "invalid path",
  [E_FILE_EXISTS] = "file already exists",
  [E_NOT_EXEC]  = "file is not a valid executable",
  [E_NOT_SUPP]  = "operation not supported",
};

/*
 * Print a number (base <= 16) in reverse order,
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
   unsigned long long num, unsigned base, int width, int padc)
{
  // first recursively print all preceding (more significant) digits
  if (num >= base) {
    printnum(putch, putdat, num / base, base, width - 1, padc);
  } else {
    // print any needed pad characters before first digit
    while (--width > 0)
      putch(padc, putdat);
  }

  // then print this (the least significant) digit
  putch("0123456789abcdef"[num % base], putdat);
}

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  if (lflag >= 2)
    return va_arg(*ap, unsigned long long);
  else if (lflag)
    return va_arg(*ap, unsigned long);
  else
    return va_arg(*ap, unsigned int);
}

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  if (lflag >= 2)
    return va_arg(*ap, long long);
  else if (lflag)
    return va_arg(*ap, long);
  else
    return va_arg(*ap, int);
}


// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  register const char *p;
  register int ch, err;
  unsigned long long num;
  int base, lflag, width, precision, altflag;
  char padc;

  while (1) {
    while ((ch = *(unsigned char *) fmt++) != '%') {
      if (ch == '\0')
        return;
      putch(ch, putdat);
    }

    // Process a %-escape sequence
    padc = ' ';
    width = -1;
    precision = -1;
    lflag = 0;
    altflag = 0;
  reswitch:
    switch (ch = *(unsigned char *) fmt++) {

    // flag to pad on the right
    case '-':
      padc = '-';
      goto reswitch;

    // flag to pad with 0's instead of spaces
    case '0':
      padc = '0';
      goto reswitch;

    // width field
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      for (precision = 0; ; ++fmt) {
        precision = precision * 10 + ch - '0';
        ch = *fmt;
        if (ch < '0' || ch > '9')
          break;
      }
      goto process_precision;

    case '*':
      precision = va_arg(ap, int);
      goto process_precision;

    case '.':
      if (width < 0)
        width = 0;
      goto reswitch;

    case '#':
      altflag = 1;
      goto reswitch;

    process_precision:
      if (width < 0)
        width = precision, precision = -1;
      goto reswitch;

    // long flag (doubled for long long)
    case 'l':
    case 'z':
      lflag++;
      goto reswitch;

    // character
    case 'c':
      putch(va_arg(ap, int), putdat);
      break;

    // error message
    case 'e':
      err = va_arg(ap, int);
      if (err < 0)
        err = -err;
      if (err >= MAXERROR || (p = error_string[err]) == NULL)
        printfmt(putch, putdat, "error %d", err);
      else
        printfmt(putch, putdat, "%s", p);
      break;

    // string
    case 's':
      if ((p = va_arg(ap, char *)) == NULL)
        p = "(null)";
      if (width > 0 && padc != '-')
        for (width -= strnlen(p, precision); width > 0; width--)
          putch(padc, putdat);
      for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
        if (altflag && (ch < ' ' || ch > '~'))
          putch('?', putdat);
        else
          putch(ch, putdat);
      for (; width > 0; width--)
        putch(' ', putdat);
      break;

    // (signed) decimal
    case 'd':
      num = getint(&ap, lflag);
      if ((long long) num < 0) {
        putch('-', putdat);
        num = -(long long) num;
      }
      base = 10;
      goto number;

    // unsigned decimal
    case 'u':
      num = getuint(&ap, lflag);
      base = 10;
      goto number;

    // (unsigned) octal
    case 'o':
      // Replace this with your code.
      putch('X', putdat);
      putch('X', putdat);
      putch('X', putdat);
      break;

    // pointer
    case 'p':
      putch('0', putdat);
      putch('x', putdat);
      num = (unsigned long long)
        (uintptr_t) va_arg(ap, void *);
      base = 16;
      goto number;

    // (unsigned) hexadecimal
    case 'x':
      num = getuint(&ap, lflag);
      base = 16;
    number:
      printnum(putch, putdat, num, base, width, padc);
      break;

    // escaped '%' character
    case '%':
      putch(ch, putdat);
      break;

    // unrecognized escape sequence - just print it literally
    default:
      putch('%', putdat);
      for (fmt--; fmt[-1] != '%'; fmt--)
        /* do nothing */;
      break;
    }
  }
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  va_list ap;

  va_start(ap, fmt);
  vprintfmt(putch, putdat, fmt, ap);
  va_end(ap);
}

struct sprintbuf {
  char *buf;
  char *ebuf;
  int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  b->cnt++;
  if (b->buf < b->ebuf)
    *b->buf++ = ch;
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  struct sprintbuf b = {buf, buf+n-1, 0};

  if (buf == NULL || n < 1)
    return -E_INVAL;

  // print the string to the buffer
  vprintfmt((void*)sprintputch, &b, fmt, ap);

  // null terminate the buffer
  *b.buf = '\0';

  return b.cnt;
}

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  va_list ap;
  int rc;

  va_start(ap, fmt);
  rc = vsnprintf(buf, n, fmt, ap);
  va_end(ap);

  return rc;
}
```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/error.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```c
/* See COPYRIGHT for copyright information. */

#ifndef JOS_INC_ERROR_H
#define JOS_INC_ERROR_H

enum {
	// Kernel error codes -- keep in sync with list in lib/printfmt.c.
	E_UNSPECIFIED	= 1,	// Unspecified or unknown problem
	E_BAD_ENV	,	// Environment doesn't exist or otherwise
				// cannot be used in requested action
	E_INVAL		,	// Invalid parameter
	E_NO_MEM	,	// Request failed due to memory shortage
	E_NO_FREE_ENV	,	// Attempt to create a new environment beyond
				// the maximum allowed
	E_FAULT		,	// Memory fault

	E_IPC_NOT_RECV	,	// Attempt to send to env that is not recving
	E_EOF		,	// Unexpected end of file

	// File system error codes -- only seen in user-level
	E_NO_DISK	,	// No free space left on disk
	E_MAX_OPEN	,	// Too many files are open
	E_NOT_FOUND	, 	// File or block not found
	E_BAD_PATH	,	// Bad path
	E_FILE_EXISTS	,	// File already exists
	E_NOT_EXEC	,	// File not a valid executable
	E_NOT_SUPP	,	// Operation not supported

	MAXERROR
};

#endif	// !JOS_INC_ERROR_H */
```

</details>

#### ğŸŒŸ ä¸è¶³ã—ã¦ã„ã‚‹æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªé–¢æ•°ã®è¿½åŠ ã€‘

ä¸Šè¨˜ã®`printfmt.c`ã«å«ã¾ã‚Œã‚‹`vprintfmt()`ã¯`strnlen()`ã‚’å¿…è¦ã¨ã—ã¾ã™ãŒã€ã“ã®é–¢æ•°ã¯xv6ã«ã¯å«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚æ–‡å­—åˆ—é–¢é€£ã‚’ã¾ã¨ã‚ã¦ã„ã‚‹`string.c`ã¸`strnlen()`ã‚’è¿½åŠ ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/string.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...

+int
+strnlen(const char *s, uint z)
+{
+  int n;
+
+  for (n = 0; z > 0 && s[n]; n++, z--)
+    ;
+  return n;
+}
```
</details>

`strnlen()`ã¯çµ‚ç«¯æ–‡å­—ãŒå«ã¾ã‚Œãªã„å¯èƒ½æ€§ã®ã‚ã‚‹æ–‡å­—åˆ—ã®é•·ã•ã‚’è¨ˆæ¸¬ã™ã‚‹é–¢æ•°ã§ã™ã€‚å¼•æ•°ã§æŒ‡å®šã—ãŸæœ€å¤§ãƒã‚¤ãƒˆæ•°ã«é”ã—ã¦ã‚‚çµ‚ç«¯æ–‡å­—ãŒç¾ã‚Œãªã‹ã£ãŸå ´åˆã«ã¯ãã“ã§è¨ˆæ¸¬ã‚’æ‰“ã¡åˆ‡ã‚Šã¾ã™ã€‚

#### ğŸŒŸ ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—å®£è¨€ã®è¿½åŠ 

ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«å¤–ã«å…¬é–‹ã™ã‚‹é–¢æ•°ã®ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—å®£è¨€ã‚’è¿½åŠ ã—ã¾ã™ã€‚xv6ã§ã¯é–¢æ•°ã®ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—å®£è¨€ã‚’`kernel/defs.h`ã«é›†ç´„ã—ã¦ã„ã‚‹ã®ã§ã€ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½åŠ ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/defs.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’é–‹ãï¼‰</span></summary>

```diff
...

 // printf.c
 int            printf(char*, ...) __attribute__ ((format (printf, 1, 2)));
 void            panic(char*) __attribute__((noreturn));
 void            printfinit(void);

+// printfmt.c
+void            vprintfmt(void (*)(int, void*), void*, const char*, void*);
+void            printfmt(void (*)(int, void*), void*, const char*, ...);
+int             vsnprintf(char*, int, const char*, void*);
+int             snprintf(char*, int, const char*, ...);
+
...

 // string.c
 int             memcmp(const void*, const void*, uint);
 void*           memmove(void*, const void*, uint);
 void*           memset(void*, int, uint);
 char*           safestrcpy(char*, const char*, int);
 int             strlen(const char*);
+int             strnlen(const char*, uint);
 int             strncmp(const char*, const char*, uint);
 char*           strncpy(char*, const char*, int);

```
</details>

#### ğŸŒŸ Makefileã®ä¿®æ­£

`Makefile`ã®`OBJS`ã«æ–°ã—ãè¿½åŠ ã—ãŸã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆåï¼‰ã‚’è¿½åŠ ã—ã¾ã™ã€‚ã¾ãŸã€GCCã®ãƒ“ãƒ«ãƒˆã‚¤ãƒ³é–¢æ•°ãŒä½¿ã‚ã‚Œãªã„ã‚ˆã†ã«`CFLAGS`ã«ã„ãã¤ã‹ã®`-fno-builtin-xxx`ã‚’è¿½åŠ ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• Makefileï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
 K=kernel
 U=user

 OBJS = \
   $K/entry.o \
   $K/start.o \
   $K/console.o \
   $K/printf.o \
+  $K/printfmt.o \
   $K/uart.o \
   $K/kalloc.o \
   $K/spinlock.o \
   $K/string.o \
   $K/main.o \
   $K/vm.o \
   $K/proc.o \
   $K/swtch.o \
   $K/trampoline.o \
   $K/trap.o \
   $K/syscall.o \
   $K/sysproc.o \
   $K/bio.o \
   $K/fs.o \
   $K/log.o \
   $K/sleeplock.o \
   $K/file.o \
   $K/pipe.o \
   $K/exec.o \
   $K/sysfile.o \
   $K/kernelvec.o \
   $K/plic.o \
   $K/virtio_disk.o

...

 CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb -gdwarf-2
 CFLAGS += -MD
 CFLAGS += -mcmodel=medany
 # CFLAGS += -ffreestanding -fno-common -nostdlib -mno-relax
 CFLAGS += -fno-common -nostdlib
 CFLAGS += -fno-builtin-strncpy -fno-builtin-strncmp -fno-builtin-strlen -fno-builtin-memset
 CFLAGS += -fno-builtin-memmove -fno-builtin-memcmp -fno-builtin-log -fno-builtin-bzero
 CFLAGS += -fno-builtin-strchr -fno-builtin-exit -fno-builtin-malloc -fno-builtin-putc
-CFLAGS += -fno-builtin-free
+CFLAGS += -fno-builtin-free -fno-builtin-strnlen -fno-builtin-snprintf -fno-builtin-vsnprintf
 CFLAGS += -fno-builtin-memcpy -Wno-main
 CFLAGS += -fno-builtin-printf -fno-builtin-fprintf -fno-builtin-vprintf
 CFLAGS += -I.
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)

...
```
</details>

ä¸€æ—¦ã€ã“ã®çŠ¶æ…‹ã§è¿½åŠ ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å«ã‚ã¦ãƒ“ãƒ«ãƒ‰ãŒé€šã‚‹ã‹ç¢ºèªã—ã¦ãŠãã¾ã™ã€‚

```
$ make clean
$ make
```

#### ğŸŒŸ ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›é–¢æ•°ã®å·®ã—æ›¿ãˆ

ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›é–¢æ•°ï¼ˆ`printf`ï¼‰ã‚’å·®ã—æ›¿ãˆã‚‹æº–å‚™ãŒã§ããŸã®ã§ã€`printf.c`ã‚’æ¬¡ã®ã‚ˆã†ã«å¤‰æ›´ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/printf.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...

 // lock to avoid interleaving concurrent printf's.
 static struct {
   struct spinlock lock;
   int locking;
 } pr;

-static char digits[] = "0123456789abcdef";
-
-static void
-printint(long long xx, int base, int sign)
-{
-  char buf[20];
-  int i;
-  unsigned long long x;
-
-  if(sign && (sign = (xx < 0)))
-    x = -xx;
-  else
-    x = xx;
-
-  i = 0;
-  do {
-    buf[i++] = digits[x % base];
-  } while((x /= base) != 0);
-
-  if(sign)
-    buf[i++] = '-';
-
-  while(--i >= 0)
-    consputc(buf[i]);
-}
-
-static void
-printptr(uint64 x)
-{
-  int i;
-  consputc('0');
-  consputc('x');
-  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
-    consputc(digits[x >> (sizeof(uint64) * 8 - 4)]);
-}
-
-// Print to the console.
-int
-printf(char *fmt, ...)
-{
-  va_list ap;
-  int i, cx, c0, c1, c2, locking;
-  char *s;
-
-  locking = pr.locking;
-  if(locking)
-    acquire(&pr.lock);
-
-  va_start(ap, fmt);
-  for(i = 0; (cx = fmt[i] & 0xff) != 0; i++){
-    if(cx != '%'){
-      consputc(cx);
-      continue;
-    }
-    i++;
-    c0 = fmt[i+0] & 0xff;
-    c1 = c2 = 0;
-    if(c0) c1 = fmt[i+1] & 0xff;
-    if(c1) c2 = fmt[i+2] & 0xff;
-    if(c0 == 'd'){
-      printint(va_arg(ap, int), 10, 1);
-    } else if(c0 == 'l' && c1 == 'd'){
-      printint(va_arg(ap, uint64), 10, 1);
-      i += 1;
-    } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
-      printint(va_arg(ap, uint64), 10, 1);
-      i += 2;
-    } else if(c0 == 'u'){
-      printint(va_arg(ap, int), 10, 0);
-    } else if(c0 == 'l' && c1 == 'u'){
-      printint(va_arg(ap, uint64), 10, 0);
-      i += 1;
-    } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
-      printint(va_arg(ap, uint64), 10, 0);
-      i += 2;
-    } else if(c0 == 'x'){
-      printint(va_arg(ap, int), 16, 0);
-    } else if(c0 == 'l' && c1 == 'x'){
-      printint(va_arg(ap, uint64), 16, 0);
-      i += 1;
-    } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
-      printint(va_arg(ap, uint64), 16, 0);
-      i += 2;
-    } else if(c0 == 'p'){
-      printptr(va_arg(ap, uint64));
-    } else if(c0 == 's'){
-      if((s = va_arg(ap, char*)) == 0)
-        s = "(null)";
-      for(; *s; s++)
-        consputc(*s);
-    } else if(c0 == '%'){
-      consputc('%');
-    } else if(c0 == 0){
-      break;
-    } else {
-      // Print unknown % sequence to draw attention.
-      consputc('%');
-      consputc(c0);
-    }
-
-#if 0
-    switch(c){
-    case 'd':
-      printint(va_arg(ap, int), 10, 1);
-      break;
-    case 'x':
-      printint(va_arg(ap, int), 16, 1);
-      break;
-    case 'p':
-      printptr(va_arg(ap, uint64));
-      break;
-    case 's':
-      if((s = va_arg(ap, char*)) == 0)
-        s = "(null)";
-      for(; *s; s++)
-        consputc(*s);
-      break;
-    case '%':
-      consputc('%');
-      break;
-    default:
-      // Print unknown % sequence to draw attention.
-      consputc('%');
-      consputc(c);
-      break;
-    }
-#endif
-  }
-  va_end(ap);
-
-  if(locking)
-    release(&pr.lock);
-
-  return 0;
-}
+
+static void
+putch(int ch, int *cnt)
+{
+  consputc(ch);
+  (void)*cnt++;
+}
+
+int
+vcprintf(const char *fmt, va_list ap)
+{
+  int cnt = 0;
+
+  vprintfmt((void*)putch, &cnt, fmt, ap);
+  return cnt;
+}
+
+int
+printf(char *fmt, ...)
+{
+  int locking, cnt;
+  va_list ap;
+
+  locking = pr.locking;
+  if(locking)
+    acquire(&pr.lock);
+
+  va_start(ap, fmt);
+  cnt = vcprintf(fmt, ap);
+  va_end(ap);
+
+  if(locking)
+    release(&pr.lock);
+
+  return cnt;
+}

void
panic(char *s)
...
```
</details>

å†ãƒ“ãƒ«ãƒ‰ã—ãŸå¾Œã€`make qemu`ã‚’å®Ÿè¡Œã—ã¦xv6ã‚’èµ·å‹•ã•ã›ã¾ã™ã€‚

```
xv6 kernel is booting

hart 1 starting
hart 2 starting
init: starting sh
```

> [!NOTE]
> ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›é–¢æ•°ã‚’å·®ã—æ›¿ãˆãŸå¾Œã‚‚å•é¡Œãªãã¦ãƒ†ã‚­ã‚¹ãƒˆãŒå‡ºåŠ›ã•ã‚Œã‚‹ã¯ãšã§ã™ã€‚

## 2.3. ç¾åœ¨æ™‚åˆ»ã®å–å¾—

### 2.3.1. RTCï¼ˆReal Time Clockï¼‰ã®åˆ©ç”¨

x86ç‰ˆã®xv6ã«ã¯RTCã‹ã‚‰æ™‚åˆ»æƒ…å ±ã‚’å–å¾—ã™ã‚‹ãŸã‚ã®é–¢æ•°ï¼ˆ`cmostime()`ï¼‰ãŒç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ãŒã€RISC-Vç‰ˆã®xv6ã«ã¯RTCé–¢é€£ã®ã‚³ãƒ¼ãƒ‰ã¯ç”¨æ„ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚QEMUãŒRISC-Vç’°å¢ƒå‘ã‘ã«ã‚‚RTCã‚’æä¾›ã—ã¦ãã‚Œã¦ã„ã‚‹ã®ã§ã“ã‚Œã‚’åˆ©ç”¨ã—ã¦ç¾åœ¨æ™‚åˆ»ã‚’å–å¾—ã™ã‚‹æ©Ÿèƒ½ã‚’è¿½åŠ ã—ã¾ã™ã€‚

> [!NOTE]
> RISC-Vç‰ˆã®xv6ã§ã¯ã‚¿ã‚¤ãƒãƒ¼å‰²ã‚Šè¾¼ã¿ã‚’ç”¨ã„ã¦100ãƒŸãƒªç§’æ¯ã«tickã‚’ã‚«ã‚¦ãƒ³ãƒˆã™ã‚‹æ©Ÿèƒ½ã ã‘ãŒå­˜åœ¨ã—ã¦ã„ã¾ã™ã€‚

QEMUãŒRISC-Vç’°å¢ƒã§æä¾›ã—ã¦ã„ã‚‹RTCã¯ã€ŒGoldfish RTCã€ã§ã™ã€‚ã“ã‚Œã¯GoogleãŒAndroidã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿å‘ã‘ã«é–‹ç™ºã—ãŸMMIOãƒ™ãƒ¼ã‚¹ã®RTCã§ã€ãƒãƒƒãƒ”ãƒ³ã‚°ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªã‚¢ãƒ‰ãƒ¬ã‚¹ã¸ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ã§RTCã®ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’èª­ã¿å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚

#### ğŸŒŸ RTCã®ç‰©ç†ã‚¢ãƒ‰ãƒ¬ã‚¹ã®å®šç¾©

ã¾ãšã€QEMUãŒæä¾›ã™ã‚‹RTCã®ç‰©ç†ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’`kernel/memlayout.h`ã«å®šç¾©ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/memlayout.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>
	
```diff
 // Physical memory layout

 // qemu -machine virt is set up like this,
 // based on qemu's hw/riscv/virt.c:
 //
 // 00001000 -- boot ROM, provided by qemu
+// 00101000 -- RTC
 // 02000000 -- CLINT
 // 0C000000 -- PLIC
 // 10000000 -- uart0 
 // 10001000 -- virtio disk 
 // 80000000 -- boot ROM jumps here in machine mode
 //             -kernel loads the kernel here
 // unused RAM after 80000000.

 // the kernel uses physical memory thus:
 // 80000000 -- entry.S, then kernel text and data
 // end -- start of kernel page allocation area
 // PHYSTOP -- end RAM used by the kernel

+// Goldfish RTC
+#define RTC 0x00101000L
+
 // qemu puts UART registers here in physical memory.
 #define UART0 0x10000000L
 #define UART0_IRQ 10

...
```
</details>

> [!NOTE]
> `0x00101000L`ã¨ã„ã†å€¤ã¯RTCã‚’æä¾›ã™ã‚‹QEMUã®ä»®æƒ³ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã®ä»•æ§˜ã§æ±ºã‚ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚
> - https://github.com/qemu/qemu/blob/master/hw/riscv/virt.c#L86

#### ğŸŒŸ ç‰©ç†ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ä»®æƒ³ã‚¢ãƒ‰ãƒ¬ã‚¹ã«ãƒãƒƒãƒ”ãƒ³ã‚°

`kernel/vm.c`ã«ã‚ã‚‹`kvmmake()`ã®ä¸­ã«ã€RTCã®ç‰©ç†ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ä»®æƒ³ã‚¢ãƒ‰ãƒ¬ã‚¹ã«ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹ãŸã‚ã®ã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/vm.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...

 // Make a direct-map page table for the kernel.
 pagetable_t
 kvmmake(void)
 {
   pagetable_t kpgtbl;

   kpgtbl = (pagetable_t) kalloc();
   memset(kpgtbl, 0, PGSIZE);

+  // rtc registers
+  kvmmap(kpgtbl, RTC, RTC, PGSIZE, PTE_R | PTE_W);
+
   // uart registers
   kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);

...
 }

...
```
</details>

> [!NOTE]
> xv6ã‚«ãƒ¼ãƒãƒ«ã§ã¯ãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆãƒãƒƒãƒ”ãƒ³ã‚°ãŒæ¡ç”¨ã•ã‚Œã¦ãŠã‚Šã€ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹ç‰©ç†ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ä»®æƒ³ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ã©ã¡ã‚‰ã‚‚åŒã˜å€¤ã¨ãªã‚Šã¾ã™ã€‚

#### ğŸŒŸ RTCã‹ã‚‰æ™‚åˆ»æƒ…å ±ã‚’èª­ã¿å‡ºã™é–¢æ•°

Goldfish RTCã¯8ã¤ã®32bitãƒ¬ã‚¸ã‚¹ã‚¿ã‚’æŒã¡ã¾ã™ãŒã€ã“ã®ã†ã¡æ™‚åˆ»æƒ…å ±ã«é–¢é€£ã™ã‚‹ã®ã¯`RTC_TIME_LOW`ã¨`RTC_TIME_HIGH`ã®2ã¤ã§ã™ã€‚ã“ã®2ã¤ã®ãƒ¬ã‚¸ã‚¹ã‚¿ã«ã€64bitã®æ™‚åˆ»æƒ…å ±ã‚’32bitã¥ã¤æ ¼ç´ã—ã¦ã„ã¾ã™ã€‚ãƒªãƒˆãƒ«ã‚¨ãƒ³ãƒ‡ã‚£ã‚¢ãƒ³ã®ç’°å¢ƒã§ã‚ã‚Œã°`RTC_TIME_LOW`ã‹ã‚‰ã¾ã¨ã‚ã¦64bitèª­ã¿å‡ºã™ã“ã¨ã§RTCãŒä¿æŒã—ã¦ã„ã‚‹æ™‚åˆ»æƒ…å ±ã‚’ãã®ã¾ã¾å–å¾—ã§ãã¾ã™ã€‚

> [!NOTE]
> 64bitã®æ™‚åˆ»æƒ…å ±ã¯UNIXã‚¨ãƒãƒƒã‚¯ï¼ˆ1970å¹´1æœˆ1æ—¥åˆå‰0æ™‚0åˆ†0ç§’ UTCï¼‰ã‹ã‚‰ã®çµŒéãƒŠãƒç§’ã®å€¤ã¨ãªã£ã¦ã„ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/rtc.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```c
#include "types.h"
#include "riscv.h"
#include "memlayout.h"
#include "defs.h"

#define RTC_TIME_LOW        0x00
#define RTC_TIME_HIGH       0x04
#define RTC_ALARM_LOW       0x08
#define RTC_ALARM_HIGH      0x0c
#define RTC_IRQ_ENABLED     0x10
#define RTC_CLEAR_ALARM     0x14
#define RTC_ALARM_STATUS    0x18
#define RTC_CLEAR_INTERRUPT 0x1c

uint64
rtcread(void)
{
  return *(volatile uint64 *)(RTC + RTC_TIME_LOW);
}
```
</details>

#### ğŸŒŸ ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—å®£è¨€ã®è¿½åŠ 

è¿½åŠ ã—ãŸé–¢æ•°ã®ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—å®£è¨€ã‚’`kenel/defs.h`ã«è¿½åŠ ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/defs.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...
 int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
 int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
 void            procdump(void);

+// rtc.c
+uint64          rtcread(void);

 // swtch.S
 void            swtch(struct context*, struct context*);

...
```
</details>

#### ğŸŒŸ Makefileã®ä¿®æ­£

æ–°ã—ãã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¿½åŠ ã—ãŸã®ã§ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒªã‚¹ãƒˆï¼ˆ`OBJS`ï¼‰ã«å®šç¾©ã‚’è¿½åŠ ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• Makefileï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
 K=kernel
 U=user

 OBJS = \
...
   $K/pipe.o \
   $K/exec.o \
   $K/sysfile.o \
   $K/kernelvec.o \
   $K/plic.o \
+  $K/rtc.o \
   $K/virtio_disk.o \

...
```
</details>

#### ğŸŒŸ å‹•ä½œç¢ºèª

`kernel/main.c`ã®`main()`ã«å‹•ä½œç¢ºèªç”¨ã®ã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ã¾ã™ã€‚

- `rtcread()`ã‚’å‘¼ã³å‡ºã—ã¦64bitã®æ™‚åˆ»æƒ…å ±ã‚’å–å¾—
- 64bitã®æ™‚åˆ»æƒ…å ±ã‚’ã€Œç§’ã€ã¨ã€ŒãƒŠãƒç§’ã€ã«åˆ†ã‘ã¦å‡ºåŠ›

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/main.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...
 // start() jumps here in supervisor mode on all CPUs.
 void
 main()
 {
   if(cpuid() == 0){
     consoleinit();
     printfinit();
     printf("\n");
     printf("xv6 kernel is booting\n");
     printf("\n");
     kinit();         // physical page allocator
     kvminit();       // create kernel page table
     kvminithart();   // turn on paging
     procinit();      // process table
     trapinit();      // trap vectors
     trapinithart();  // install kernel trap vector
     plicinit();      // set up interrupt controller
     plicinithart();  // ask PLIC for device interrupts
     binit();         // buffer cache
     iinit();         // inode table
     fileinit();      // file table
     virtio_disk_init(); // emulated hard disk
+    uint64 rtc = rtcread();
+    printf("%ld.%ld\n", rtc / 1000000000, rtc % 1000000000);
     userinit();      // first user process
     __sync_synchronize();
     started = 1;
   } else {
     while(started == 0)
       ;
     __sync_synchronize();
     printf("hart %d starting\n", cpuid());
     kvminithart();    // turn on paging
     trapinithart();   // install kernel trap vector
     plicinithart();   // ask PLIC for device interrupts
   }

   scheduler();        
 }
```
</details>

å†ãƒ“ãƒ«ãƒ‰ã—ãŸå¾Œã€`make qemu`ã‚’å®Ÿè¡Œã—ã¦xv6ã‚’èµ·å‹•ã•ã›ã¾ã™ã€‚

```
xv6 kernel is booting

1754986635.308689000
hart 1 starting
hart 2 starting
init: starting sh
$ 
```

ã‚·ã‚§ãƒ«ãŒç«‹ã¡ä¸ŠãŒã‚‹å‰ã®èµ·å‹•ãƒ­ã‚°ã®ä¸­ã«ã€Œ`ç§’.ãƒŠãƒç§’`ã€ã®å½¢å¼ã§æ™‚åˆ»æƒ…å ±ãŒå‡ºåŠ›ã•ã‚Œã¾ã™ã€‚ã“ã®ã†ã¡ç§’ã®éƒ¨åˆ†ã¯UNIXã‚¿ã‚¤ãƒ ãã®ã‚‚ã®ã§ã™ã€‚

> [!TIP]
> `date`ã‚³ãƒãƒ³ãƒ‰ã‚’åˆ©ç”¨ã™ã‚‹ã¨UNIXã‚¿ã‚¤ãƒ ã‚’ä»»æ„ã®æ›¸å¼ã®æ™‚åˆ»ã«å¤‰æ›ã§ãã‚‹ã®ã§ã€ã“ã‚Œã‚’åˆ©ç”¨ã—ã¦å‡ºåŠ›ã•ã‚Œã¦ã„ã‚‹UNIXã‚¿ã‚¤ãƒ ãŒæ­£ã—ã„å€¤ã‹ã©ã†ã‹æ¤œè¨¼ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚é–‹ç™ºç’°å¢ƒã®ã‚·ã‚§ãƒ«ã§æ¬¡ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚
>
> ```
> $ date -d @1754986635 +"%Y/%m/%d %T"
> ```


### 2.3.2. ç¾åœ¨æ™‚åˆ»ã‚’å¾—ã‚‹é–¢æ•°ã®è¿½åŠ 

`rtcread()`ã§RTCã‹ã‚‰ç¾åœ¨æ™‚åˆ»ã‚’å–å¾—ã§ãã‚‹ã‚ˆã†ã«ãªã£ãŸã®ã§ã€ã“ã‚Œã‚’ãƒ™ãƒ¼ã‚¹ã«ã—ã¦ç¾åœ¨æ™‚åˆ»ã‚’å¾—ã‚‹ãŸã‚ã«ã‚ˆãä½¿ã‚ã‚Œã¦ã„ã‚‹`time()`ã¨`gettimeofday()`ã‚’ä½œæˆã—ã¾ã™ã€‚

#### ğŸŒŸ å‹å®šç¾©ã®è¿½åŠ 

`kernel/types.h`ã«ã€`time()`ãŒä½¿ç”¨ã™ã‚‹`time_t`ã®å®šç¾©ã‚’è¿½åŠ ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/types.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
 typedef unsigned int   uint;
 typedef unsigned short ushort;
 typedef unsigned char  uchar;

 typedef unsigned char uint8;
 typedef unsigned short uint16;
 typedef unsigned int  uint32;
 typedef unsigned long uint64;

 typedef uint64 pde_t;

+typedef long time_t;
+
 #if defined(_STDIO_H)
 #define MKFS
 #endif

...
```
</details>

#### ğŸŒŸ æ§‹é€ ä½“å®šç¾©ã®è¿½åŠ 

æ–°ã—ã`kernel/time.h`ã‚’ä½œæˆã—ã€`gettimeofday()`ãŒä½¿ç”¨ã™ã‚‹`struct timeval`ã‚’å®šç¾©ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“ kernel/time.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```c
struct timeval {
  long tv_sec;
  long tv_usec;
};
```
</details>

#### ğŸŒŸ é–¢æ•°ã®è¿½åŠ 

æ–°ã—ã`kernel/time.c`ã‚’ä½œæˆã—ã€ä»¥ä¸‹ã®å†…å®¹ã‚’è¨˜è¿°ã—ã¦ãã ã•ã„ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/time.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```c
#include "types.h"
#include "riscv.h"
#include "defs.h"
#include "time.h"

time_t
time(time_t *t)
{
  time_t _t;
  if (!t)
    t = &_t;
  *t = rtcread() / 1000000000;
  return *t;
}

int
gettimeofday(struct timeval *tv, void *tz)
{
  (void)tz;
  uint64 rtc = rtcread();
  tv->tv_sec = rtc / 1000000000;
  tv->tv_usec = (rtc % 1000000000) / 1000;
  return 0;
}
```
</details>

#### ğŸŒŸ ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—å®£è¨€ã®è¿½åŠ 

è¿½åŠ ã—ãŸé–¢æ•°ã®ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—å®£è¨€ã‚’`kernel/defs.h`ã«è¿½åŠ ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/defs.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
 struct buf;
 struct context;
 struct file;
 struct inode;
 struct pipe;
 struct proc;
 struct spinlock;
 struct sleeplock;
 struct stat;
 struct superblock;
+struct timeval;

...

 // syscall.c
 void            argint(int, int*);
 int             argstr(int, char*, int);
 void            argaddr(int, uint64 *);
 int             fetchstr(uint64, char*, int);
 int             fetchaddr(uint64, uint64*);
 void            syscall();

+// time.c
+time_t          time(time_t*);
+int             gettimeofday(struct timeval*, void*);

 // trap.c
 extern uint     ticks;
 void            trapinit(void);
 void            trapinithart(void);
 extern struct spinlock tickslock;
 void            usertrapret(void);

...
```
</details>

#### ğŸŒŸ Makefileã®ä¿®æ­£

æ–°ã—ãã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¿½åŠ ã—ãŸã®ã§ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒªã‚¹ãƒˆï¼ˆ`OBJS`ï¼‰ã«å®šç¾©ã‚’è¿½åŠ ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• Makefileï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
 K=kernel
 U=user

 OBJS = \
...
   $K/sysfile.o \
   $K/kernelvec.o \
   $K/plic.o \
   $K/rtc.o \
+  $K/time.o \
   $K/virtio_disk.o

...
```
</details>

#### ğŸŒŸ å‹•ä½œç¢ºèª

`kernel/main.c`ã®`main()`ã«ã‚ã‚‹å‹•ä½œç¢ºèªç”¨ã®ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãæ›ãˆã¾ã™ã€‚

> [!WARNING]
> `gettimeofday()`ã‚’ä½¿ç”¨ã™ã‚‹éš›ã¯`time.h`ãŒå¿…è¦ãªã®ã§ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ã‚’å¿˜ã‚Œãªã„ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/main.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
 #include "types.h"
 #include "param.h"
 #include "memlayout.h"
 #include "riscv.h"
 #include "defs.h"
+#include "time.h"

 volatile static int started = 0;

 // start() jumps here in supervisor mode on all CPUs.
 void
 main()
 {
...
-    uint64 rtc = rtcread();
-    printf("%ld.%ld\n", rtc / 1000000000, rtc % 1000000000);
+    struct timeval tv;
+    gettimeofday(&tv, NULL);
+    printf("tv: {sec: %ld, usec: %ld}\n", tv.tv_sec, tv.tv_usec);
...
 }
```
</details>

å†ãƒ“ãƒ«ãƒ‰ã—ãŸå¾Œã€`make qemu`ã‚’å®Ÿè¡Œã—ã¦xv6ã‚’èµ·å‹•ã•ã›ã¾ã™ã€‚

```
xv6 kernel is booting

tv: {sec: 1754986939, usec: 308376}
hart 2 starting
hart 1 starting
init: starting sh
$
```

`struct timeval`å‹ã®å¤‰æ•°ãŒä¿æŒã—ã¦ã„ã‚‹ç§’ã¨ãƒã‚¤ã‚¯ãƒ­ç§’ãŒå‡ºåŠ›ã•ã‚Œã¾ã™ã€‚

> [!NOTE]
> ãƒŠãƒç§’ã®ç²¾åº¦ãŒå¿…è¦ãªå ´åˆã¯`struct timespec`ã‚’è¿”ã™`clock_gettime()`ã‚’ä½œæˆã™ã‚‹ã¨ã„ã„ã§ã—ã‚‡ã†ã€‚

### 2.3.3. ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å½¢å¼ã¸ã®å¤‰æ›

UNIXã‚¿ã‚¤ãƒ ã®ã¾ã¾ã ã¨å¯èª­æ€§ãŒä¹ã—ã„ãŸã‚ã€ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å½¢å¼ã®æ—¥æ™‚æƒ…å ±ã‚’ä¿æŒã™ã‚‹`struct tm`ã‚’è¿½åŠ ã—ã¾ã™ã€‚åŠ ãˆã¦ã€UNIXã‚¿ã‚¤ãƒ ã¨ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å½¢å¼ã®å€¤ã‚’ç›¸äº’ã«å¤‰æ›ã™ã‚‹ãŸã‚ã®é–¢æ•°ã‚’ä½œã‚Šã¾ã™ã€‚

#### ğŸŒŸ æ§‹é€ ä½“å®šç¾©ã®è¿½åŠ 

ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å½¢å¼ã®æ—¥æ™‚æƒ…å ±ã‚’æ‰±ã†ãŸã‚ã®æ§‹é€ ä½“ï¼ˆ`struct tm`ï¼‰ã®å®šç¾©ã‚’`kernel/time.h`ã«è¿½åŠ ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/time.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
 struct timeval {
   long tv_sec;
   long tv_usec;
 };
+
+struct tm {
+  int tm_sec;   // 0-60
+  int tm_min;   // 0-59
+  int tm_hour;  // 0-23
+  int tm_mday;  // 1-31
+  int tm_mon;   // 0-11
+  int tm_year;  // since 1900
+  int tm_wday;  // 0-6
+  int tm_yday;  // 0-365
+  int tm_isdst; // zero
+};
```
</details>

> [!IMPORTANT]
> `struct tm`ã‚’æ‰±ã†éš›ã«ã¯ä»¥ä¸‹ã®ç‚¹ã«æ³¨æ„ã—ã¾ã—ã‚‡ã†ã€‚
>
> - `tm_mday`ï¼ˆæ—¥ï¼‰ã ã‘`1`ã‹ã‚‰å§‹ã¾ã‚‹
> - `tm_year`ï¼ˆå¹´ï¼‰ã¯`1900`å¹´ã‹ã‚‰ã®çµŒéå¹´æ•°
> - `tm_wday`ï¼ˆæ›œæ—¥ï¼‰ã¯æ—¥æ›œæ—¥ï¼ˆ`0`ï¼‰ã‹ã‚‰åœŸæ›œæ—¥ï¼ˆ`6`ï¼‰ã¾ã§ã®å€¤
> - `tm_isdst`ã¯ã‚µãƒãƒ¼ã‚¿ã‚¤ãƒ ã«é–¢ã™ã‚‹å€¤ï¼ˆã“ã“ã§ã¯å¸¸ã«ã‚¼ãƒ­ã«ã—ã¦ãŠãï¼‰

#### ğŸŒŸ é–¢æ•°ã®è¿½åŠ 

ã“ã“ã§ã¯ã€`kernel/time.c`ã¸ä»¥ä¸‹ã®4ã¤ã®é–¢æ•°ã‚’è¿½åŠ ã—ã¾ã™ã€‚

- `isreapyear()`: ã†ã‚‹ã†å¹´ã‚’åˆ¤å®šã™ã‚‹ãŸã‚ã®é–¢æ•°ï¼ˆå†…éƒ¨åˆ©ç”¨ã®ã¿ï¼‰
- `ndays()`: æŒ‡å®šã—ãŸå¹´æœˆã«å­˜åœ¨ã™ã‚‹æ—¥æ•°ã‚’å¾—ã‚‹ãŸã‚ã®é–¢æ•°ï¼ˆå†…éƒ¨åˆ©ç”¨ã®ã¿ï¼‰
- `mktime()`: ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å½¢å¼ã®å€¤ï¼ˆ`struct tm`ï¼‰ã‹ã‚‰UNIXã‚¿ã‚¤ãƒ ï¼ˆ`time_t`ï¼‰ã¸å¤‰æ›ã™ã‚‹é–¢æ•°
- `localtime_r()`: UNIXã‚¿ã‚¤ãƒ ï¼ˆ`time_t`ï¼‰ã‹ã‚‰ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å½¢å¼ã®å€¤ï¼ˆ`struct tm`ï¼‰ã¸å¤‰æ›ã™ã‚‹é–¢æ•°

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/time.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...

 int
 gettimeofday(struct timeval *tv, void *tz)
 {
   (void)tz;
   uint64 rtc = rtcread();
   tv->tv_sec = rtc / 1000000000;
   tv->tv_usec = (rtc % 1000000000) / 1000;
   return 0;
 }

+static int
+isleapyear(int y)
+{
+  return (y % 4 == 0 && y % 100 != 0) || (y % 400 == 0);
+}
+
+static int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
+
+static int
+ndays(int y, int m)
+{
+  int n = days[m];
+
+  if (m == 1 && isleapyear(y)) {
+    n++;
+  }
+  return n;
+}
+
+time_t
+mktime(struct tm *tm)
+{
+  const int epoch = 1970;
+  time_t result = 0;
+
+  for (int y = epoch; y < tm->tm_year + 1900; y++) {
+    result += (isleapyear(y) ? 366 : 365) * 24 * 3600;
+  }
+  for (int m = 0; m < tm->tm_mon; m++) {
+    result += ndays(tm->tm_year + 1900, m) * 24 * 3600;
+  }
+  result += (tm->tm_mday - 1) * 24 * 3600;
+  result += tm->tm_hour * 3600;
+  result += tm->tm_min * 60;
+  result += tm->tm_sec;
+  result -= 9 * 3600; // JST
+  return result;
+}
+
+struct tm *
+localtime_r(const time_t *timep, struct tm *result)
+{
+  time_t local_time;
+
+  local_time = *timep + (9 * 3600); // JST
+  result->tm_sec = local_time % 60;
+  local_time /= 60;
+  result->tm_min = local_time % 60;
+  local_time /= 60;
+  result->tm_hour = local_time % 24;
+  local_time /= 24;
+
+  int days = local_time;
+  result->tm_wday = (days + 4) % 7;
+
+  int y = 1970;
+  while (1) {
+    int n = isleapyear(y) ? 366 : 365;
+    if (days < n) {
+      break;
+    }
+    days -= n;
+    y++;
+  }
+  result->tm_year = y - 1900;
+  result->tm_yday = days;
+
+  int m = 0;
+  while (1) {
+    int n = ndays(y, m);
+    if (days < n) {
+      break;
+    }
+    days -= n;
+    m++;
+  }
+  result->tm_mon = m;
+  result->tm_mday = days + 1;
+  result->tm_isdst = 0;
+  return result;
+}
```
</details>

> [!WARNING]
> ç°¡ç•¥åŒ–ã®ãŸã‚ã«ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å½¢å¼ã§ã¯å›ºå®šçš„ã«æ—¥æœ¬ã®ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ï¼ˆJSTï¼‰ã«åˆã‚ã›ãŸå€¤ã‚’ä¿æŒã™ã‚‹ã‚ˆã†ã«ã—ã¦ã¾ã™ã€‚

#### ğŸŒŸ ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—å®£è¨€ã®è¿½åŠ 

è¿½åŠ ã—ãŸé–¢æ•°ã®ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—å®£è¨€ã‚’`kernel/defs.h`ã«è¿½åŠ ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/defs.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
 struct buf;
 struct context;
 struct file;
 struct inode;
 struct pipe;
 struct proc;
 struct spinlock;
 struct sleeplock;
 struct stat;
 struct superblock;
 struct timeval;
+struct tm;

...


 // time.c
 time_t          time(time_t*);
 int             gettimeofday(struct timeval*, void*);
+time_t          mktime(struct tm*);
+struct tm*      localtime_r(const time_t*, struct tm*);

...
```
</details>

#### ğŸŒŸ å‹•ä½œç¢ºèª

`kernel/main.c`ã®`main()`ã«ã‚ã‚‹ã€å‹•ä½œç¢ºèªç”¨ã®ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãæ›ãˆã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/main.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...
     struct timeval tv;
     gettimeofday(&tv, NULL);
     printf("tv: {sec:%ld, usec:%ld}\n", tv.tv_sec, tv.tv_usec);
+    struct tm tm;
+    localtime_r(&tv.tv_sec, &tm);
+    printf("%04d/%02d/%02d %02d:%02d:%02d\n",
+      tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
+    printf("%ld\n", mktime(&tm));
...
```
</details>

å†ãƒ“ãƒ«ãƒ‰ã—ãŸå¾Œã€`make qemu`ã‚’å®Ÿè¡Œã—ã¦xv6ã‚’èµ·å‹•ã•ã›ã¾ã™ã€‚

```
xv6 kernel is booting

tv: {sec: 1754987184, usec: 308273}
2025/08/12 17:26:24
1754987184
hart 1 starting
hart 2 starting
init: starting sh
$
```

`struct timeval`ã®å€¤ã«ç¶šã‘ã¦ã€`localtime_r()`ã§å–å¾—ã—ãŸ`struct tm`ã®å€¤ã‚’ç”¨ã„ãŸã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å½¢å¼ã®æ—¥æ™‚æƒ…å ±ã¨ã€`mktime()`ã§`struct tm`ã‹ã‚‰é€†å¤‰æ›ã—ãŸUNIXã‚¿ã‚¤ãƒ ãŒå‡ºåŠ›ã•ã‚Œã‚‹ã¯ãšã§ã™ã€‚

## 2.4. ä¾¿åˆ©ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ç§»æ¤

è‡ªä½œãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã®å®Ÿè£…ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã®ä¾¿åˆ©ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆ`util.c`ï½¤`util.h`ï¼‰ã‚’å…ˆã«ç§»æ¤ã—ã¦ãŠãã¾ã™ã€‚

#### ğŸŒŸ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ä½œæˆ

è‡ªä½œãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã®ã‚³ãƒ¼ãƒ‰ã¯`kernel/net`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆã—ã¦ãã®ä¸­ã«é…ç½®ã™ã‚‹ã“ã¨ã«ã—ã¾ã™ã€‚ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ä¾å­˜ã®ã‚³ãƒ¼ãƒ‰ã‚’é…ç½®ã™ã‚‹ãŸã‚ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¾ã§ä¸€æ‹¬ã§ä½œæˆã—ã¾ã™ã€‚

```
$ mkdir -p kernel/net/platform/xv6-riscv
```

#### ğŸŒŸ Makefileã®ä¿®æ­£

æ–°ã—ãä½œæˆã—ãŸãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ãƒ‘ã‚¹ã‚„`make clean`ã®å¯¾è±¡ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«è¿½åŠ ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• Makefileï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
 K=kernel
 U=user
+N=$K/net
+P=$N/platform/xv6-riscv

...

 CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb -gdwarf-2
 CFLAGS += -MD
 CFLAGS += -mcmodel=medany
 CFLAGS += -ffreestanding
 CFLAGS += -fno-common -nostdlib
 CFLAGS += -fno-builtin-strncpy -fno-builtin-strncmp -fno-builtin-strlen -fno-builtin-memset
 CFLAGS += -fno-builtin-memmove -fno-builtin-memcmp -fno-builtin-log -fno-builtin-bzero
 CFLAGS += -fno-builtin-strchr -fno-builtin-exit -fno-builtin-malloc -fno-builtin-putc
 CFLAGS += -fno-builtin-free
 CFLAGS += -fno-builtin-memcpy -Wno-main
 CFLAGS += -fno-builtin-printf -fno-builtin-fprintf -fno-builtin-vprintf
-CFLAGS += -I.
+CFLAGS += -I. -I $K -I $N -I $P
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)

...

--include kernel/*.d user/*.d
+-include $K/*.d $U/*.d $N/*.d $P/*.d

 clean: 
 	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
 	*/*.o */*.d */*.asm */*.sym \
+	$N/*.o $N/*.d $P/*.o $P/*.d \
 	$U/initcode $U/initcode.out $K/kernel fs.img \
 	mkfs/mkfs .gdbinit \
        $U/usys.S \
 	$(UPROGS)

...
```
</details>

#### ğŸŒŸ ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ä¾å­˜ã‚³ãƒ¼ãƒ‰ã®è¿½åŠ 

ã¾ãšã€ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ä¾å­˜ã®ã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ã¾ã™ã€‚ã„ã¾ã®æ™‚ç‚¹ã§ã¯ãƒ¡ãƒ¢ãƒªé–¢é€£ã®ã‚³ãƒ¼ãƒ‰ã ã‘å«ã‚ã¦ã„ã¾ã™ã€‚ãã®ä»–ã¯å¿…è¦ã«ãªã£ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§éšæ™‚è¿½åŠ ã—ã¦ã„ãã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/net/platform/xv6-riscv/platform.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```c
#ifndef PLATFORM_H
#define PLATFORM_H

#include "types.h"
#include "riscv.h"
#include "defs.h"

/*
 * Memory
 */

static inline void *
memory_alloc(size_t size)
{
    void *p;

    if (PGSIZE < size) {
        return NULL;
    }
    p = kalloc();
    if (p) {
        memset(p, 0, size);
    }
    return p;
}

static inline void
memory_free(void *ptr)
{
    kfree(ptr);
}

/*
 * Mutex
 */

#include "param.h"
#include "spinlock.h"
#include "proc.h"



/*
 * Interrupt
 */



/*
 * Scheduler
 */



#endif
```
</details>

> [!NOTE]
> xv6ã®ã‚«ãƒ¼ãƒãƒ«å†…ã§ã¯ãƒ¡ãƒ¢ãƒªã¯`kalloc()`ã§ç¢ºä¿ã—ã¾ã™ã€‚ç¢ºä¿ã™ã‚‹ãƒ¡ãƒ¢ãƒªã®ã‚µã‚¤ã‚ºã¯æŒ‡å®šã§ããšã€å¸¸ã«ãƒšãƒ¼ã‚¸ã‚µã‚¤ã‚ºï¼ˆ4KBï¼‰ã®ãƒ¡ãƒ¢ãƒªãŒè¿”ã•ã‚Œã¾ã™ã€‚è‡ªä½œãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã§ã¯4KBã‚’è¶…ãˆã‚‹ãƒ¡ãƒ¢ãƒªã‚’ç¢ºä¿ã™ã‚‹ã“ã¨ã¯ãªã„ã®ã§ã²ã¨ã¾ãšå•é¡Œãªã„ã¯ãšã§ã™ã€‚`kalloc()`ã§ç¢ºä¿ã—ãŸãƒ¡ãƒ¢ãƒªã¯`kfree()`ã§è§£æ”¾ã—ã¾ã™ã€‚

#### ğŸŒŸ ä¾¿åˆ©ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®é…ç½®

ä¾¿åˆ©ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’`kernel/net`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ä¸‹ã«é…ç½®ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/net/util.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```c
#include "platform.h"

#include "util.h"

/*
 * Logging
 */

int
lprintf(FILE *fp, int level, const char *file, int line, const char *func, const char *fmt, ...)
{
    struct timeval tv;
    struct tm tm;
    char timestamp[32];
    int n = 0;
    va_list ap;

    flockfile(fp);
    gettimeofday(&tv, NULL);
    strftime(timestamp, sizeof(timestamp), "%T", localtime_r(&tv.tv_sec, &tm));
    n += fprintf(fp, "%s.%03d [%c] %s: ", timestamp, (int)(tv.tv_usec / 1000), level, func);
    va_start(ap, fmt);
    n += vfprintf(fp, fmt, ap);
    va_end(ap);
    n += fprintf(fp, " (%s:%d)\n", file, line);
    funlockfile(fp);
    return n;
}

void
hexdump(FILE *fp, const void *data, size_t size)
{
    unsigned char *src;
    int offset, index;

    flockfile(fp);
    src = (unsigned char *)data;
    fprintf(fp, "+------+-------------------------------------------------+------------------+\n");
    for(offset = 0; offset < (int)size; offset += 16) {
        fprintf(fp, "| %04x | ", offset);
        for(index = 0; index < 16; index++) {
            if(offset + index < (int)size) {
                fprintf(fp, "%02x ", 0xff & src[offset + index]);
            } else {
                fprintf(fp, "   ");
            }
        }
        fprintf(fp, "| ");
        for(index = 0; index < 16; index++) {
            if(offset + index < (int)size) {
                if(isascii(src[offset + index]) && isprint(src[offset + index])) {
                    fprintf(fp, "%c", src[offset + index]);
                } else {
                    fprintf(fp, ".");
                }
            } else {
                fprintf(fp, " ");
            }
        }
        fprintf(fp, " |\n");
    }
    fprintf(fp, "+------+-------------------------------------------------+------------------+\n");
    funlockfile(fp);
}

/*
 * Queue
 */

struct queue_entry {
    struct queue_entry *next;
    void *data;
};

void
queue_init(struct queue_head *queue)
{
    queue->head = NULL;
    queue->tail = NULL;
    queue->num = 0;
}

void *
queue_push(struct queue_head *queue, void *data)
{
    struct queue_entry *entry;

    if (!queue) {
        return NULL;
    }
    entry = memory_alloc(sizeof(*entry));
    if (!entry) {
        return NULL;
    }
    entry->next = NULL;
    entry->data = data;
    if (queue->tail) {
        queue->tail->next = entry;
    }
    queue->tail = entry;
    if (!queue->head) {
        queue->head = entry;
    }
    queue->num++;
    return data;
}

void *
queue_pop(struct queue_head *queue)
{
    struct queue_entry *entry;
    void *data;

    if (!queue || !queue->head) {
        return NULL;
    }
    entry = queue->head;
    queue->head = entry->next;
    if (!queue->head) {
        queue->tail = NULL;
    }
    queue->num--;
    data = entry->data;
    memory_free(entry);
    return data;
}

void *
queue_peek(struct queue_head *queue)
{
    if (!queue || !queue->head) {
        return NULL;
    }
    return queue->head->data;
}

void
queue_foreach(struct queue_head *queue, void (*func)(void *arg, void *data), void *arg)
{
    struct queue_entry *entry;

    if (!queue || !func) {
        return;
    }
    for (entry = queue->head; entry; entry = entry->next) {
        func(arg, entry->data);
    }
}

/*
 * Byteorder
 */

#ifndef __BIG_ENDIAN
#define __BIG_ENDIAN 4321
#endif
#ifndef __LITTLE_ENDIAN
#define __LITTLE_ENDIAN 1234
#endif

static int endian;

static int
byteorder(void) {
    uint32_t x = 0x00000001;

    return *(uint8_t *)&x ? __LITTLE_ENDIAN : __BIG_ENDIAN;
}

static uint16_t
byteswap16(uint16_t v)
{
    return (v & 0x00ff) << 8 | (v & 0xff00 ) >> 8;
}

static uint32_t
byteswap32(uint32_t v)
{
    return (v & 0x000000ff) << 24 | (v & 0x0000ff00) << 8 | (v & 0x00ff0000) >> 8 | (v & 0xff000000) >> 24;
}

uint16_t
hton16(uint16_t h)
{
    if (!endian) {
        endian = byteorder();
    }
    return endian == __LITTLE_ENDIAN ? byteswap16(h) : h;
}

uint16_t
ntoh16(uint16_t n)
{
    if (!endian) {
        endian = byteorder();
    }
    return endian == __LITTLE_ENDIAN ? byteswap16(n) : n;
}

uint32_t
hton32(uint32_t h)
{
    if (!endian) {
        endian = byteorder();
    }
    return endian == __LITTLE_ENDIAN ? byteswap32(h) : h;
}

uint32_t
ntoh32(uint32_t n)
{
    if (!endian) {
        endian = byteorder();
    }
    return endian == __LITTLE_ENDIAN ? byteswap32(n) : n;
}

/*
 * Checksum
 */

uint16_t
cksum16(uint16_t *addr, uint16_t count, uint32_t init)
{
    uint32_t sum;

    sum = init;
    while (count > 1) {
        sum += *(addr++);
        count -= 2;
    }
    if (count > 0) {
        sum += *(uint8_t *)addr;
    }
    while (sum >> 16) {
        sum = (sum & 0xffff) + (sum >> 16);
    }
    return ~(uint16_t)sum;
}
```
</details>


<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/net/util.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```c
#ifndef UTIL_H
#define UTIL_H

#include "platform.h"

/*
 * Compare
 */

#ifndef MAX
#define MAX(x, y) ((x) > (y) ? (x) : (y))
#endif
#ifndef MIN
#define MIN(x, y) ((x) < (y) ? (x) : (y))
#endif

/*
 * Array
 */

#define countof(x) ((sizeof(x) / sizeof(*x)))
#define tailof(x) (x + countof(x))
#define indexof(x, y) (((uintptr_t)y - (uintptr_t)x) / sizeof(*y))

/*
 * Time
 */

#define timeval_add_usec(x, y)         \
    do {                               \
        (x)->tv_sec += y / 1000000;    \
        (x)->tv_usec += y % 1000000;   \
        if ((x)->tv_usec >= 1000000) { \
            (x)->tv_sec += 1;          \
            (x)->tv_usec -= 1000000;   \
        }                              \
    } while(0);

#define timespec_add_nsec(x, y)           \
    do {                                  \
        (x)->tv_sec += y / 1000000000;    \
        (x)->tv_nsec += y % 1000000000;   \
        if ((x)->tv_nsec >= 1000000000) { \
            (x)->tv_sec += 1;             \
            (x)->tv_nsec -= 1000000000;   \
        }                                 \
    } while(0);

/*
 * Logging
 */

#define errorf(...) lprintf(stderr, 'E', __FILE__, __LINE__, __func__, __VA_ARGS__)
#define warnf(...) lprintf(stderr, 'W', __FILE__, __LINE__, __func__, __VA_ARGS__)
#define infof(...) lprintf(stderr, 'I', __FILE__, __LINE__, __func__, __VA_ARGS__)
#define debugf(...) lprintf(stderr, 'D', __FILE__, __LINE__, __func__, __VA_ARGS__)

#ifdef HEXDUMP
#define debugdump(...) hexdump(stderr, __VA_ARGS__)
#else
#define debugdump(...)
#endif

extern int
lprintf(FILE *fp, int level, const char *file, int line, const char *func, const char *fmt, ...);
extern void
hexdump(FILE *fp, const void *data, size_t size);

/*
 * Queue
 */

struct queue_entry;

struct queue_head {
    struct queue_entry *head;
    struct queue_entry *tail;
    unsigned int num;
};

extern void
queue_init(struct queue_head *queue);
extern void *
queue_push(struct queue_head *queue, void *data);
extern void *
queue_pop(struct queue_head *queue);
extern void *
queue_peek(struct queue_head *queue);
extern void
queue_foreach(struct queue_head *queue, void (*func)(void *arg, void *data), void *arg);

/*
 * Byteorder
 */

extern uint16_t
hton16(uint16_t h);
extern uint16_t
ntoh16(uint16_t n);
extern uint32_t
hton32(uint32_t h);
extern uint32_t
ntoh32(uint32_t n);

/*
 * Checksum
 */

extern uint16_t
cksum16(uint16_t *addr, uint16_t count, uint32_t init);

#endif
```
</details>

> [!IMPORTANT]
> xv6ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ã¯`-nostdinc`ãŒæŒ‡å®šã•ã‚Œã‚‹ãŸã‚ã€`#include <>`ã§ã‚·ã‚¹ãƒ†ãƒ ãƒ˜ãƒƒãƒ€ã‚’ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ã—ã¦ã„ã‚‹ç®‡æ‰€ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã—ã¾ã„ã¾ã™ã€‚ã“ã‚Œã«å¯¾å‡¦ã™ã‚‹ãŸã‚ã«ã€ã‚·ã‚¹ãƒ†ãƒ ãƒ˜ãƒƒãƒ€ã®ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ã‚’å…¨ã¦å‰Šé™¤ã—ã¦ã„ã¾ã™ã€‚
>
> ã“ã®å…ˆã§è¿½åŠ ã™ã‚‹ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯é–¢é€£ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ã¤ã„ã¦ã‚‚ã€ã‚·ã‚¹ãƒ†ãƒ ãƒ˜ãƒƒãƒ€ã®ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ã‚’å–ã‚Šé™¤ãã€æ›¿ã‚ã‚Šã«`platform.h`ã‚’å†’é ­ã§ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ã™ã‚‹ã‚ˆã†ã«å¤‰æ›´ã—ã¾ã™ã€‚

#### ğŸŒŸ ä¸è¶³ã—ã¦ã„ã‚‹æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªé–¢æ•°ã®è¿½åŠ 

xv6ã«ã¯æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒå®Ÿè£…ã•ã‚Œã¦ã„ãªã„ãŸã‚ã€å¿…è¦ãªé–¢æ•°ã¯è‡ªåˆ†ã§è¿½åŠ ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã“ã§ã¯ã€ä¾¿åˆ©ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒå¿…è¦ã¨ã™ã‚‹é–¢æ•°ã«åŠ ãˆã¦è‡ªä½œãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã®ç§»æ¤ã§å¿…è¦ã«ãªã‚‹é–¢æ•°ã‚’è¿½åŠ ã—ã¦ãŠãã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/net/platform/xv6-riscv/std.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```c
#ifndef STD_H
#define STD_H

#include <stdarg.h>

#include "time.h"

#define UINT16_MAX 65535

#define isascii(x) ((x >= 0x00) && (x <= 0x7f))
#define isprint(x) ((x >= 0x20) && (x <= 0x7e))

#define EINTR 1

extern int errno;

/*
 * STDIO
 */

typedef struct {
    /* dummy */
} FILE;

extern FILE *stderr;

#define fprintf(fp, ...) printf(__VA_ARGS__)
#define vfprintf(fp, ...) vcprintf(__VA_ARGS__)

extern void
flockfile(FILE *fp);
extern void
funlockfile(FILE *fp);
extern int
vfprintf(FILE *fp, const char *fmt, va_list ap);

/*
 * Time
 */

struct timespec {
    /* dummy */
};

extern size_t
strftime(char *s, size_t max, const char *format, const struct tm *tm);
extern void
timersub(struct timeval *a, struct timeval *b, struct timeval *res);
extern void
timerclear(struct timeval *tv);

#define timercmp(a, b, cmp) \
    ((a)->tv_sec == (b)->tv_sec ? (a)->tv_usec cmp (b)->tv_usec : (a)->tv_sec cmp (b)->tv_sec)

/*
 * Random
 */

extern void
srand(unsigned int newseed);
extern long
random(void);

/*
 * String
 */

extern void *
memcpy(void *dst, const void *src, uint n);
extern long
strtol(const char *s, char **endptr, int base);
extern char *
strrchr(const char *cp, int ch);

#endif
```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/net/platform/xv6-riscv/std.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```c
#include "platform.h"

int errno;

/*
 * STDIO
 */

FILE *stderr;

void
flockfile(FILE *fp)
{
    /* dummy */
}

void
funlockfile(FILE *fp)
{
    /* dummy */
}

/*
 * Time
 */

size_t
strftime(char *s, size_t max, const char *format, const struct tm *tm)
{
    (void)format; /* force HH:MM:SS */
    return snprintf(s, max, "%02d:%02d:%02d", tm->tm_hour, tm->tm_min, tm->tm_sec);
}

void
timersub(struct timeval *a, struct timeval *b, struct timeval *res)
{
    res->tv_sec = a->tv_sec - b->tv_sec;
    res->tv_usec = a->tv_usec - b->tv_usec;
    if (res->tv_usec < 0) {
        --res->tv_sec;
        res->tv_usec += 1000*1000;
    }
    return;
}

void
timerclear(struct timeval *tv)
{
    tv->tv_sec = 0;
    tv->tv_usec = 0;
}

/*
 * Random
 */

static unsigned int seed = 1;

void
srand(unsigned int newseed)
{
    seed = newseed;
}

long
random(void)
{
    /* Linear Congruential Generator (LCG) */
    seed = (seed * 1103515245 + 12345) % 0x7fffffff;
    return seed;
}

/*
 * String
 */

long
strtol(const char *s, char **endptr, int base)
{
    int neg = 0;
    long val = 0;

    // gobble initial whitespace
    while (*s == ' ' || *s == '\t')
        s++;

    // plus/minus sign
    if (*s == '+')
        s++;
    else if (*s == '-')
        s++, neg = 1;

    // hex or octal base prefix
    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
        s += 2, base = 16;
    else if (base == 0 && s[0] == '0')
        s++, base = 8;
    else if (base == 0)
        base = 10;

    // digits
    while (1) {
        int dig;

        if (*s >= '0' && *s <= '9')
            dig = *s - '0';
        else if (*s >= 'a' && *s <= 'z')
            dig = *s - 'a' + 10;
        else if (*s >= 'A' && *s <= 'Z')
            dig = *s - 'A' + 10;
        else
            break;
        if (dig >= base)
            break;
        s++, val = (val * base) + dig;
        // we don't properly detect overflow!
    }

    if (endptr)
        *endptr = (char *) s;
    return (neg ? -val : val);
}

char *
strrchr(const char *cp, int ch)
{
    char *save;
    char c;

    for (save = (char *) 0; (c = *cp); cp++) {
        if (c == ch) {
            save = (char *) cp;
        }
    }
    return save;
}
```
</details>

> [!NOTE]
> ä¸€éƒ¨ã€ãƒ€ãƒŸãƒ¼ã®é–¢æ•°ã‚‚å«ã‚“ã§ã„ã¾ã™ãŒä¸»ã«ä¸‹è¨˜ã®ã‚«ãƒ†ã‚´ãƒªã®é–¢æ•°ã‚’è¿½åŠ ã—ã¦ã„ã¾ã™ã€‚
> + æ¨™æº–å…¥å‡ºåŠ›
> + æ™‚åˆ»é–¢é€£
> + ãƒ©ãƒ³ãƒ€ãƒ é–¢æ•°
> + æ–‡å­—åˆ—æ“ä½œ

ã“ã®`kernel/net/platform/xv6/std.h`ã¯ã€`kernel/net/platform/xv6/platform.h`ã‹ã‚‰è‡ªå‹•çš„ã«èª­ã¿è¾¼ã¾ã‚Œã‚‹ã‚ˆã†ã«ã—ã¦ãŠãã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/net/platform/xv6-riscv/platform.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
#ifndef PLATFORM_H
#define PLATFORM_H

#include "types.h"
#include "riscv.h"
#include "defs.h"

+#include "std.h"
+
...
```
</details>

#### ğŸŒŸ å‹•ä½œç¢ºèª

ä¾¿åˆ©ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å‹•ä½œç¢ºèªã®ãŸã‚ã«ã€è‡ªä½œãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã®ãƒ¡ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ç›¸å½“ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¿½åŠ ã—ã¾ã™ã€‚

> [!WARNING]
> ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ä¸€æ™‚çš„ãªã‚‚ã®ã§å¾Œã»ã©æ­£å¼ãªã‚‚ã®ã«å·®ã—æ›¿ãˆã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/net/net.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```c
#include "platform.h"

#include "util.h"

void
netinit(void)
{
    char msg[] = "Hello, SecCamp2025!";

    debugf("%s", msg);
    debugdump(msg, sizeof(msg));
}
```
</details>

ä¾¿åˆ©ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®æ©Ÿèƒ½ã‚’ä½¿ã£ã¦ãƒ­ã‚°å‡ºåŠ›ã¨16é€²ãƒ€ãƒ³ãƒ—ã‚’ãƒ†ã‚¹ãƒˆã—ã¾ã™ã€‚

`netinit()`ã¯xv6ã®`main()`é–¢æ•°ã‹ã‚‰å‘¼ã³å‡ºã™ã“ã¨ã«ãªã‚‹ã®ã§ã€`defs.h`ã«ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—å®£è¨€ã‚’è¿½åŠ ã—ã¦ãŠãã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/defs.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...

 // virtio_disk.c
 void            virtio_disk_init(void);
 void            virtio_disk_rw(struct buf *, int);
 void            virtio_disk_intr(void);

+// net/net.c
+void            netinit(void);
+
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))

...
```
</details>

æ–°ã—ãã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¿½åŠ ã—ãŸã®ã§ã€`Makefile`ã‚’ç·¨é›†ã—ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒªã‚¹ãƒˆï¼ˆOBJSï¼‰ã«å®šç¾©ã‚’è¿½åŠ ã—ã¾ã™ã€‚

> [!NOTE]
> 16é€²ãƒ€ãƒ³ãƒ—ã®ãŸã‚ã®`debugdump()`ãƒã‚¯ãƒ­ã‚’æœ‰åŠ¹ã«ã™ã‚‹ãŸã‚ã«`CFLAGS`ã«`-DHEXDUMP`ã‚‚è¿½åŠ ã—ã¦ãŠãã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• Makefileï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
 K=kernel
 U=user
 N=$K/net
 P=$N/platform/xv6-riscv

 OBJS = \
...
   $K/plic.o \
   $K/rtc.o \
   $K/time.o \
-  $K/virtio_disk.o
+  $K/virtio_disk.o \
+  $N/util.o \
+  $N/net.o \
+  $P/std.o

...

 CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb -gdwarf-2
 CFLAGS += -MD
 CFLAGS += -mcmodel=medany
 CFLAGS += -ffreestanding
 CFLAGS += -fno-common -nostdlib
 CFLAGS += -fno-builtin-strncpy -fno-builtin-strncmp -fno-builtin-strlen -fno-builtin-memset
 CFLAGS += -fno-builtin-memmove -fno-builtin-memcmp -fno-builtin-log -fno-builtin-bzero
 CFLAGS += -fno-builtin-strchr -fno-builtin-exit -fno-builtin-malloc -fno-builtin-putc
 CFLAGS += -fno-builtin-free
 CFLAGS += -fno-builtin-memcpy -Wno-main
 CFLAGS += -fno-builtin-printf -fno-builtin-fprintf -fno-builtin-vprintf
 CFLAGS += -I.
-CFLAGS += -I. -I $K -I $N -I $P
+CFLAGS += -I. -I $K -I $N -I $P -DHEXDUMP
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)

...
```
</details>

xv6ã®`main()`é–¢æ•°ã‹ã‚‰`netinit()`ã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«ã—ã¾ã™ã€‚

> [!NOTE]
> ã“ã“ã¾ã§ã«è¿½åŠ ã—ãŸæ™‚åˆ»æƒ…å ±ã®ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã¯å‰Šé™¤ã—ã¦ã—ã¾ã„ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/main.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...
     fileinit();      // file table
     virtio_disk_init(); // emulated hard disk
-    struct timeval tv;
-    gettimeofday(&tv, NULL);
-    printf("tv: {sec:%ld, usec:%ld}\n", tv.tv_sec, tv.tv_usec);
-    struct tm tm;
-    localtime_r(&tv.tv_sec, &tm);
-    printf("%04d/%02d/%02d %02d:%02d:%02d\n",
-      tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
-    printf("%ld\n", mktime(&tm));
+    netinit();       // network stack
     userinit();      // first user process
     __sync_synchronize();
     started = 1;
...
```
</details>

å†ãƒ“ãƒ«ãƒ‰ã—ãŸå¾Œã€`make qemu`ã‚’å®Ÿè¡Œã—ã¦xv6ã‚’èµ·å‹•ã•ã›ã¾ã™ã€‚

```
xv6 kernel is booting

17:33:15.313 [D] netinit: Hello, SecCamp2025! (kernel/net/net.c:10)
+------+-------------------------------------------------+------------------+
| 0000 | 48 65 6c 6c 6f 2c 20 53 65 63 43 61 6d 70 32 30 | Hello, SecCamp20 |
| 0010 | 32 35 21 00                                     | 25!.             |
+------+-------------------------------------------------+------------------+
hart 1 starting
hart 2 starting
init: starting sh
$
```

> [!NOTE]
> è¦‹è¦šãˆã®ã‚ã‚‹æ›¸å¼ã®ãƒ­ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨16é€²ãƒ€ãƒ³ãƒ—ãŒå‡ºåŠ›ã•ã‚Œã‚‹ã¯ãšã§ã™ã€‚


ãŠç–²ã‚Œã•ã¾ã§ã—ãŸã€ã“ã‚Œã§ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã‚’ç§»æ¤ã™ã‚‹æº–å‚™ãŒæ•´ã„ã¾ã—ãŸï¼

<hr/>

[æ¬¡ã¸](03.md)
