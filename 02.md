# 2. 下準備

xv6に自作プロトコルスタックを移植するにあたって、いくつか下準備をしておきます。

## 2.1. 型定義の追加

自作プロトコルスタックで多用しているビット幅指定の数値型（`uint8_t`や`uint32_t`）などの型定義を追加しておきます。xv6では型定義を`kernel/types.h`に集約しているので、このファイルに追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📝 kernel/types.h（クリックしてコードを表示）</span></summary>

```diff
...

typedef uint64 pde_t;
+
+#if defined(_STDIO_H)
+#define MKFS
+#endif
+
+#if !defined(MKFS)
+
+#define NULL ((void *)0)
+
+typedef char int8_t;
+typedef unsigned char uint8_t;
+typedef short int16_t;
+typedef unsigned short uint16_t;
+typedef int int32_t;
+typedef unsigned int uint32_t;
+typedef long long int64_t;
+typedef unsigned long long uint64_t;
+
+typedef int64_t ssize_t;
+typedef uint64_t size_t;
+
+typedef int64_t intptr_t;
+typedef uint64_t uintptr_t;
+
+#endif
```
</details>

> [!NOTE]
> xv6を起動するために`make qemu`を実行すると、ユーザランドの実行ファイルなどを格納したディスクイメージ（`fs.img`）を作製するプログラム（`mkfs`）がコンパイルおよび実行されます。
>
> この`mkfs`は、xv6ではなくホストで実行するプログラムであるため、コンパイル時にはホスト環境のヘッダファイルが読み込まれます。ホスト環境のヘッダファイルが読み込まれると、ここで追加している型定義との衝突が発生してしまうため、`mkfs`のコンパイル時のみ追加した型定義が読み込まれないようにしています。


## 2.2. コンソール出力の改良

### 2.2.1. コンソール出力

xv6のカーネル内からコンソールへ文字列を出力するには`printf()`を使用します。

```c
printf("Hello, world!\n");
```

標準ライブラリの`printf()`と同等の関数ですが、フォーマット文字列のサポートが限定的です。

- サポートしている変換指定子は `%d`, `%ld`, `%lld`, `u`, `lu`, `llu`, `%x`, `lx`, `llx`, `%p`, `%s` のみ
- フラグ文字やフィールド幅、精度などもサポートしていない

カーネル内で使用する`printf()`のコードは`kernel/printf.c`に含まれています。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/printf.c（クリックしてコードを表示）</span></summary>

```c
// Print to the console.
int
printf(char *fmt, ...)
{
  va_list ap;
  int i, cx, c0, c1, c2, locking;
  char *s;

  locking = pr.locking;
  if(locking)
    acquire(&pr.lock);

  va_start(ap, fmt);
  for(i = 0; (cx = fmt[i] & 0xff) != 0; i++){
    if(cx != '%'){
      consputc(cx);
      continue;
    }
    i++;
    c0 = fmt[i+0] & 0xff;
    c1 = c2 = 0;
    if(c0) c1 = fmt[i+1] & 0xff;
    if(c1) c2 = fmt[i+2] & 0xff;
    if(c0 == 'd'){
      printint(va_arg(ap, int), 10, 1);
    } else if(c0 == 'l' && c1 == 'd'){
      printint(va_arg(ap, uint64), 10, 1);
      i += 1;
    } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
      printint(va_arg(ap, uint64), 10, 1);
      i += 2;
    } else if(c0 == 'u'){
      printint(va_arg(ap, int), 10, 0);
    } else if(c0 == 'l' && c1 == 'u'){
      printint(va_arg(ap, uint64), 10, 0);
      i += 1;
    } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
      printint(va_arg(ap, uint64), 10, 0);
      i += 2;
    } else if(c0 == 'x'){
      printint(va_arg(ap, int), 16, 0);
    } else if(c0 == 'l' && c1 == 'x'){
      printint(va_arg(ap, uint64), 16, 0);
      i += 1;
    } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
      printint(va_arg(ap, uint64), 16, 0);
      i += 2;
    } else if(c0 == 'p'){
      printptr(va_arg(ap, uint64));
    } else if(c0 == 's'){
      if((s = va_arg(ap, char*)) == 0)
        s = "(null)";
      for(; *s; s++)
        consputc(*s);
    } else if(c0 == '%'){
      consputc('%');
    } else if(c0 == 0){
      break;
    } else {
      // Print unknown % sequence to draw attention.
      consputc('%');
      consputc(c0);
    }

#if 0
    switch(c){
    case 'd':
      printint(va_arg(ap, int), 10, 1);
      break;
    case 'x':
      printint(va_arg(ap, int), 16, 1);
      break;
    case 'p':
      printptr(va_arg(ap, uint64));
      break;
    case 's':
      if((s = va_arg(ap, char*)) == 0)
        s = "(null)";
      for(; *s; s++)
        consputc(*s);
      break;
    case '%':
      consputc('%');
      break;
    default:
      // Print unknown % sequence to draw attention.
      consputc('%');
      consputc(c);
      break;
    }
#endif
  }
  va_end(ap);

  if(locking)
    release(&pr.lock);

  return 0;
}
```
</details>

### 2.2.2. 改良版のコンソール出力

xv6のコンソール出力は簡素すぎるため、より多くのフォーマット文字列をサポートする実装に差し替えます。今回は「JOS」という、xv6と同じくMITの6.828コースで利用されている教育用のOSからコードを拝借します。

+ Lab1 - MIT 6.828 (2018): https://pdos.csail.mit.edu/6.828/2018/labs/lab1/
+ Gitリポジトリ: https://pdos.csail.mit.edu/6.828/2018/jos.git

> [!NOTE]
> JOSのライセンスはxv6と同様にMITライセンスです。

上記のGitリポジトリから抽出した2つのファイルを、xv6の作業ディレクトリへ追加します。

> [!IMPORTANT]
> 下記のコードをそのままコピー＆ペーストしてください。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/printfmt.c（クリックしてコードを表示）</span></summary>

```c
// Stripped-down primitive printf-style formatting routines,
// used in common by printf, sprintf, fprintf, etc.
// This code is also used by both the kernel and user programs.

#include <stdarg.h>

#include "types.h"
#include "riscv.h"
#include "defs.h"
#include "error.h"

/*
 * Space or zero padding and a field width are supported for the numeric
 * formats only.
 *
 * The special format %e takes an integer error code
 * and prints a string describing the error.
 * The integer may be positive or negative,
 * so that -E_NO_MEM and E_NO_MEM are equivalent.
 */

static const char * const error_string[MAXERROR] =
{
  [E_UNSPECIFIED] = "unspecified error",
  [E_BAD_ENV] = "bad environment",
  [E_INVAL] = "invalid parameter",
  [E_NO_MEM]  = "out of memory",
  [E_NO_FREE_ENV] = "out of environments",
  [E_FAULT] = "segmentation fault",
  [E_IPC_NOT_RECV]= "env is not recving",
  [E_EOF]   = "unexpected end of file",
  [E_NO_DISK] = "no free space on disk",
  [E_MAX_OPEN]  = "too many files are open",
  [E_NOT_FOUND] = "file or block not found",
  [E_BAD_PATH]  = "invalid path",
  [E_FILE_EXISTS] = "file already exists",
  [E_NOT_EXEC]  = "file is not a valid executable",
  [E_NOT_SUPP]  = "operation not supported",
};

/*
 * Print a number (base <= 16) in reverse order,
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
   unsigned long long num, unsigned base, int width, int padc)
{
  // first recursively print all preceding (more significant) digits
  if (num >= base) {
    printnum(putch, putdat, num / base, base, width - 1, padc);
  } else {
    // print any needed pad characters before first digit
    while (--width > 0)
      putch(padc, putdat);
  }

  // then print this (the least significant) digit
  putch("0123456789abcdef"[num % base], putdat);
}

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  if (lflag >= 2)
    return va_arg(*ap, unsigned long long);
  else if (lflag)
    return va_arg(*ap, unsigned long);
  else
    return va_arg(*ap, unsigned int);
}

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  if (lflag >= 2)
    return va_arg(*ap, long long);
  else if (lflag)
    return va_arg(*ap, long);
  else
    return va_arg(*ap, int);
}


// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  register const char *p;
  register int ch, err;
  unsigned long long num;
  int base, lflag, width, precision, altflag;
  char padc;

  while (1) {
    while ((ch = *(unsigned char *) fmt++) != '%') {
      if (ch == '\0')
        return;
      putch(ch, putdat);
    }

    // Process a %-escape sequence
    padc = ' ';
    width = -1;
    precision = -1;
    lflag = 0;
    altflag = 0;
  reswitch:
    switch (ch = *(unsigned char *) fmt++) {

    // flag to pad on the right
    case '-':
      padc = '-';
      goto reswitch;

    // flag to pad with 0's instead of spaces
    case '0':
      padc = '0';
      goto reswitch;

    // width field
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      for (precision = 0; ; ++fmt) {
        precision = precision * 10 + ch - '0';
        ch = *fmt;
        if (ch < '0' || ch > '9')
          break;
      }
      goto process_precision;

    case '*':
      precision = va_arg(ap, int);
      goto process_precision;

    case '.':
      if (width < 0)
        width = 0;
      goto reswitch;

    case '#':
      altflag = 1;
      goto reswitch;

    process_precision:
      if (width < 0)
        width = precision, precision = -1;
      goto reswitch;

    // long flag (doubled for long long)
    case 'l':
    case 'z':
      lflag++;
      goto reswitch;

    // character
    case 'c':
      putch(va_arg(ap, int), putdat);
      break;

    // error message
    case 'e':
      err = va_arg(ap, int);
      if (err < 0)
        err = -err;
      if (err >= MAXERROR || (p = error_string[err]) == NULL)
        printfmt(putch, putdat, "error %d", err);
      else
        printfmt(putch, putdat, "%s", p);
      break;

    // string
    case 's':
      if ((p = va_arg(ap, char *)) == NULL)
        p = "(null)";
      if (width > 0 && padc != '-')
        for (width -= strnlen(p, precision); width > 0; width--)
          putch(padc, putdat);
      for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
        if (altflag && (ch < ' ' || ch > '~'))
          putch('?', putdat);
        else
          putch(ch, putdat);
      for (; width > 0; width--)
        putch(' ', putdat);
      break;

    // (signed) decimal
    case 'd':
      num = getint(&ap, lflag);
      if ((long long) num < 0) {
        putch('-', putdat);
        num = -(long long) num;
      }
      base = 10;
      goto number;

    // unsigned decimal
    case 'u':
      num = getuint(&ap, lflag);
      base = 10;
      goto number;

    // (unsigned) octal
    case 'o':
      // Replace this with your code.
      putch('X', putdat);
      putch('X', putdat);
      putch('X', putdat);
      break;

    // pointer
    case 'p':
      putch('0', putdat);
      putch('x', putdat);
      num = (unsigned long long)
        (uintptr_t) va_arg(ap, void *);
      base = 16;
      goto number;

    // (unsigned) hexadecimal
    case 'x':
      num = getuint(&ap, lflag);
      base = 16;
    number:
      printnum(putch, putdat, num, base, width, padc);
      break;

    // escaped '%' character
    case '%':
      putch(ch, putdat);
      break;

    // unrecognized escape sequence - just print it literally
    default:
      putch('%', putdat);
      for (fmt--; fmt[-1] != '%'; fmt--)
        /* do nothing */;
      break;
    }
  }
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  va_list ap;

  va_start(ap, fmt);
  vprintfmt(putch, putdat, fmt, ap);
  va_end(ap);
}

struct sprintbuf {
  char *buf;
  char *ebuf;
  int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  b->cnt++;
  if (b->buf < b->ebuf)
    *b->buf++ = ch;
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  struct sprintbuf b = {buf, buf+n-1, 0};

  if (buf == NULL || n < 1)
    return -E_INVAL;

  // print the string to the buffer
  vprintfmt((void*)sprintputch, &b, fmt, ap);

  // null terminate the buffer
  *b.buf = '\0';

  return b.cnt;
}

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  va_list ap;
  int rc;

  va_start(ap, fmt);
  rc = vsnprintf(buf, n, fmt, ap);
  va_end(ap);

  return rc;
}
```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/error.h（クリックしてコードを表示）</span></summary>

```c
/* See COPYRIGHT for copyright information. */

#ifndef JOS_INC_ERROR_H
#define JOS_INC_ERROR_H

enum {
	// Kernel error codes -- keep in sync with list in lib/printfmt.c.
	E_UNSPECIFIED	= 1,	// Unspecified or unknown problem
	E_BAD_ENV	,	// Environment doesn't exist or otherwise
				// cannot be used in requested action
	E_INVAL		,	// Invalid parameter
	E_NO_MEM	,	// Request failed due to memory shortage
	E_NO_FREE_ENV	,	// Attempt to create a new environment beyond
				// the maximum allowed
	E_FAULT		,	// Memory fault

	E_IPC_NOT_RECV	,	// Attempt to send to env that is not recving
	E_EOF		,	// Unexpected end of file

	// File system error codes -- only seen in user-level
	E_NO_DISK	,	// No free space left on disk
	E_MAX_OPEN	,	// Too many files are open
	E_NOT_FOUND	, 	// File or block not found
	E_BAD_PATH	,	// Bad path
	E_FILE_EXISTS	,	// File already exists
	E_NOT_EXEC	,	// File not a valid executable
	E_NOT_SUPP	,	// Operation not supported

	MAXERROR
};

#endif	// !JOS_INC_ERROR_H */
```

</details>

#### 🌟 不足している標準ライブラリ関数の追加】

上記の`printfmt.c`に含まれる`vprintfmt()`は`strnlen()`を必要としますが、この関数はxv6には含まれていません。文字列関連をまとめている`string.c`へ`strnlen()`を追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/string.c（クリックしてコードを表示）</span></summary>

```diff
...

+int
+strnlen(const char *s, uint z)
+{
+  int n;
+
+  for (n = 0; z > 0 && s[n]; n++, z--)
+    ;
+  return n;
+}
```
</details>

`strnlen()`は終端文字が含まれない可能性のある文字列の長さを計測する関数です。引数で指定した最大バイト数に達しても終端文字が現れなかった場合にはそこで計測を打ち切ります。

#### 🌟 プロトタイプ宣言の追加

ソースファイル外に公開する関数のプロトタイプ宣言を追加します。xv6では関数のプロトタイプ宣言を`kernel/defs.h`に集約しているので、このファイルに追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/defs.h（クリックしてコードを開く）</span></summary>

```diff
...

 // printf.c
 int            printf(char*, ...) __attribute__ ((format (printf, 1, 2)));
 void            panic(char*) __attribute__((noreturn));
 void            printfinit(void);

+// printfmt.c
+void            vprintfmt(void (*)(int, void*), void*, const char*, void*);
+void            printfmt(void (*)(int, void*), void*, const char*, ...);
+int             vsnprintf(char*, int, const char*, void*);
+int             snprintf(char*, int, const char*, ...);
+
...

 // string.c
 int             memcmp(const void*, const void*, uint);
 void*           memmove(void*, const void*, uint);
 void*           memset(void*, int, uint);
 char*           safestrcpy(char*, const char*, int);
 int             strlen(const char*);
+int             strnlen(const char*, uint);
 int             strncmp(const char*, const char*, uint);
 char*           strncpy(char*, const char*, int);

```
</details>

#### 🌟 Makefileの修正

`Makefile`の`OBJS`に新しく追加したソースファイル（のオブジェクト名）を追加します。また、GCCのビルトイン関数が使われないように`CFLAGS`にいくつかの`-fno-builtin-xxx`を追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 Makefile（クリックしてコードを表示）</span></summary>

```diff
 K=kernel
 U=user

 OBJS = \
   $K/entry.o \
   $K/start.o \
   $K/console.o \
   $K/printf.o \
+  $K/printfmt.o \
   $K/uart.o \
   $K/kalloc.o \
   $K/spinlock.o \
   $K/string.o \
   $K/main.o \
   $K/vm.o \
   $K/proc.o \
   $K/swtch.o \
   $K/trampoline.o \
   $K/trap.o \
   $K/syscall.o \
   $K/sysproc.o \
   $K/bio.o \
   $K/fs.o \
   $K/log.o \
   $K/sleeplock.o \
   $K/file.o \
   $K/pipe.o \
   $K/exec.o \
   $K/sysfile.o \
   $K/kernelvec.o \
   $K/plic.o \
   $K/virtio_disk.o

...

 CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb -gdwarf-2
 CFLAGS += -MD
 CFLAGS += -mcmodel=medany
 # CFLAGS += -ffreestanding -fno-common -nostdlib -mno-relax
 CFLAGS += -fno-common -nostdlib
 CFLAGS += -fno-builtin-strncpy -fno-builtin-strncmp -fno-builtin-strlen -fno-builtin-memset
 CFLAGS += -fno-builtin-memmove -fno-builtin-memcmp -fno-builtin-log -fno-builtin-bzero
 CFLAGS += -fno-builtin-strchr -fno-builtin-exit -fno-builtin-malloc -fno-builtin-putc
-CFLAGS += -fno-builtin-free
+CFLAGS += -fno-builtin-free -fno-builtin-strnlen -fno-builtin-snprintf -fno-builtin-vsnprintf
 CFLAGS += -fno-builtin-memcpy -Wno-main
 CFLAGS += -fno-builtin-printf -fno-builtin-fprintf -fno-builtin-vprintf
 CFLAGS += -I.
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)

...
```
</details>

一旦、この状態で追加ファイルを含めてビルドが通るか確認しておきます。

```
$ make clean
$ make
```

#### 🌟 コンソール出力関数の差し替え

コンソール出力関数（`printf`）を差し替える準備ができたので、`printf.c`を次のように変更します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/printf.c（クリックしてコードを表示）</span></summary>

```diff
...

 // lock to avoid interleaving concurrent printf's.
 static struct {
   struct spinlock lock;
   int locking;
 } pr;

-static char digits[] = "0123456789abcdef";
-
-static void
-printint(long long xx, int base, int sign)
-{
-  char buf[20];
-  int i;
-  unsigned long long x;
-
-  if(sign && (sign = (xx < 0)))
-    x = -xx;
-  else
-    x = xx;
-
-  i = 0;
-  do {
-    buf[i++] = digits[x % base];
-  } while((x /= base) != 0);
-
-  if(sign)
-    buf[i++] = '-';
-
-  while(--i >= 0)
-    consputc(buf[i]);
-}
-
-static void
-printptr(uint64 x)
-{
-  int i;
-  consputc('0');
-  consputc('x');
-  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
-    consputc(digits[x >> (sizeof(uint64) * 8 - 4)]);
-}
-
-// Print to the console.
-int
-printf(char *fmt, ...)
-{
-  va_list ap;
-  int i, cx, c0, c1, c2, locking;
-  char *s;
-
-  locking = pr.locking;
-  if(locking)
-    acquire(&pr.lock);
-
-  va_start(ap, fmt);
-  for(i = 0; (cx = fmt[i] & 0xff) != 0; i++){
-    if(cx != '%'){
-      consputc(cx);
-      continue;
-    }
-    i++;
-    c0 = fmt[i+0] & 0xff;
-    c1 = c2 = 0;
-    if(c0) c1 = fmt[i+1] & 0xff;
-    if(c1) c2 = fmt[i+2] & 0xff;
-    if(c0 == 'd'){
-      printint(va_arg(ap, int), 10, 1);
-    } else if(c0 == 'l' && c1 == 'd'){
-      printint(va_arg(ap, uint64), 10, 1);
-      i += 1;
-    } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
-      printint(va_arg(ap, uint64), 10, 1);
-      i += 2;
-    } else if(c0 == 'u'){
-      printint(va_arg(ap, int), 10, 0);
-    } else if(c0 == 'l' && c1 == 'u'){
-      printint(va_arg(ap, uint64), 10, 0);
-      i += 1;
-    } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
-      printint(va_arg(ap, uint64), 10, 0);
-      i += 2;
-    } else if(c0 == 'x'){
-      printint(va_arg(ap, int), 16, 0);
-    } else if(c0 == 'l' && c1 == 'x'){
-      printint(va_arg(ap, uint64), 16, 0);
-      i += 1;
-    } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
-      printint(va_arg(ap, uint64), 16, 0);
-      i += 2;
-    } else if(c0 == 'p'){
-      printptr(va_arg(ap, uint64));
-    } else if(c0 == 's'){
-      if((s = va_arg(ap, char*)) == 0)
-        s = "(null)";
-      for(; *s; s++)
-        consputc(*s);
-    } else if(c0 == '%'){
-      consputc('%');
-    } else if(c0 == 0){
-      break;
-    } else {
-      // Print unknown % sequence to draw attention.
-      consputc('%');
-      consputc(c0);
-    }
-
-#if 0
-    switch(c){
-    case 'd':
-      printint(va_arg(ap, int), 10, 1);
-      break;
-    case 'x':
-      printint(va_arg(ap, int), 16, 1);
-      break;
-    case 'p':
-      printptr(va_arg(ap, uint64));
-      break;
-    case 's':
-      if((s = va_arg(ap, char*)) == 0)
-        s = "(null)";
-      for(; *s; s++)
-        consputc(*s);
-      break;
-    case '%':
-      consputc('%');
-      break;
-    default:
-      // Print unknown % sequence to draw attention.
-      consputc('%');
-      consputc(c);
-      break;
-    }
-#endif
-  }
-  va_end(ap);
-
-  if(locking)
-    release(&pr.lock);
-
-  return 0;
-}
+
+static void
+putch(int ch, int *cnt)
+{
+  consputc(ch);
+  (void)*cnt++;
+}
+
+int
+vcprintf(const char *fmt, va_list ap)
+{
+  int cnt = 0;
+
+  vprintfmt((void*)putch, &cnt, fmt, ap);
+  return cnt;
+}
+
+int
+printf(char *fmt, ...)
+{
+  int locking, cnt;
+  va_list ap;
+
+  locking = pr.locking;
+  if(locking)
+    acquire(&pr.lock);
+
+  va_start(ap, fmt);
+  cnt = vcprintf(fmt, ap);
+  va_end(ap);
+
+  if(locking)
+    release(&pr.lock);
+
+  return cnt;
+}

void
panic(char *s)
...
```
</details>

再ビルドした後、`make qemu`を実行してxv6を起動させます。

```
xv6 kernel is booting

hart 1 starting
hart 2 starting
init: starting sh
```

> [!NOTE]
> コンソール出力関数を差し替えた後も問題なくてテキストが出力されるはずです。

## 2.3. 現在時刻の取得

### 2.3.1. RTC（Real Time Clock）の利用

x86版のxv6にはRTCから時刻情報を取得するための関数（`cmostime()`）が用意されていますが、RISC-V版のxv6にはRTC関連のコードは用意されていません。QEMUがRISC-V環境向けにもRTCを提供してくれているのでこれを利用して現在時刻を取得する機能を追加します。

> [!NOTE]
> RISC-V版のxv6ではタイマー割り込みを用いて100ミリ秒毎にtickをカウントする機能だけが存在しています。

QEMUがRISC-V環境で提供しているRTCは「Goldfish RTC」です。これはGoogleがAndroidエミュレータ向けに開発したMMIOベースのRTCで、マッピングされたメモリアドレスへアクセスすることでRTCのレジスタを読み出すことができます。

#### 🌟 RTCの物理アドレスの定義

まず、QEMUが提供するRTCの物理アドレスを`kernel/memlayout.h`に定義します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/memlayout.h（クリックしてコードを表示）</span></summary>
	
```diff
 // Physical memory layout

 // qemu -machine virt is set up like this,
 // based on qemu's hw/riscv/virt.c:
 //
 // 00001000 -- boot ROM, provided by qemu
+// 00101000 -- RTC
 // 02000000 -- CLINT
 // 0C000000 -- PLIC
 // 10000000 -- uart0 
 // 10001000 -- virtio disk 
 // 80000000 -- boot ROM jumps here in machine mode
 //             -kernel loads the kernel here
 // unused RAM after 80000000.

 // the kernel uses physical memory thus:
 // 80000000 -- entry.S, then kernel text and data
 // end -- start of kernel page allocation area
 // PHYSTOP -- end RAM used by the kernel

+// Goldfish RTC
+#define RTC 0x00101000L
+
 // qemu puts UART registers here in physical memory.
 #define UART0 0x10000000L
 #define UART0_IRQ 10

...
```
</details>

> [!NOTE]
> `0x00101000L`という値はRTCを提供するQEMUの仮想ハードウェアの仕様で決められています。
> - https://github.com/qemu/qemu/blob/master/hw/riscv/virt.c#L86

#### 🌟 物理アドレスを仮想アドレスにマッピング

`kernel/vm.c`にある`kvmmake()`の中に、RTCの物理アドレスを仮想アドレスにマッピングするためのコードを追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/vm.c（クリックしてコードを表示）</span></summary>

```diff
...

 // Make a direct-map page table for the kernel.
 pagetable_t
 kvmmake(void)
 {
   pagetable_t kpgtbl;

   kpgtbl = (pagetable_t) kalloc();
   memset(kpgtbl, 0, PGSIZE);

+  // rtc registers
+  kvmmap(kpgtbl, RTC, RTC, PGSIZE, PTE_R | PTE_W);
+
   // uart registers
   kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);

...
 }

...
```
</details>

> [!NOTE]
> xv6カーネルではダイレクトマッピングが採用されており、マッピングする物理アドレスと仮想アドレスはどちらも同じ値となります。

#### 🌟 RTCから時刻情報を読み出す関数

Goldfish RTCは8つの32bitレジスタを持ちますが、このうち時刻情報に関連するのは`RTC_TIME_LOW`と`RTC_TIME_HIGH`の2つです。この2つのレジスタに、64bitの時刻情報を32bitづつ格納しています。リトルエンディアンの環境であれば`RTC_TIME_LOW`からまとめて64bit読み出すことでRTCが保持している時刻情報をそのまま取得できます。

> [!NOTE]
> 64bitの時刻情報はUNIXエポック（1970年1月1日午前0時0分0秒 UTC）からの経過ナノ秒の値となっています。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/rtc.c（クリックしてコードを表示）</span></summary>

```c
#include "types.h"
#include "riscv.h"
#include "memlayout.h"
#include "defs.h"

#define RTC_TIME_LOW        0x00
#define RTC_TIME_HIGH       0x04
#define RTC_ALARM_LOW       0x08
#define RTC_ALARM_HIGH      0x0c
#define RTC_IRQ_ENABLED     0x10
#define RTC_CLEAR_ALARM     0x14
#define RTC_ALARM_STATUS    0x18
#define RTC_CLEAR_INTERRUPT 0x1c

uint64
rtcread(void)
{
  return *(volatile uint64 *)(RTC + RTC_TIME_LOW);
}
```
</details>

#### 🌟 プロトタイプ宣言の追加

追加した関数のプロトタイプ宣言を`kenel/defs.h`に追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/defs.c（クリックしてコードを表示）</span></summary>

```diff
...
 int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
 int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
 void            procdump(void);

+// rtc.c
+uint64          rtcread(void);

 // swtch.S
 void            swtch(struct context*, struct context*);

...
```
</details>

#### 🌟 Makefileの修正

新しくソースファイルを追加したので、オブジェクトファイルのリスト（`OBJS`）に定義を追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 Makefile（クリックしてコードを表示）</span></summary>

```diff
 K=kernel
 U=user

 OBJS = \
...
   $K/pipe.o \
   $K/exec.o \
   $K/sysfile.o \
   $K/kernelvec.o \
   $K/plic.o \
+  $K/rtc.o \
   $K/virtio_disk.o \

...
```
</details>

#### 🌟 動作確認

`kernel/main.c`の`main()`に動作確認用のコードを追加します。

- `rtcread()`を呼び出して64bitの時刻情報を取得
- 64bitの時刻情報を「秒」と「ナノ秒」に分けて出力

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/main.c（クリックしてコードを表示）</span></summary>

```diff
...
 // start() jumps here in supervisor mode on all CPUs.
 void
 main()
 {
   if(cpuid() == 0){
     consoleinit();
     printfinit();
     printf("\n");
     printf("xv6 kernel is booting\n");
     printf("\n");
     kinit();         // physical page allocator
     kvminit();       // create kernel page table
     kvminithart();   // turn on paging
     procinit();      // process table
     trapinit();      // trap vectors
     trapinithart();  // install kernel trap vector
     plicinit();      // set up interrupt controller
     plicinithart();  // ask PLIC for device interrupts
     binit();         // buffer cache
     iinit();         // inode table
     fileinit();      // file table
     virtio_disk_init(); // emulated hard disk
+    uint64 rtc = rtcread();
+    printf("%ld.%ld\n", rtc / 1000000000, rtc % 1000000000);
     userinit();      // first user process
     __sync_synchronize();
     started = 1;
   } else {
     while(started == 0)
       ;
     __sync_synchronize();
     printf("hart %d starting\n", cpuid());
     kvminithart();    // turn on paging
     trapinithart();   // install kernel trap vector
     plicinithart();   // ask PLIC for device interrupts
   }

   scheduler();        
 }
```
</details>

再ビルドした後、`make qemu`を実行してxv6を起動させます。

```
xv6 kernel is booting

1754986635.308689000
hart 1 starting
hart 2 starting
init: starting sh
$ 
```

シェルが立ち上がる前の起動ログの中に「`秒.ナノ秒`」の形式で時刻情報が出力されます。このうち秒の部分はUNIXタイムそのものです。

> [!TIP]
> `date`コマンドを利用するとUNIXタイムを任意の書式の時刻に変換できるので、これを利用して出力されているUNIXタイムが正しい値かどうか検証してみましょう。開発環境のシェルで次のコマンドを実行してください。
>
> ```
> $ date -d @1754986635 +"%Y/%m/%d %T"
> ```


### 2.3.2. 現在時刻を得る関数の追加

`rtcread()`でRTCから現在時刻を取得できるようになったので、これをベースにして現在時刻を得るためによく使われている`time()`と`gettimeofday()`を作成します。

#### 🌟 型定義の追加

`kernel/types.h`に、`time()`が使用する`time_t`の定義を追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/types.h（クリックしてコードを表示）</span></summary>

```diff
 typedef unsigned int   uint;
 typedef unsigned short ushort;
 typedef unsigned char  uchar;

 typedef unsigned char uint8;
 typedef unsigned short uint16;
 typedef unsigned int  uint32;
 typedef unsigned long uint64;

 typedef uint64 pde_t;

+typedef long time_t;
+
 #if defined(_STDIO_H)
 #define MKFS
 #endif

...
```
</details>

#### 🌟 構造体定義の追加

新しく`kernel/time.h`を作成し、`gettimeofday()`が使用する`struct timeval`を定義します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📝 kernel/time.h（クリックしてコードを表示）</span></summary>

```c
struct timeval {
  long tv_sec;
  long tv_usec;
};
```
</details>

#### 🌟 関数の追加

新しく`kernel/time.c`を作成し、以下の内容を記述してください。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/time.c（クリックしてコードを表示）</span></summary>

```c
#include "types.h"
#include "riscv.h"
#include "defs.h"
#include "time.h"

time_t
time(time_t *t)
{
  time_t _t;
  if (!t)
    t = &_t;
  *t = rtcread() / 1000000000;
  return *t;
}

int
gettimeofday(struct timeval *tv, void *tz)
{
  (void)tz;
  uint64 rtc = rtcread();
  tv->tv_sec = rtc / 1000000000;
  tv->tv_usec = (rtc % 1000000000) / 1000;
  return 0;
}
```
</details>

#### 🌟 プロトタイプ宣言の追加

追加した関数のプロトタイプ宣言を`kernel/defs.h`に追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/defs.h（クリックしてコードを表示）</span></summary>

```diff
 struct buf;
 struct context;
 struct file;
 struct inode;
 struct pipe;
 struct proc;
 struct spinlock;
 struct sleeplock;
 struct stat;
 struct superblock;
+struct timeval;

...

 // syscall.c
 void            argint(int, int*);
 int             argstr(int, char*, int);
 void            argaddr(int, uint64 *);
 int             fetchstr(uint64, char*, int);
 int             fetchaddr(uint64, uint64*);
 void            syscall();

+// time.c
+time_t          time(time_t*);
+int             gettimeofday(struct timeval*, void*);

 // trap.c
 extern uint     ticks;
 void            trapinit(void);
 void            trapinithart(void);
 extern struct spinlock tickslock;
 void            usertrapret(void);

...
```
</details>

#### 🌟 Makefileの修正

新しくソースファイルを追加したので、オブジェクトファイルのリスト（`OBJS`）に定義を追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 Makefile（クリックしてコードを表示）</span></summary>

```diff
 K=kernel
 U=user

 OBJS = \
...
   $K/sysfile.o \
   $K/kernelvec.o \
   $K/plic.o \
   $K/rtc.o \
+  $K/time.o \
   $K/virtio_disk.o

...
```
</details>

#### 🌟 動作確認

`kernel/main.c`の`main()`にある動作確認用のコードを書き換えます。

> [!WARNING]
> `gettimeofday()`を使用する際は`time.h`が必要なのでインクルードを忘れないようにしてください。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/main.c（クリックしてコードを表示）</span></summary>

```diff
 #include "types.h"
 #include "param.h"
 #include "memlayout.h"
 #include "riscv.h"
 #include "defs.h"
+#include "time.h"

 volatile static int started = 0;

 // start() jumps here in supervisor mode on all CPUs.
 void
 main()
 {
...
-    uint64 rtc = rtcread();
-    printf("%ld.%ld\n", rtc / 1000000000, rtc % 1000000000);
+    struct timeval tv;
+    gettimeofday(&tv, NULL);
+    printf("tv: {sec: %ld, usec: %ld}\n", tv.tv_sec, tv.tv_usec);
...
 }
```
</details>

再ビルドした後、`make qemu`を実行してxv6を起動させます。

```
xv6 kernel is booting

tv: {sec: 1754986939, usec: 308376}
hart 2 starting
hart 1 starting
init: starting sh
$
```

`struct timeval`型の変数が保持している秒とマイクロ秒が出力されます。

> [!NOTE]
> ナノ秒の精度が必要な場合は`struct timespec`を返す`clock_gettime()`を作成するといいでしょう。

### 2.3.3. カレンダー形式への変換

UNIXタイムのままだと可読性が乏しいため、カレンダー形式の日時情報を保持する`struct tm`を追加します。加えて、UNIXタイムとカレンダー形式の値を相互に変換するための関数を作ります。

#### 🌟 構造体定義の追加

カレンダー形式の日時情報を扱うための構造体（`struct tm`）の定義を`kernel/time.h`に追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/time.h（クリックしてコードを表示）</span></summary>

```diff
 struct timeval {
   long tv_sec;
   long tv_usec;
 };
+
+struct tm {
+  int tm_sec;   // 0-60
+  int tm_min;   // 0-59
+  int tm_hour;  // 0-23
+  int tm_mday;  // 1-31
+  int tm_mon;   // 0-11
+  int tm_year;  // since 1900
+  int tm_wday;  // 0-6
+  int tm_yday;  // 0-365
+  int tm_isdst; // zero
+};
```
</details>

> [!IMPORTANT]
> `struct tm`を扱う際には以下の点に注意しましょう。
>
> - `tm_mday`（日）だけ`1`から始まる
> - `tm_year`（年）は`1900`年からの経過年数
> - `tm_wday`（曜日）は日曜日（`0`）から土曜日（`6`）までの値
> - `tm_isdst`はサマータイムに関する値（ここでは常にゼロにしておく）

#### 🌟 関数の追加

ここでは、`kernel/time.c`へ以下の4つの関数を追加します。

- `isreapyear()`: うるう年を判定するための関数（内部利用のみ）
- `ndays()`: 指定した年月に存在する日数を得るための関数（内部利用のみ）
- `mktime()`: カレンダー形式の値（`struct tm`）からUNIXタイム（`time_t`）へ変換する関数
- `localtime_r()`: UNIXタイム（`time_t`）からカレンダー形式の値（`struct tm`）へ変換する関数

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/time.c（クリックしてコードを表示）</span></summary>

```diff
...

 int
 gettimeofday(struct timeval *tv, void *tz)
 {
   (void)tz;
   uint64 rtc = rtcread();
   tv->tv_sec = rtc / 1000000000;
   tv->tv_usec = (rtc % 1000000000) / 1000;
   return 0;
 }

+static int
+isleapyear(int y)
+{
+  return (y % 4 == 0 && y % 100 != 0) || (y % 400 == 0);
+}
+
+static int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
+
+static int
+ndays(int y, int m)
+{
+  int n = days[m];
+
+  if (m == 1 && isleapyear(y)) {
+    n++;
+  }
+  return n;
+}
+
+time_t
+mktime(struct tm *tm)
+{
+  const int epoch = 1970;
+  time_t result = 0;
+
+  for (int y = epoch; y < tm->tm_year + 1900; y++) {
+    result += (isleapyear(y) ? 366 : 365) * 24 * 3600;
+  }
+  for (int m = 0; m < tm->tm_mon; m++) {
+    result += ndays(tm->tm_year + 1900, m) * 24 * 3600;
+  }
+  result += (tm->tm_mday - 1) * 24 * 3600;
+  result += tm->tm_hour * 3600;
+  result += tm->tm_min * 60;
+  result += tm->tm_sec;
+  result -= 9 * 3600; // JST
+  return result;
+}
+
+struct tm *
+localtime_r(const time_t *timep, struct tm *result)
+{
+  time_t local_time;
+
+  local_time = *timep + (9 * 3600); // JST
+  result->tm_sec = local_time % 60;
+  local_time /= 60;
+  result->tm_min = local_time % 60;
+  local_time /= 60;
+  result->tm_hour = local_time % 24;
+  local_time /= 24;
+
+  int days = local_time;
+  result->tm_wday = (days + 4) % 7;
+
+  int y = 1970;
+  while (1) {
+    int n = isleapyear(y) ? 366 : 365;
+    if (days < n) {
+      break;
+    }
+    days -= n;
+    y++;
+  }
+  result->tm_year = y - 1900;
+  result->tm_yday = days;
+
+  int m = 0;
+  while (1) {
+    int n = ndays(y, m);
+    if (days < n) {
+      break;
+    }
+    days -= n;
+    m++;
+  }
+  result->tm_mon = m;
+  result->tm_mday = days + 1;
+  result->tm_isdst = 0;
+  return result;
+}
```
</details>

> [!WARNING]
> 簡略化のためにカレンダー形式では固定的に日本のタイムゾーン（JST）に合わせた値を保持するようにしてます。

#### 🌟 プロトタイプ宣言の追加

追加した関数のプロトタイプ宣言を`kernel/defs.h`に追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/defs.h（クリックしてコードを表示）</span></summary>

```diff
 struct buf;
 struct context;
 struct file;
 struct inode;
 struct pipe;
 struct proc;
 struct spinlock;
 struct sleeplock;
 struct stat;
 struct superblock;
 struct timeval;
+struct tm;

...


 // time.c
 time_t          time(time_t*);
 int             gettimeofday(struct timeval*, void*);
+time_t          mktime(struct tm*);
+struct tm*      localtime_r(const time_t*, struct tm*);

...
```
</details>

#### 🌟 動作確認

`kernel/main.c`の`main()`にある、動作確認用のコードを書き換えます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/main.h（クリックしてコードを表示）</span></summary>

```diff
...
     struct timeval tv;
     gettimeofday(&tv, NULL);
     printf("tv: {sec:%ld, usec:%ld}\n", tv.tv_sec, tv.tv_usec);
+    struct tm tm;
+    localtime_r(&tv.tv_sec, &tm);
+    printf("%04d/%02d/%02d %02d:%02d:%02d\n",
+      tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
+    printf("%ld\n", mktime(&tm));
...
```
</details>

再ビルドした後、`make qemu`を実行してxv6を起動させます。

```
xv6 kernel is booting

tv: {sec: 1754987184, usec: 308273}
2025/08/12 17:26:24
1754987184
hart 1 starting
hart 2 starting
init: starting sh
$
```

`struct timeval`の値に続けて、`localtime_r()`で取得した`struct tm`の値を用いたカレンダー形式の日時情報と、`mktime()`で`struct tm`から逆変換したUNIXタイムが出力されるはずです。

## 2.4. 便利ライブラリの移植

自作プロトコルスタックの実装をサポートするための便利ライブラリ（`util.c`､`util.h`）を先に移植しておきます。

#### 🌟 ディレクトリの作成

自作プロトコルスタックのコードは`kernel/net`ディレクトリを作成してその中に配置することにします。プラットフォーム依存のコードを配置するためのディレクトリまで一括で作成します。

```
$ mkdir -p kernel/net/platform/xv6-riscv
```

#### 🌟 Makefileの修正

新しく作成したディレクトリをインクルードパスや`make clean`の対象ディレクトリに追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 Makefile（クリックしてコードを表示）</span></summary>

```diff
 K=kernel
 U=user
+N=$K/net
+P=$N/platform/xv6-riscv

...

 CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb -gdwarf-2
 CFLAGS += -MD
 CFLAGS += -mcmodel=medany
 CFLAGS += -ffreestanding
 CFLAGS += -fno-common -nostdlib
 CFLAGS += -fno-builtin-strncpy -fno-builtin-strncmp -fno-builtin-strlen -fno-builtin-memset
 CFLAGS += -fno-builtin-memmove -fno-builtin-memcmp -fno-builtin-log -fno-builtin-bzero
 CFLAGS += -fno-builtin-strchr -fno-builtin-exit -fno-builtin-malloc -fno-builtin-putc
 CFLAGS += -fno-builtin-free
 CFLAGS += -fno-builtin-memcpy -Wno-main
 CFLAGS += -fno-builtin-printf -fno-builtin-fprintf -fno-builtin-vprintf
-CFLAGS += -I.
+CFLAGS += -I. -I $K -I $N -I $P
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)

...

--include kernel/*.d user/*.d
+-include $K/*.d $U/*.d $N/*.d $P/*.d

 clean: 
 	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
 	*/*.o */*.d */*.asm */*.sym \
+	$N/*.o $N/*.d $P/*.o $P/*.d \
 	$U/initcode $U/initcode.out $K/kernel fs.img \
 	mkfs/mkfs .gdbinit \
        $U/usys.S \
 	$(UPROGS)

...
```
</details>

#### 🌟 プラットフォーム依存コードの追加

まず、プラットフォーム依存のコードを追加します。いまの時点ではメモリ関連のコードだけ含めています。その他は必要になったタイミングで随時追加していきます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/net/platform/xv6-riscv/platform.h（クリックしてコードを表示）</span></summary>

```c
#ifndef PLATFORM_H
#define PLATFORM_H

#include "types.h"
#include "riscv.h"
#include "defs.h"

/*
 * Memory
 */

static inline void *
memory_alloc(size_t size)
{
    void *p;

    if (PGSIZE < size) {
        return NULL;
    }
    p = kalloc();
    if (p) {
        memset(p, 0, size);
    }
    return p;
}

static inline void
memory_free(void *ptr)
{
    kfree(ptr);
}

/*
 * Mutex
 */

#include "param.h"
#include "spinlock.h"
#include "proc.h"



/*
 * Interrupt
 */



/*
 * Scheduler
 */



#endif
```
</details>

> [!NOTE]
> xv6のカーネル内ではメモリは`kalloc()`で確保します。確保するメモリのサイズは指定できず、常にページサイズ（4KB）のメモリが返されます。自作プロトコルスタックでは4KBを超えるメモリを確保することはないのでひとまず問題ないはずです。`kalloc()`で確保したメモリは`kfree()`で解放します。

#### 🌟 便利ライブラリの配置

便利ライブラリのファイルを`kernel/net`ディレクトリの下に配置します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/net/util.c（クリックしてコードを表示）</span></summary>

```c
#include "platform.h"

#include "util.h"

/*
 * Logging
 */

int
lprintf(FILE *fp, int level, const char *file, int line, const char *func, const char *fmt, ...)
{
    struct timeval tv;
    struct tm tm;
    char timestamp[32];
    int n = 0;
    va_list ap;

    flockfile(fp);
    gettimeofday(&tv, NULL);
    strftime(timestamp, sizeof(timestamp), "%T", localtime_r(&tv.tv_sec, &tm));
    n += fprintf(fp, "%s.%03d [%c] %s: ", timestamp, (int)(tv.tv_usec / 1000), level, func);
    va_start(ap, fmt);
    n += vfprintf(fp, fmt, ap);
    va_end(ap);
    n += fprintf(fp, " (%s:%d)\n", file, line);
    funlockfile(fp);
    return n;
}

void
hexdump(FILE *fp, const void *data, size_t size)
{
    unsigned char *src;
    int offset, index;

    flockfile(fp);
    src = (unsigned char *)data;
    fprintf(fp, "+------+-------------------------------------------------+------------------+\n");
    for(offset = 0; offset < (int)size; offset += 16) {
        fprintf(fp, "| %04x | ", offset);
        for(index = 0; index < 16; index++) {
            if(offset + index < (int)size) {
                fprintf(fp, "%02x ", 0xff & src[offset + index]);
            } else {
                fprintf(fp, "   ");
            }
        }
        fprintf(fp, "| ");
        for(index = 0; index < 16; index++) {
            if(offset + index < (int)size) {
                if(isascii(src[offset + index]) && isprint(src[offset + index])) {
                    fprintf(fp, "%c", src[offset + index]);
                } else {
                    fprintf(fp, ".");
                }
            } else {
                fprintf(fp, " ");
            }
        }
        fprintf(fp, " |\n");
    }
    fprintf(fp, "+------+-------------------------------------------------+------------------+\n");
    funlockfile(fp);
}

/*
 * Queue
 */

struct queue_entry {
    struct queue_entry *next;
    void *data;
};

void
queue_init(struct queue_head *queue)
{
    queue->head = NULL;
    queue->tail = NULL;
    queue->num = 0;
}

void *
queue_push(struct queue_head *queue, void *data)
{
    struct queue_entry *entry;

    if (!queue) {
        return NULL;
    }
    entry = memory_alloc(sizeof(*entry));
    if (!entry) {
        return NULL;
    }
    entry->next = NULL;
    entry->data = data;
    if (queue->tail) {
        queue->tail->next = entry;
    }
    queue->tail = entry;
    if (!queue->head) {
        queue->head = entry;
    }
    queue->num++;
    return data;
}

void *
queue_pop(struct queue_head *queue)
{
    struct queue_entry *entry;
    void *data;

    if (!queue || !queue->head) {
        return NULL;
    }
    entry = queue->head;
    queue->head = entry->next;
    if (!queue->head) {
        queue->tail = NULL;
    }
    queue->num--;
    data = entry->data;
    memory_free(entry);
    return data;
}

void *
queue_peek(struct queue_head *queue)
{
    if (!queue || !queue->head) {
        return NULL;
    }
    return queue->head->data;
}

void
queue_foreach(struct queue_head *queue, void (*func)(void *arg, void *data), void *arg)
{
    struct queue_entry *entry;

    if (!queue || !func) {
        return;
    }
    for (entry = queue->head; entry; entry = entry->next) {
        func(arg, entry->data);
    }
}

/*
 * Byteorder
 */

#ifndef __BIG_ENDIAN
#define __BIG_ENDIAN 4321
#endif
#ifndef __LITTLE_ENDIAN
#define __LITTLE_ENDIAN 1234
#endif

static int endian;

static int
byteorder(void) {
    uint32_t x = 0x00000001;

    return *(uint8_t *)&x ? __LITTLE_ENDIAN : __BIG_ENDIAN;
}

static uint16_t
byteswap16(uint16_t v)
{
    return (v & 0x00ff) << 8 | (v & 0xff00 ) >> 8;
}

static uint32_t
byteswap32(uint32_t v)
{
    return (v & 0x000000ff) << 24 | (v & 0x0000ff00) << 8 | (v & 0x00ff0000) >> 8 | (v & 0xff000000) >> 24;
}

uint16_t
hton16(uint16_t h)
{
    if (!endian) {
        endian = byteorder();
    }
    return endian == __LITTLE_ENDIAN ? byteswap16(h) : h;
}

uint16_t
ntoh16(uint16_t n)
{
    if (!endian) {
        endian = byteorder();
    }
    return endian == __LITTLE_ENDIAN ? byteswap16(n) : n;
}

uint32_t
hton32(uint32_t h)
{
    if (!endian) {
        endian = byteorder();
    }
    return endian == __LITTLE_ENDIAN ? byteswap32(h) : h;
}

uint32_t
ntoh32(uint32_t n)
{
    if (!endian) {
        endian = byteorder();
    }
    return endian == __LITTLE_ENDIAN ? byteswap32(n) : n;
}

/*
 * Checksum
 */

uint16_t
cksum16(uint16_t *addr, uint16_t count, uint32_t init)
{
    uint32_t sum;

    sum = init;
    while (count > 1) {
        sum += *(addr++);
        count -= 2;
    }
    if (count > 0) {
        sum += *(uint8_t *)addr;
    }
    while (sum >> 16) {
        sum = (sum & 0xffff) + (sum >> 16);
    }
    return ~(uint16_t)sum;
}
```
</details>


<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/net/util.h（クリックしてコードを表示）</span></summary>

```c
#ifndef UTIL_H
#define UTIL_H

#include "platform.h"

/*
 * Compare
 */

#ifndef MAX
#define MAX(x, y) ((x) > (y) ? (x) : (y))
#endif
#ifndef MIN
#define MIN(x, y) ((x) < (y) ? (x) : (y))
#endif

/*
 * Array
 */

#define countof(x) ((sizeof(x) / sizeof(*x)))
#define tailof(x) (x + countof(x))
#define indexof(x, y) (((uintptr_t)y - (uintptr_t)x) / sizeof(*y))

/*
 * Time
 */

#define timeval_add_usec(x, y)         \
    do {                               \
        (x)->tv_sec += y / 1000000;    \
        (x)->tv_usec += y % 1000000;   \
        if ((x)->tv_usec >= 1000000) { \
            (x)->tv_sec += 1;          \
            (x)->tv_usec -= 1000000;   \
        }                              \
    } while(0);

#define timespec_add_nsec(x, y)           \
    do {                                  \
        (x)->tv_sec += y / 1000000000;    \
        (x)->tv_nsec += y % 1000000000;   \
        if ((x)->tv_nsec >= 1000000000) { \
            (x)->tv_sec += 1;             \
            (x)->tv_nsec -= 1000000000;   \
        }                                 \
    } while(0);

/*
 * Logging
 */

#define errorf(...) lprintf(stderr, 'E', __FILE__, __LINE__, __func__, __VA_ARGS__)
#define warnf(...) lprintf(stderr, 'W', __FILE__, __LINE__, __func__, __VA_ARGS__)
#define infof(...) lprintf(stderr, 'I', __FILE__, __LINE__, __func__, __VA_ARGS__)
#define debugf(...) lprintf(stderr, 'D', __FILE__, __LINE__, __func__, __VA_ARGS__)

#ifdef HEXDUMP
#define debugdump(...) hexdump(stderr, __VA_ARGS__)
#else
#define debugdump(...)
#endif

extern int
lprintf(FILE *fp, int level, const char *file, int line, const char *func, const char *fmt, ...);
extern void
hexdump(FILE *fp, const void *data, size_t size);

/*
 * Queue
 */

struct queue_entry;

struct queue_head {
    struct queue_entry *head;
    struct queue_entry *tail;
    unsigned int num;
};

extern void
queue_init(struct queue_head *queue);
extern void *
queue_push(struct queue_head *queue, void *data);
extern void *
queue_pop(struct queue_head *queue);
extern void *
queue_peek(struct queue_head *queue);
extern void
queue_foreach(struct queue_head *queue, void (*func)(void *arg, void *data), void *arg);

/*
 * Byteorder
 */

extern uint16_t
hton16(uint16_t h);
extern uint16_t
ntoh16(uint16_t n);
extern uint32_t
hton32(uint32_t h);
extern uint32_t
ntoh32(uint32_t n);

/*
 * Checksum
 */

extern uint16_t
cksum16(uint16_t *addr, uint16_t count, uint32_t init);

#endif
```
</details>

> [!IMPORTANT]
> xv6のコンパイルでは`-nostdinc`が指定されるため、`#include <>`でシステムヘッダをインクルードしている箇所でエラーが発生してしまいます。これに対処するために、システムヘッダのインクルードを全て削除しています。
>
> この先で追加するプロトコルスタック関連のファイルについても、システムヘッダのインクルードを取り除き、替わりに`platform.h`を冒頭でインクルードするように変更します。

#### 🌟 不足している標準ライブラリ関数の追加

xv6には標準ライブラリが実装されていないため、必要な関数は自分で追加する必要があります。ここでは、便利ライブラリが必要とする関数に加えて自作プロトコルスタックの移植で必要になる関数を追加しておきます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/net/platform/xv6-riscv/std.h（クリックしてコードを表示）</span></summary>

```c
#ifndef STD_H
#define STD_H

#include <stdarg.h>

#include "time.h"

#define UINT16_MAX 65535

#define isascii(x) ((x >= 0x00) && (x <= 0x7f))
#define isprint(x) ((x >= 0x20) && (x <= 0x7e))

#define EINTR 1

extern int errno;

/*
 * STDIO
 */

typedef struct {
    /* dummy */
} FILE;

extern FILE *stderr;

#define fprintf(fp, ...) printf(__VA_ARGS__)
#define vfprintf(fp, ...) vcprintf(__VA_ARGS__)

extern void
flockfile(FILE *fp);
extern void
funlockfile(FILE *fp);
extern int
vfprintf(FILE *fp, const char *fmt, va_list ap);

/*
 * Time
 */

struct timespec {
    /* dummy */
};

extern size_t
strftime(char *s, size_t max, const char *format, const struct tm *tm);
extern void
timersub(struct timeval *a, struct timeval *b, struct timeval *res);
extern void
timerclear(struct timeval *tv);

#define timercmp(a, b, cmp) \
    ((a)->tv_sec == (b)->tv_sec ? (a)->tv_usec cmp (b)->tv_usec : (a)->tv_sec cmp (b)->tv_sec)

/*
 * Random
 */

extern void
srand(unsigned int newseed);
extern long
random(void);

/*
 * String
 */

extern void *
memcpy(void *dst, const void *src, uint n);
extern long
strtol(const char *s, char **endptr, int base);
extern char *
strrchr(const char *cp, int ch);

#endif
```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/net/platform/xv6-riscv/std.c（クリックしてコードを表示）</span></summary>

```c
#include "platform.h"

int errno;

/*
 * STDIO
 */

FILE *stderr;

void
flockfile(FILE *fp)
{
    /* dummy */
}

void
funlockfile(FILE *fp)
{
    /* dummy */
}

/*
 * Time
 */

size_t
strftime(char *s, size_t max, const char *format, const struct tm *tm)
{
    (void)format; /* force HH:MM:SS */
    return snprintf(s, max, "%02d:%02d:%02d", tm->tm_hour, tm->tm_min, tm->tm_sec);
}

void
timersub(struct timeval *a, struct timeval *b, struct timeval *res)
{
    res->tv_sec = a->tv_sec - b->tv_sec;
    res->tv_usec = a->tv_usec - b->tv_usec;
    if (res->tv_usec < 0) {
        --res->tv_sec;
        res->tv_usec += 1000*1000;
    }
    return;
}

void
timerclear(struct timeval *tv)
{
    tv->tv_sec = 0;
    tv->tv_usec = 0;
}

/*
 * Random
 */

static unsigned int seed = 1;

void
srand(unsigned int newseed)
{
    seed = newseed;
}

long
random(void)
{
    /* Linear Congruential Generator (LCG) */
    seed = (seed * 1103515245 + 12345) % 0x7fffffff;
    return seed;
}

/*
 * String
 */

long
strtol(const char *s, char **endptr, int base)
{
    int neg = 0;
    long val = 0;

    // gobble initial whitespace
    while (*s == ' ' || *s == '\t')
        s++;

    // plus/minus sign
    if (*s == '+')
        s++;
    else if (*s == '-')
        s++, neg = 1;

    // hex or octal base prefix
    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
        s += 2, base = 16;
    else if (base == 0 && s[0] == '0')
        s++, base = 8;
    else if (base == 0)
        base = 10;

    // digits
    while (1) {
        int dig;

        if (*s >= '0' && *s <= '9')
            dig = *s - '0';
        else if (*s >= 'a' && *s <= 'z')
            dig = *s - 'a' + 10;
        else if (*s >= 'A' && *s <= 'Z')
            dig = *s - 'A' + 10;
        else
            break;
        if (dig >= base)
            break;
        s++, val = (val * base) + dig;
        // we don't properly detect overflow!
    }

    if (endptr)
        *endptr = (char *) s;
    return (neg ? -val : val);
}

char *
strrchr(const char *cp, int ch)
{
    char *save;
    char c;

    for (save = (char *) 0; (c = *cp); cp++) {
        if (c == ch) {
            save = (char *) cp;
        }
    }
    return save;
}
```
</details>

> [!NOTE]
> 一部、ダミーの関数も含んでいますが主に下記のカテゴリの関数を追加しています。
> + 標準入出力
> + 時刻関連
> + ランダム関数
> + 文字列操作

この`kernel/net/platform/xv6/std.h`は、`kernel/net/platform/xv6/platform.h`から自動的に読み込まれるようにしておきます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/net/platform/xv6-riscv/platform.h（クリックしてコードを表示）</span></summary>

```diff
#ifndef PLATFORM_H
#define PLATFORM_H

#include "types.h"
#include "riscv.h"
#include "defs.h"

+#include "std.h"
+
...
```
</details>

#### 🌟 動作確認

便利ライブラリの動作確認のために、自作プロトコルスタックのメインモジュールに相当するファイルを追加します。

> [!WARNING]
> このファイルは一時的なもので後ほど正式なものに差し替えます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/net/net.c（クリックしてコードを表示）</span></summary>

```c
#include "platform.h"

#include "util.h"

void
netinit(void)
{
    char msg[] = "Hello, SecCamp2025!";

    debugf("%s", msg);
    debugdump(msg, sizeof(msg));
}
```
</details>

便利ライブラリの機能を使ってログ出力と16進ダンプをテストします。

`netinit()`はxv6の`main()`関数から呼び出すことになるので、`defs.h`にプロトタイプ宣言を追加しておきます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/defs.h（クリックしてコードを表示）</span></summary>

```diff
...

 // virtio_disk.c
 void            virtio_disk_init(void);
 void            virtio_disk_rw(struct buf *, int);
 void            virtio_disk_intr(void);

+// net/net.c
+void            netinit(void);
+
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))

...
```
</details>

新しくソースファイルを追加したので、`Makefile`を編集してオブジェクトファイルのリスト（OBJS）に定義を追加します。

> [!NOTE]
> 16進ダンプのための`debugdump()`マクロを有効にするために`CFLAGS`に`-DHEXDUMP`も追加しておきます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 Makefile（クリックしてコードを表示）</span></summary>

```diff
 K=kernel
 U=user
 N=$K/net
 P=$N/platform/xv6-riscv

 OBJS = \
...
   $K/plic.o \
   $K/rtc.o \
   $K/time.o \
-  $K/virtio_disk.o
+  $K/virtio_disk.o \
+  $N/util.o \
+  $N/net.o \
+  $P/std.o

...

 CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb -gdwarf-2
 CFLAGS += -MD
 CFLAGS += -mcmodel=medany
 CFLAGS += -ffreestanding
 CFLAGS += -fno-common -nostdlib
 CFLAGS += -fno-builtin-strncpy -fno-builtin-strncmp -fno-builtin-strlen -fno-builtin-memset
 CFLAGS += -fno-builtin-memmove -fno-builtin-memcmp -fno-builtin-log -fno-builtin-bzero
 CFLAGS += -fno-builtin-strchr -fno-builtin-exit -fno-builtin-malloc -fno-builtin-putc
 CFLAGS += -fno-builtin-free
 CFLAGS += -fno-builtin-memcpy -Wno-main
 CFLAGS += -fno-builtin-printf -fno-builtin-fprintf -fno-builtin-vprintf
 CFLAGS += -I.
-CFLAGS += -I. -I $K -I $N -I $P
+CFLAGS += -I. -I $K -I $N -I $P -DHEXDUMP
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)

...
```
</details>

xv6の`main()`関数から`netinit()`を呼び出すようにします。

> [!NOTE]
> ここまでに追加した時刻情報のテストコードは削除してしまいます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/main.c（クリックしてコードを表示）</span></summary>

```diff
...
     fileinit();      // file table
     virtio_disk_init(); // emulated hard disk
-    struct timeval tv;
-    gettimeofday(&tv, NULL);
-    printf("tv: {sec:%ld, usec:%ld}\n", tv.tv_sec, tv.tv_usec);
-    struct tm tm;
-    localtime_r(&tv.tv_sec, &tm);
-    printf("%04d/%02d/%02d %02d:%02d:%02d\n",
-      tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
-    printf("%ld\n", mktime(&tm));
+    netinit();       // network stack
     userinit();      // first user process
     __sync_synchronize();
     started = 1;
...
```
</details>

再ビルドした後、`make qemu`を実行してxv6を起動させます。

```
xv6 kernel is booting

17:33:15.313 [D] netinit: Hello, SecCamp2025! (kernel/net/net.c:10)
+------+-------------------------------------------------+------------------+
| 0000 | 48 65 6c 6c 6f 2c 20 53 65 63 43 61 6d 70 32 30 | Hello, SecCamp20 |
| 0010 | 32 35 21 00                                     | 25!.             |
+------+-------------------------------------------------+------------------+
hart 1 starting
hart 2 starting
init: starting sh
$
```

> [!NOTE]
> 見覚えのある書式のログメッセージと16進ダンプが出力されるはずです。


お疲れさまでした、これでプロトコルスタックを移植する準備が整いました！

<hr/>

[次へ](03.md)
