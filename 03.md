# 3. è‡ªä½œãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã®ç§»æ¤ï¼ˆå‰ç·¨ï¼‰

ã“ã“ã‹ã‚‰è‡ªä½œãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã®ã‚³ãƒ¼ãƒ‰ã‚’xv6ã«ç§»æ¤ã—ã¦ã„ãã¾ã™ã€‚ä½œæ¥­é‡ãŒå¤šã„ãŸã‚å‰ç·¨ã¨å¾Œç·¨ã«ã‚ã‘ã¦ãŠã‚Šã€å‰ç·¨ã§ã¯NICã‹ã‚‰èª­ã¿å–ã£ãŸãƒ‘ã‚±ãƒƒãƒˆã‚’ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã®å—ä¿¡ã‚­ãƒ¥ãƒ¼ã«æ ¼ç´ã—ã¦ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢å‰²ã‚Šè¾¼ã¿ã‚’ç™ºç”Ÿã•ã›ã‚‹ã¨ã“ã‚ã¾ã§é€²ã‚ã¾ã™ã€‚

> [!IMPORTANT]
> è‡ªä½œãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã®å…¨ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å…±é€šã—ã¦ã€ä¸‹è¨˜ã®ä¿®æ­£ã‚’åŠ ãˆã¦ã‚ã‚Šã¾ã™ã€‚
>
> + ã‚·ã‚¹ãƒ†ãƒ ãƒ˜ãƒƒãƒ€ã®ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ï¼ˆ`#include <>`ï¼‰ã‚’å‰Šé™¤
>   + `-nostdinc`ã¸ã®å¯¾å¿œ
>   + æ›¿ã‚ã‚Šã«`platform.h`ã‚’å†’é ­ã§ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰
> 
> + ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã®å¤§ããªãƒãƒƒãƒ•ã‚¡ã‚’å‹•çš„ãƒ¡ãƒ¢ãƒªç¢ºä¿ã«å¤‰æ›´
>   + ä¸»ã«é€ä¿¡ãƒ‘ã‚±ãƒƒãƒˆæ§‹ç¯‰ç”¨ã®ãƒãƒƒãƒ•ã‚¡
>   + ã‚¹ã‚¿ãƒƒã‚¯ãŒæº¢ã‚Œã¦ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ã¦ã—ã¾ã†å•é¡Œã¸ã®å¯¾å‡¦ï¼ˆRISC-Vç‰ˆã§ã¯å•é¡Œãªã„ã‹ã‚‚ã—ã‚Œãªã„ãŒx86ç‰ˆã®å¯¾ç­–ã‚’è¸è¥²ï¼‰
>   + æœ¬æ¥ã¯mbufã®ã‚ˆã†ãªä»•çµ„ã¿ã‚’æ¡ç”¨ã™ã¹ãã ãŒè¤‡é›‘ã«ãªã£ã¦ã—ã¾ã†ã®ã§è¦‹é€ã‚Š

ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯æœ¬ä½“ã®ã‚³ãƒ¼ãƒ‰ã¯ç§»æ¤ã—ã‚„ã™ã„ä½œã‚Šã«ã—ã¦ã„ã‚‹ã“ã¨ã‚‚ã‚ã‚Šã€æœ¬ä½“ã¨åˆ†é›¢ã—ã¦ã‚ã‚‹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å›ºæœ‰ã®å‡¦ç†ã‚’é™¤ã‘ã°ä»–ã«ç›®ç«‹ã£ãŸå¤‰æ›´ã¯ç™ºç”Ÿã—ã¾ã›ã‚“ã€‚

## 3.1. ãƒ¡ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«

è‡ªä½œãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã®ãƒ¡ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç§»æ¤ã—ã¾ã™ã€‚

#### ğŸŒŸ æš«å®šã‚³ãƒ¼ãƒ‰ã®å‰Šé™¤

ã“ã“ã¾ã§æš«å®šçš„ã«ä½œæˆã—ã¦ã„ãŸ`kernel/net/net.c`ã‚’å‰Šé™¤ã—ã¾ã™ã€‚

```
$ rm kernel/net/net.c
```

#### ğŸŒŸ ãƒ¡ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚³ãƒ¼ãƒ‰ã®è¿½åŠ 

ãƒ¡ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/net/net.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```c
#ifndef NET_H
#define NET_H

#include "platform.h"

#ifndef IFNAMSIZ
#define IFNAMSIZ 16
#endif

#define NET_DEVICE_TYPE_DUMMY     0x0000
#define NET_DEVICE_TYPE_LOOPBACK  0x0001
#define NET_DEVICE_TYPE_ETHERNET  0x0002

#define NET_DEVICE_FLAG_UP        0x0001
#define NET_DEVICE_FLAG_LOOPBACK  0x0010
#define NET_DEVICE_FLAG_BROADCAST 0x0020
#define NET_DEVICE_FLAG_P2P       0x0040
#define NET_DEVICE_FLAG_NEED_ARP  0x0100

#define NET_DEVICE_ADDR_LEN 16

#define NET_DEVICE_IS_UP(x) ((x)->flags & NET_DEVICE_FLAG_UP)
#define NET_DEVICE_STATE(x) (NET_DEVICE_IS_UP(x) ? "up" : "down")

/* NOTE: use same value as the Ethernet types */
#define NET_PROTOCOL_TYPE_IP   0x0800
#define NET_PROTOCOL_TYPE_ARP  0x0806
#define NTT_PROTOCOL_TYPE_IPV6 0x86dd

#define NET_IFACE_FAMILY_IP    1
#define NET_IFACE_FAMILY_IPV6  2

#define NET_IFACE(x) ((struct net_iface *)(x))

struct net_device {
    struct net_device *next;
    struct net_iface *ifaces; /* NOTE: if you want to add/delete the entries after net_run(), you need to protect ifaces with a mutex. */
    unsigned int index;
    char name[IFNAMSIZ];
    uint16_t type;
    uint16_t mtu;
    uint16_t flags;
    uint16_t hlen; /* header length */
    uint16_t alen; /* address length */
    uint8_t addr[NET_DEVICE_ADDR_LEN];
    union {
        uint8_t peer[NET_DEVICE_ADDR_LEN];
        uint8_t broadcast[NET_DEVICE_ADDR_LEN];
    };
    struct net_device_ops *ops;
    void *priv;
};

struct net_device_ops {
    int (*open)(struct net_device *dev);
    int (*close)(struct net_device *dev);
    int (*transmit)(struct net_device *dev, uint16_t type, const uint8_t *data, size_t len, const void *dst);
};

struct net_iface {
    struct net_iface *next;
    struct net_device *dev; /* back pointer to parent */
    int family;
    /* depends on implementation of protocols. */
};

extern struct net_device *
net_device_alloc(void);
extern int
net_device_register(struct net_device *dev);
extern int
net_device_add_iface(struct net_device *dev, struct net_iface *iface);
extern struct net_iface *
net_device_get_iface(struct net_device *dev, int family);
extern int
net_device_output(struct net_device *dev, uint16_t type, const uint8_t *data, size_t len, const void *dst);

extern int
net_protocol_register(uint16_t type, void (*handler)(const uint8_t *data, size_t len, struct net_device *dev));

extern int
net_timer_register(struct timeval interval, void (*handler)(void));
extern int
net_timer_handler(void);

extern int
net_input_handler(uint16_t type, const uint8_t *data, size_t len, struct net_device *dev);
extern int
net_softirq_handler(void);

extern int
net_event_subscribe(void (*handler)(void *arg), void *arg);
extern int
net_event_handler(void);
extern void
net_raise_event(void);

extern int
net_run(void);
extern void
net_shutdown(void);
extern int
net_init(void);

#endif
```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/net/net.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```c
#include "platform.h"

#include "util.h"
#include "net.h"

struct net_protocol {
    struct net_protocol *next;
    uint16_t type;
    struct queue_head queue; /* input queue */
    void (*handler)(const uint8_t *data, size_t len, struct net_device *dev);
};

struct net_protocol_queue_entry {
    struct net_device *dev;
    size_t len;
    uint8_t data[];
};

struct net_timer {
    struct net_timer *next;
    struct timeval interval;
    struct timeval last;
    void (*handler)(void);
};

struct net_event {
    struct net_event *next;
    void (*handler)(void *arg);
    void *arg;
};

/* NOTE: if you want to add/delete the entries after net_run(), you need to protect these lists with a mutex. */
static struct net_device *devices;
static struct net_protocol *protocols;
static struct net_timer *timers;
static struct net_event *events;

struct net_device *
net_device_alloc(void)
{
    struct net_device *dev;

    dev = memory_alloc(sizeof(*dev));
    if (!dev) {
        errorf("memory_alloc() failure");
        return NULL;
    }
    return dev;
}

/* NOTE: must not be call after net_run() */
int
net_device_register(struct net_device *dev)
{
    static unsigned int index = 0;

    dev->index = index++;
    snprintf(dev->name, sizeof(dev->name), "net%d", dev->index);
    dev->next = devices;
    devices = dev;
    infof("registered, dev=%s, type=0x%04x", dev->name, dev->type);
    return 0;
}

static int
net_device_open(struct net_device *dev)
{
    if (NET_DEVICE_IS_UP(dev)) {
        errorf("already opened, dev=%s", dev->name);
        return -1;
    }
    if (dev->ops->open) {
        if (dev->ops->open(dev) == -1) {
            errorf("failure, dev=%s", dev->name);
            return -1;
        }
    }
    dev->flags |= NET_DEVICE_FLAG_UP;
    infof("dev=%s, state=%s", dev->name, NET_DEVICE_STATE(dev));
    return 0;
}

static int
net_device_close(struct net_device *dev)
{
    if (!NET_DEVICE_IS_UP(dev)) {
        errorf("not opened, dev=%s", dev->name);
        return -1;
    }
    if (dev->ops->close) {
        if (dev->ops->close(dev) == -1) {
            errorf("failure, dev=%s", dev->name);
            return -1;
        }
    }
    dev->flags &= ~NET_DEVICE_FLAG_UP;
    infof("dev=%s, state=%s", dev->name, NET_DEVICE_STATE(dev));
    return 0;
}

/* NOTE: must not be call after net_run() */
int
net_device_add_iface(struct net_device *dev, struct net_iface *iface)
{
    struct net_iface *entry;

    for (entry = dev->ifaces; entry; entry = entry->next) {
        if (entry->family == iface->family) {
            /* NOTE: For simplicity, only one iface can be added per family. */
            errorf("already exists, dev=%s, family=%d", dev->name, entry->family);
            return -1;
        }
    }
    iface->next = dev->ifaces;
    iface->dev = dev;
    dev->ifaces = iface;
    return 0;
}

struct net_iface *
net_device_get_iface(struct net_device *dev, int family)
{
    struct net_iface *entry;

    for (entry = dev->ifaces; entry; entry = entry->next) {
        if (entry->family == family) {
            break;
        }
    }
    return entry;
}

int
net_device_output(struct net_device *dev, uint16_t type, const uint8_t *data, size_t len, const void *dst)
{
    if (!NET_DEVICE_IS_UP(dev)) {
        errorf("not opened, dev=%s", dev->name);
        return -1;
    }
    if (len > dev->mtu) {
        errorf("too long, dev=%s, mtu=%u, len=%zu", dev->name, dev->mtu, len);
        return -1;
    }
    debugf("dev=%s, type=0x%04x, len=%zu", dev->name, type, len);
    debugdump(data, len);
    if (dev->ops->transmit(dev, type, data, len, dst) == -1) {
        errorf("device transmit failure, dev=%s, len=%zu", dev->name, len);
        return -1;
    }
    return 0;
}

/* NOTE: must not be call after net_run() */
int
net_protocol_register(uint16_t type, void (*handler)(const uint8_t *data, size_t len, struct net_device *dev))
{
    struct net_protocol *proto;

    for (proto = protocols; proto; proto = proto->next) {
        if (type == proto->type) {
            errorf("already registered, type=0x%04x", type);
            return -1;
        }
    }
    proto = memory_alloc(sizeof(*proto));
    if (!proto) {
        errorf("memory_alloc() failure");
        return -1;
    }
    proto->type = type;
    proto->handler = handler;
    proto->next = protocols;
    protocols = proto;
    infof("registered, type=0x%04x", type);
    return 0;
}

/* NOTE: must not be call after net_run() */
int
net_timer_register(struct timeval interval, void (*handler)(void))
{
    struct net_timer *timer;

    timer = memory_alloc(sizeof(*timer));
    if (!timer) {
        errorf("memory_alloc() failure");
        return -1;
    }
    timer->interval = interval;
    gettimeofday(&timer->last, NULL);
    timer->handler = handler;
    timer->next = timers;
    timers = timer;
    infof("registered: interval={%d, %d}", interval.tv_sec, interval.tv_usec);
    return 0;
}

int
net_timer_handler(void)
{
    struct net_timer *timer;
    struct timeval now, diff;

    for (timer = timers; timer; timer = timer->next) {
        gettimeofday(&now, NULL);
        timersub(&now, &timer->last, &diff);
        if (timercmp(&timer->interval, &diff, <) != 0) { /* true (!0) or false (0) */
            timer->handler();
            timer->last = now;
        }
    }
    return 0;
}

int
net_input_handler(uint16_t type, const uint8_t *data, size_t len, struct net_device *dev)
{
    struct net_protocol *proto;
    struct net_protocol_queue_entry *entry;

    for (proto = protocols; proto; proto = proto->next) {
        if (proto->type == type) {
            entry = memory_alloc(sizeof(*entry) + len);
            if (!entry) {
                errorf("memory_alloc() failure");
                return -1;
            }
            entry->dev = dev;
            entry->len = len;
            memcpy(entry->data, data, len);
            if (!queue_push(&proto->queue, entry)) {
                errorf("queue_push() failure");
                memory_free(entry);
                return -1;
            }
            debugf("queue pushed (num:%u), dev=%s, type=0x%04x, len=%zu", proto->queue.num, dev->name, type, len);
            debugdump(data, len);
            intr_raise_irq(INTR_IRQ_SOFTIRQ);
            return 0;
        }
    }
    /* unsupported protocol */
    return 0;
}

int
net_softirq_handler(void)
{
    struct net_protocol *proto;
    struct net_protocol_queue_entry *entry;

    for (proto = protocols; proto; proto = proto->next) {
        while (1) {
            entry = queue_pop(&proto->queue);
            if (!entry) {
                break;
            }
            debugf("queue popped (num:%u), dev=%s, type=0x%04x, len=%zu", proto->queue.num, entry->dev->name, proto->type, entry->len);
            debugdump(entry->data, entry->len);
            proto->handler(entry->data, entry->len, entry->dev);
            memory_free(entry);
        }
    }
    return 0;
}

/* NOTE: must not be call after net_run() */
int
net_event_subscribe(void (*handler)(void *arg), void *arg)
{
    struct net_event *event;

    event = memory_alloc(sizeof(*event));
    if (!event) {
        errorf("memory_alloc() failure");
        return -1;
    }
    event->handler = handler;
    event->arg = arg;
    event->next = events;
    events = event;
    return 0;
}

int
net_event_handler(void)
{
    struct net_event *event;

    for (event = events; event; event = event->next) {
        event->handler(event->arg);
    }
    return 0;
}

void
net_raise_event()
{
    intr_raise_irq(INTR_IRQ_EVENT);
}

int
net_run(void)
{
    struct net_device *dev;

    if (intr_run() == -1) {
        errorf("intr_run() failure");
        return -1;
    }
    debugf("open all devices...");
    for (dev = devices; dev; dev = dev->next) {
        net_device_open(dev);
    }
    debugf("running...");
    return 0;
}

void
net_shutdown(void)
{
    struct net_device *dev;

    debugf("close all devices...");
    for (dev = devices; dev; dev = dev->next) {
        net_device_close(dev);
    }
    intr_shutdown();
    debugf("shutting down");
}

//#include "ip.h"
//#include "arp.h"
//#include "icmp.h"
//#include "udp.h"
//#include "tcp.h"

int
net_init(void)
{
    if (intr_init() == -1) {
        errorf("intr_init() failure");
        return -1;
    }
//    if (ip_init() == -1) {
//        errorf("ip_init() failure");
//        return -1;
//    }
//    if (arp_init() == -1) {
//        errorf("arp_init() failure");
//        return -1;
//    }
//    if (icmp_init() == -1) {
//        errorf("icmp_init() failure");
//        return -1;
//    }
//    if (udp_init() == -1) {
//        errorf("udp_init() failure");
//        return -1;
//    }
//    if (tcp_init() == -1) {
//        errorf("tcp_init() failure");
//        return -1;
//    }
    infof("initialized");
    return 0;
}

void
netinit(void)
{
    if (net_init() == -1) {
        panic("net_init() failure");
    }
}

void
netrun(void)
{
    if (net_run() == -1) {
        panic("net_run() failure");
    }
}
```
</details>

> [!NOTE]
> 1ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¥ã¤ç§»æ¤ã—ã¦ã„ãéƒ½åˆä¸Šã€`net_init()`ã§è¡Œã£ã¦ã„ãŸå„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åˆæœŸåŒ–å‡¦ç†ã‚’ä¸€æ—¦ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã—ã¦ã„ã¾ã™ã€‚ã¾ãŸã€xv6ã‹ã‚‰å‘¼ã³å‡ºã™ãŸã‚ã®`netinit()`ã¨`netrun()`ã‚’è¿½åŠ ã—ã¦ã„ã¾ã™ãŒã€ã©ã¡ã‚‰ã‚‚`net_init()`ã¨`net_run()`ã«å¯¾ã™ã‚‹ãƒ©ãƒƒãƒ‘ãƒ¼é–¢æ•°ã§ã™ã€‚

#### ğŸŒŸ ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ä¾å­˜ã®å‰²ã‚Šè¾¼ã¿é–¢é€£ã‚³ãƒ¼ãƒ‰ï¼ˆæš«å®šæªç½®ï¼‰

ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ä¾å­˜ã®å‰²ã‚Šè¾¼ã¿å‡¦ç†ã«ã¤ã„ã¦ã¯ã‚‚ã†å°‘ã—å¾Œã§è¿½åŠ ã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯ã¨ã‚Šã‚ãˆãšã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚’é€šã™ãŸã‚ã®æš«å®šã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ã¦ãŠãã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/net/platform/xv6-riscv/plartform.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...

 /*
  * Interrupt
  */

+#define INTR_IRQ_SOFTIRQ 0
+#define INTR_IRQ_EVENT 0
+
+static inline int
+intr_raise_irq(unsigned int irq)
+{
+    return 0;
+}
+
+static inline int
+intr_init(void)
+{
+    return 0;
+}
+
+static inline int
+intr_run(void)
+{
+    return 0;
+}
+
+static inline void
+intr_shutdown(void)
+{
+    return;
+}

...
```
</details>

#### ğŸŒŸ ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—å®£è¨€ã®è¿½åŠ 

è¿½åŠ ã—ãŸé–¢æ•°ã®ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—å®£è¨€ã‚’`kernel/defs.h`ã«è¿½åŠ ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/defs.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...

 // net/net.c
 void            netinit(void);
+void            netrun(void);
+int             net_softirq_handler(void);
+int             net_event_handler(void);

...
```
</details>

#### ğŸŒŸ ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã®èµ·å‹•

`kernel/main.c`ã®`main()`ã®ä¸­ã§ã€`netinit()`ã«ç¶šã‘ã¦`netrun()`ã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/main.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...

 // start() jumps here in supervisor mode on all CPUs.
 void
 main()
 {
   if(cpuid() == 0){
...
     virtio_disk_init(); // emulated hard disk
     netinit();       // network stack
+    netrun();        // start networking
     userinit();      // first user process
     __sync_synchronize();
     started = 1;
...
  }

  scheduler();        
}

...
```
</details>

#### ğŸŒŸ å‹•ä½œç¢ºèª

å†ãƒ“ãƒ«ãƒ‰ã—ãŸå¾Œã€`make qemu`ã‚’å®Ÿè¡Œã—ã¦xv6ã‚’èµ·å‹•ã•ã›ã¾ã™ã€‚

```
xv6 kernel is booting

17:38:44.308 [I] net_init: initialized (kernel/net/net.c:365)
17:38:44.309 [D] net_run: open all devices... (kernel/net/net.c:311)
17:38:44.309 [D] net_run: running... (kernel/net/net.c:315)
hart 1 starting
hart 2 starting
init: starting sh
$
```

> [!NOTE]
> ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã®åˆæœŸåŒ–ã«ç¶šã‘ã¦èµ·å‹•å‡¦ç†ãŒå®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹ã“ã¨ãŒç¢ºèªã§ãã¾ã™ã€‚

## 3.2. Ethernetãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«

è‡ªä½œãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã®Ethernetãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç§»æ¤ã—ã¾ã™ã€‚

#### ğŸŒŸ Ethernetãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚³ãƒ¼ãƒ‰ã®è¿½åŠ 

Ethernetãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ã¾ã™ã€‚

> [!IMPORTANT]
> é€å—ä¿¡ã¨ã‚‚ã«ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã§æŒã£ã¦ã„ãŸå¤§ããªãƒãƒƒãƒ•ã‚¡ã‚’å‹•çš„ãƒ¡ãƒ¢ãƒªç¢ºä¿ã«å¤‰æ›´ã—ã¦ã‚ã‚Šã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/net/ether.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```c
#ifndef ETHER_H
#define ETHER_H

#include "platform.h"

#include "net.h"

#define ETHER_ADDR_LEN 6
#define ETHER_ADDR_STR_LEN 18 /* "xx:xx:xx:xx:xx:xx\0" */

#define ETHER_HDR_SIZE 14
#define ETHER_FRAME_SIZE_MIN   60 /* without FCS */
#define ETHER_FRAME_SIZE_MAX 1514 /* without FCS */
#define ETHER_PAYLOAD_SIZE_MIN (ETHER_FRAME_SIZE_MIN - ETHER_HDR_SIZE)
#define ETHER_PAYLOAD_SIZE_MAX (ETHER_FRAME_SIZE_MAX - ETHER_HDR_SIZE)

/* see https://www.iana.org/assignments/ieee-802-numbers/ieee-802-numbers.txt */
#define ETHER_TYPE_IP   0x0800
#define ETHER_TYPE_ARP  0x0806
#define ETHER_TYPE_IPV6 0x86dd

extern const uint8_t ETHER_ADDR_ANY[ETHER_ADDR_LEN];
extern const uint8_t ETHER_ADDR_BROADCAST[ETHER_ADDR_LEN];

extern int
ether_addr_pton(const char *p, uint8_t *n);
extern char *
ether_addr_ntop(const uint8_t *n, char *p, size_t size);

typedef ssize_t (*ether_transmit_func_t)(struct net_device *dev, const uint8_t *data, size_t len);
typedef ssize_t (*ether_input_func_t)(struct net_device *dev, uint8_t *buf, size_t size);

extern int
ether_transmit_helper(struct net_device *dev, uint16_t type, const uint8_t *payload, size_t plen, const void *dst, ether_transmit_func_t callback);
extern int
ether_input_helper(struct net_device *dev, ether_input_func_t callback);
extern void
ether_setup_helper(struct net_device *dev);

#endif
```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/net/ether.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```c
#include "platform.h"

#include "util.h"
#include "net.h"
#include "ether.h"

struct ether_hdr {
    uint8_t dst[ETHER_ADDR_LEN];
    uint8_t src[ETHER_ADDR_LEN];
    uint16_t type;
};

const uint8_t ETHER_ADDR_ANY[ETHER_ADDR_LEN] = {"\x00\x00\x00\x00\x00\x00"};
const uint8_t ETHER_ADDR_BROADCAST[ETHER_ADDR_LEN] = {"\xff\xff\xff\xff\xff\xff"};

int
ether_addr_pton(const char *p, uint8_t *n)
{
    int index;
    char *ep;
    long val;

    if (!p || !n) {
        return -1;
    }
    for (index = 0; index < ETHER_ADDR_LEN; index++) {
        val = strtol(p, &ep, 16);
        if (ep == p || val < 0 || val > 0xff || (index < ETHER_ADDR_LEN - 1 && *ep != ':')) {
            break;
        }
        n[index] = (uint8_t)val;
        p = ep + 1;
    }
    if (index != ETHER_ADDR_LEN || *ep != '\0') {
        return -1;
    }
    return 0;
}

char *
ether_addr_ntop(const uint8_t *n, char *p, size_t size)
{
    if (!n || !p) {
        return NULL;
    }
    snprintf(p, size, "%02x:%02x:%02x:%02x:%02x:%02x", n[0], n[1], n[2], n[3], n[4], n[5]);
    return p;
}

static void
ether_dump(const uint8_t *frame, size_t flen)
{
    struct ether_hdr *hdr;
    char addr[ETHER_ADDR_STR_LEN];

    hdr = (struct ether_hdr *)frame;
    flockfile(stderr);
    fprintf(stderr, "        src: %s\n", ether_addr_ntop(hdr->src, addr, sizeof(addr)));
    fprintf(stderr, "        dst: %s\n", ether_addr_ntop(hdr->dst, addr, sizeof(addr)));
    fprintf(stderr, "       type: 0x%04x\n", ntoh16(hdr->type));
#ifdef HEXDUMP
    hexdump(stderr, frame, flen);
#endif
    funlockfile(stderr);
}

int
ether_transmit_helper(struct net_device *dev, uint16_t type, const uint8_t *data, size_t len, const void *dst, ether_transmit_func_t callback)
{
    uint8_t *frame;
    struct ether_hdr *hdr;
    size_t flen, pad = 0;
    int ret;

    frame = memory_alloc(ETHER_FRAME_SIZE_MAX);
    if (!frame) {
        return -1;
    }
    hdr = (struct ether_hdr *)frame;
    memcpy(hdr->dst, dst, ETHER_ADDR_LEN);
    memcpy(hdr->src, dev->addr, ETHER_ADDR_LEN);
    hdr->type = hton16(type);
    memcpy(hdr+1, data, len);
    if (len < ETHER_PAYLOAD_SIZE_MIN) {
        pad = ETHER_PAYLOAD_SIZE_MIN - len;
    }
    flen = sizeof(*hdr) + len + pad;
    debugf("dev=%s, type=0x%04x, len=%zu", dev->name, type, flen);
    ether_dump(frame, flen);
    ret = callback(dev, frame, flen) == (ssize_t)flen ? 0 : -1;
    memory_free(frame);
    return ret;
}

int
ether_input_helper(struct net_device *dev, ether_input_func_t callback)
{
    uint8_t *frame;
    ssize_t flen;
    struct ether_hdr *hdr;
    uint16_t type;
    int ret;

    frame = memory_alloc(ETHER_FRAME_SIZE_MAX);
    if (!frame) {
        return -1;
    }
    flen = callback(dev, frame, ETHER_FRAME_SIZE_MAX);
    if (flen < (ssize_t)sizeof(*hdr)) {
        errorf("too short");
        memory_free(frame);
        return -1;
    }
    hdr = (struct ether_hdr *)frame;
    if (memcmp(dev->addr, hdr->dst, ETHER_ADDR_LEN) != 0) {
        if (memcmp(ETHER_ADDR_BROADCAST, hdr->dst, ETHER_ADDR_LEN) != 0) {
            /* for other host */
            memory_free(frame);
            return -1;
        }
    }
    type = ntoh16(hdr->type);
    debugf("dev=%s, type=0x%04x, len=%zd", dev->name, type, flen);
    ether_dump(frame, flen);
    ret = net_input_handler(type, (uint8_t *)(hdr+1), flen - sizeof(*hdr), dev);
    memory_free(frame);
    return ret;
}

void
ether_setup_helper(struct net_device *dev)
{
    dev->type = NET_DEVICE_TYPE_ETHERNET;
    dev->mtu = ETHER_PAYLOAD_SIZE_MAX;
    dev->flags = (NET_DEVICE_FLAG_BROADCAST | NET_DEVICE_FLAG_NEED_ARP);
    dev->hlen = ETHER_HDR_SIZE;
    dev->alen = ETHER_ADDR_LEN;
    memcpy(dev->broadcast, ETHER_ADDR_BROADCAST, ETHER_ADDR_LEN);
}
```
</details>

#### ğŸŒŸ Makefileã®ä¿®æ­£

ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¿½åŠ ã—ãŸã®ã§`Makefile`ã‚’ä¿®æ­£ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• Makefileï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
 OBJS = \
...
   $K/virtio_disk.o \
   $N/util.o \
   $N/net.o \
+  $N/ether.o \
   $P/std.o

```
</details>

ä¸€æ—¦ã€ã“ã®çŠ¶æ…‹ã§ãƒ“ãƒ«ãƒ‰ãŒé€šã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãŠãã¾ã—ã‚‡ã†ã€‚

```
$ make clean
$ make
```

## 3.3. virtio-netãƒ‰ãƒ©ã‚¤ãƒ

QEMUãŒæä¾›ã™ã‚‹ã€Œvirtio-netã€ãƒ‡ãƒã‚¤ã‚¹ã®ãƒ‰ãƒ©ã‚¤ãƒã‚’ä½œæˆã—ã¾ã™ã€‚

> [!NOTE]
> virtio-netã‚’ã¯ã˜ã‚ã¨ã™ã‚‹virtioãƒ‡ãƒã‚¤ã‚¹ã¯ã€ç‰©ç†çš„ãªãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã‚’ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã§å®Œå…¨ã«ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã®ã¨ã¯ç•°ãªã‚Šã€ã‚²ã‚¹ãƒˆOSãŒè‡ªèº«ãŒä»®æƒ³ãƒ‡ãƒã‚¤ã‚¹ã§ã‚ã‚‹ã“ã¨ã‚’èªè­˜ã—ã¦ãƒã‚¤ãƒ‘ãƒ¼ãƒã‚¤ã‚¶ãƒ¼ã¨å”èª¿ã—ã¦åŠ¹ç‡çš„ã«å‹•ä½œã™ã‚‹ã‚ˆã†ã«è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚

> [!NOTE]
> RISC-Vç‰ˆã®xv6ã§ã¯ã€ãƒ‡ã‚£ã‚¹ã‚¯è£…ç½®ã«virtio-diskã‚’åˆ©ç”¨ã—ã¦ãŠã‚Šã€æ—¢ã«virtioãƒ‡ãƒã‚¤ã‚¹ã‚’æ‰±ã†ãŸã‚ã®ã‚³ãƒ¼ãƒ‰ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚’å‚è€ƒã«ã—ãªãŒã‚‰ã€æ–°ãŸã«virtio-netã«å¯¾å¿œã•ã›ã¦ã„ãã¾ã™ã€‚

#### ğŸŒŸ virtio-netãƒ‡ãƒã‚¤ã‚¹ã®æ¥ç¶š

ã¾ãšã€QEMUã‚’èµ·å‹•ã—ãŸéš›ã«ã‚²ã‚¹ãƒˆã§ã‚ã‚‹xv6ã«å¯¾ã—ã¦virtio-netãƒ‡ãƒã‚¤ã‚¹ãŒæä¾›ã•ã‚Œã‚‹ã‚ˆã†ã«`Makefile`ã‚’ä¿®æ­£ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• Makefileï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...

+TAPDEV=tap0
+TAPADDR=192.0.2.1/24
+
 QEMUOPTS = -machine virt -bios none -kernel $K/kernel -m 128M -smp $(CPUS) -nographic
 QEMUOPTS += -global virtio-mmio.force-legacy=false
 QEMUOPTS += -drive file=fs.img,if=none,format=raw,id=x0
 QEMUOPTS += -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0
+QEMUOPTS += -netdev tap,ifname=$(TAPDEV),id=en0
+QEMUOPTS += -device virtio-net-device,netdev=en0,csum=off,gso=off,guest_csum=off,bus=virtio-mmio-bus.1
 
+tap:
+       @ip addr show $(TAPDEV) 2>/dev/null || (echo "Create '$(TAPDEV)'"; \
+         sudo ip tuntap add mode tap user $(USER) name $(TAPDEV); \
+         sudo sysctl -w net.ipv6.conf.$(TAPDEV).disable_ipv6=1; \
+         sudo ip addr add $(TAPADDR) dev $(TAPDEV); \
+         sudo ip link set $(TAPDEV) up; \
+         ip addr show $(TAPDEV); \
+       )
+
-qemu: $K/kernel fs.img
+qemu: $K/kernel fs.img tap
        $(QEMU) $(QEMUOPTS)

...
```
</details>

> [!NOTE]
> QEMUã®èµ·å‹•ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¨˜è¿°ã™ã‚‹`QEMUOPTS`ã«å¯¾ã—ã¦virtio-netã‚’ç”¨ã„ãŸãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ‡ãƒã‚¤ã‚¹ã‚’è¿½åŠ ã™ã‚‹è¨­å®šã‚’åŠ ãˆã¾ã™ã€‚ã“ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ‡ãƒã‚¤ã‚¹ã¯ãƒ›ã‚¹ãƒˆå´ã®Tapãƒ‡ãƒã‚¤ã‚¹ã«æ¥ç¶šã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

> [!NOTE]
> virtioã®ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆä»•æ§˜ã«ã¯PCIã¨MMIOãŒã‚ã‚Šã¾ã™ãŒã€ã“ã“ã§ã¯PCIã‚ˆã‚Šã‚‚å®Ÿè£…ã—ã‚„ã™ã„MMIOã‚’æ¡ç”¨ã—ã¦ã„ã¾ã™ã€‚

> [!NOTE]
> QEMUã¯èµ·å‹•æ™‚ã«Tapãƒ‡ãƒã‚¤ã‚¹ã‚’ä½œæˆã—ã¾ã™ãŒã€IPã‚¢ãƒ‰ãƒ¬ã‚¹ã®è¨­å®šã¾ã§ã¯ã‚„ã£ã¦ãã‚Œã¾ã›ã‚“ã€‚`make qemu`ã‚’å®Ÿè¡Œã—ãŸéš›ã«Tapãƒ‡ãƒã‚¤ã‚¹ãŒå­˜åœ¨ã—ãªã‘ã‚Œã°ä½œæˆã—ã¦IPã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¨­å®šã™ã‚‹å‡¦ç†ã‚‚åˆã‚ã›ã¦è¿½åŠ ã—ã¦ã„ã¾ã™ã€‚

å†ãƒ“ãƒ«ãƒ‰ã—ãŸå¾Œã€`make qemu`ã‚’å®Ÿè¡Œã—ã¦xv6ã‚’èµ·å‹•ã•ã›ã¾ã™ã€‚

> [!NOTE]
> QEMUã‚’èµ·å‹•ã™ã‚‹å‰ã«Tapãƒ‡ãƒã‚¤ã‚¹ã‚’ä½œæˆã—ã¦IPã‚¢ãƒ‰ãƒ¬ã‚¹ãŒè¨­å®šã•ã‚Œã‚‹ã¯ãšã§ã™ã€‚

```
Create 'tap0'
net.ipv6.conf.tap0.disable_ipv6 = 1
79: tap0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc fq_codel state DOWN group default qlen 1000
    link/ether 16:2a:af:19:b5:91 brd ff:ff:ff:ff:ff:ff
    inet 192.0.2.1/24 scope global tap0
       valid_lft forever preferred_lft forever
...
```

> [!NOTE]
> ç¶šã‘ã¦QEMUãŒèµ·å‹•ã—ã¦ãã‚Œã°å¤§ä¸ˆå¤«ã§ã™ã€‚èµ·å‹•ã«å¤±æ•—ã—ãŸå ´åˆã¯`QEMUOPT`ã¸ã®è¿½åŠ å†…å®¹ã«ãƒŸã‚¹ãŒãªã„ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚

```
xv6 kernel is booting

17:38:44.308 [I] net_init: initialized (kernel/net/net.c:365)
17:38:44.309 [D] net_run: open all devices... (kernel/net/net.c:311)
17:38:44.309 [D] net_run: running... (kernel/net/net.c:315)
hart 1 starting
hart 2 starting
init: starting sh
$
```

#### ğŸŒŸ MMIOã‚¢ãƒ‰ãƒ¬ã‚¹ã®ãƒãƒƒãƒ”ãƒ³ã‚°

QEMUãŒæä¾›ã™ã‚‹virtio-netãƒ‡ãƒã‚¤ã‚¹ã‚’xv6ã§æ‰±ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã®è¨­å®šã‚’è¡Œã„ã¾ã™ã€‚ã“ã‚Œã¯åŒã˜MMIOãƒ‡ãƒã‚¤ã‚¹ã§ã‚ã‚‹Goldfish RTCã‚’æ‰±ãˆã‚‹ã‚ˆã†ã«ã—ãŸæ™‚ã¨åŒã˜ä½œæ¥­ã§ã™ã€‚

> [!NOTE]
> Goldfish RTCã¨åŒæ§˜ã«virtioãƒ‡ãƒã‚¤ã‚¹ã®ç‰©ç†ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚‚QEMUå´ã§æ±ºã‚ã‚‰ã‚Œã¦ãŠã‚Šã€1ã¤ã‚ã®virtioãƒ‡ãƒã‚¤ã‚¹ãŒ`0x10001000`ã€2ã¤ã‚ã®virtioãƒ‡ãƒã‚¤ã‚¹ãŒ`0x10002000`ã«é…ç½®ã•ã‚Œã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/memlayout.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
 // Physical memory layout

 // qemu -machine virt is set up like this,
 // based on qemu's hw/riscv/virt.c:
 //
 // 00001000 -- boot ROM, provided by qemu
 // 00101000 -- RTC
 // 02000000 -- CLINT
 // 0C000000 -- PLIC
 // 10000000 -- uart0 
 // 10001000 -- virtio disk
+// 10002000 -- virtio network 
 // 80000000 -- boot ROM jumps here in machine mode
 //             -kernel loads the kernel here
 // unused RAM after 80000000.

 // the kernel uses physical memory thus:
 // 80000000 -- entry.S, then kernel text and data
 // end -- start of kernel page allocation area
 // PHYSTOP -- end RAM used by the kernel

 // Goldfish RTC
 #define RTC 0x00101000L

 // qemu puts UART registers here in physical memory.
 #define UART0 0x10000000L
 #define UART0_IRQ 10

 // virtio mmio interface
 #define VIRTIO0 0x10001000
 #define VIRTIO0_IRQ 1
+#define VIRTIO1 0x10002000L
+#define VIRTIO1_IRQ 2

...
```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/vm.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...
 pagetable_t
 kvmmake(void)
 {
...
   // virtio mmio disk interface
   kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
 
+  // virtio mmio network interface
+  kvmmap(kpgtbl, VIRTIO1, VIRTIO1, PGSIZE, PTE_R | PTE_W);
+
   // PLIC
   kvmmap(kpgtbl, PLIC, PLIC, 0x4000000, PTE_R | PTE_W);
...
 }
```
</details>

#### ğŸŒŸ virtio-netãƒ‡ãƒã‚¤ã‚¹ã®ãƒ‰ãƒ©ã‚¤ãƒã‚’è¿½åŠ 

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/net/platform/xv6-riscv/virtio_net.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```c
#include "platform.h"
#include "memlayout.h"
#include "virtio.h"

#include "util.h"
#include "net.h"
#include "ether.h"

#define R(r) ((volatile uint32_t *)(VIRTIO1 + (r)))

/*
 * virtq
 */

struct virtq {
    struct virtq_desc *desc;
    struct virtq_avail *avail;
    struct virtq_used *used;
    int num;
    int last_used_idx;
    char *free;
};

void
virtq_init(struct virtq *vq, int sel, int num)
{
    uint32_t max;

    // select queue
    *R(VIRTIO_MMIO_QUEUE_SEL) = sel;

    // ensure selected queue is not in use.
    if (*R(VIRTIO_MMIO_QUEUE_READY)) {
        panic("queue already in use");
    }

    // check maximum queue size.
    max = *R(VIRTIO_MMIO_QUEUE_NUM_MAX);
    if (max == 0) {
        panic("queue not available");
    }
    if (max < num) {
        panic("queue too short");
    }

    // allocate and zero queue memory.
    vq->desc = kalloc();
    vq->avail = kalloc();
    vq->used = kalloc();
    vq->free = kalloc();
    if (!vq->desc || !vq->avail || !vq->used || !vq->free) {
        panic("kalloc failed");
    }
    memset(vq->desc, 0, PGSIZE);
    memset(vq->avail, 0, PGSIZE);
    memset(vq->used, 0, PGSIZE);
    memset(vq->free, 0,  PGSIZE);

    // set queue size.
    vq->num = num;
    *R(VIRTIO_MMIO_QUEUE_NUM) = vq->num;

    // write physical addresses.
    *R(VIRTIO_MMIO_QUEUE_DESC_LOW) = (uint64_t)vq->desc;
    *R(VIRTIO_MMIO_QUEUE_DESC_HIGH) = (uint64_t)vq->desc >> 32;
    *R(VIRTIO_MMIO_DRIVER_DESC_LOW) = (uint64_t)vq->avail;
    *R(VIRTIO_MMIO_DRIVER_DESC_HIGH) = (uint64_t)vq->avail >> 32;
    *R(VIRTIO_MMIO_DEVICE_DESC_LOW) = (uint64_t)vq->used;
    *R(VIRTIO_MMIO_DEVICE_DESC_HIGH) = (uint64_t)vq->used >> 32;

    // queue is ready.
    *R(VIRTIO_MMIO_QUEUE_READY) = 1;

    // all descriptors start out unused.
    for (int i = 0; i < vq->num; i++) {
        vq->free[i] = 1;
    }
    vq->last_used_idx = 0;
}

// find a free descriptor, mark it non-free, return its index.
int
virtq_alloc_desc(struct virtq *vq)
{
    for (int i = 0; i < vq->num; i++) {
        if(vq->free[i]){
            vq->free[i] = 0;
            return i;
        }
    }
    return -1;
}

// mark a descriptor as free.
void
virtq_free_desc(struct virtq *vq, int i)
{
    if (i >= vq->num) {
        panic("virtq_free_desc: invalid index");
    }
    if (vq->free[i]) {
        panic("virtq_free_desc: freeing free descriptor");
    }
    vq->desc[i].addr = 0;
    vq->desc[i].len = 0;
    vq->desc[i].flags = 0;
    vq->desc[i].next = 0;
    vq->free[i] = 1;
}

/*
 * virtio-net
 */

#define RXQ 0
#define TXQ 1

#define QSIZE NUM
#define RX_BUF_SIZE 2048

#define VIRTIO_MMIO_CONFIG 0x100
#define VIRTIO_NET_F_CSUM 0
#define VIRTIO_NET_F_GUEST_CSUM 1
#define VIRTIO_NET_F_MAC 5
#define VIRTIO_F_VERSION_1 32

struct virtio_net {
    struct net_device *dev;
    uint32_t status;
    uint64_t features;
    struct spinlock lock;
    struct virtq rx_q;
    struct virtq tx_q;
    char rx_bufs[QSIZE][RX_BUF_SIZE];
    char tx_bufs[QSIZE][RX_BUF_SIZE];
    char tx_status[QSIZE];
} _nic0;

struct virtio_net_hdr {
#define VIRTIO_NET_HDR_F_NEEDS_CSUM 1
#define VIRTIO_NET_HDR_F_DATA_VALID 2
#define VIRTIO_NET_HDR_F_RSC_INFO 4
    uint8_t flags;
#define VIRTIO_NET_HDR_GSO_NONE 0
#define VIRTIO_NET_HDR_GSO_TCPV4 1
#define VIRTIO_NET_HDR_GSO_UDP 3
#define VIRTIO_NET_HDR_GSO_TCPV6 4
#define VIRTIO_NET_HDR_GSO_ECN 0x80
    uint8_t gso_type;
    uint16_t hdr_len;
    uint16_t gso_size;
    uint16_t csum_start;
    uint16_t csum_offset;
    uint16_t num_buffers;
};

#define PRIV(x) ((struct virtio_net *)(x)->priv)

static int
virtio_net_open(struct net_device *dev)
{
    struct virtio_net *nic = PRIV(dev);

    acquire(&nic->lock);

    // set receive buffers
    for (int i = 0; i < QSIZE; i++) {
        nic->rx_q.desc[i].addr = (uint64)nic->rx_bufs[i];
        nic->rx_q.desc[i].len = RX_BUF_SIZE;
        nic->rx_q.desc[i].flags = VRING_DESC_F_WRITE;
        nic->rx_q.avail->ring[i] = i;
        nic->rx_q.free[i] = 0;
    }
    __sync_synchronize();
    nic->rx_q.avail->idx = QSIZE;
    nic->rx_q.last_used_idx = 0;

    // tell device we're completely ready.
    nic->status |= VIRTIO_CONFIG_S_DRIVER_OK;
    *R(VIRTIO_MMIO_STATUS) = nic->status;

    // Notify the device of new RX buffers.
    *R(VIRTIO_MMIO_QUEUE_NOTIFY) = RXQ;

    release(&nic->lock);

    return 0;
}

static int
virtio_net_close(struct net_device *dev)
{
    struct virtio_net *nic = PRIV(dev);

    acquire(&nic->lock);

    nic->status = *R(VIRTIO_MMIO_STATUS);

    // clear DRIVER_OK bit
    nic->status &= ~VIRTIO_CONFIG_S_DRIVER_OK;
    *R(VIRTIO_MMIO_STATUS) = nic->status;

    release(&nic->lock);
    return 0;
}

static ssize_t 
virtio_net_write(struct net_device *dev, const uint8_t *data, size_t len)
{
    struct virtio_net *nic = PRIV(dev);
    int idx;
    void *buf;
    struct virtio_net_hdr *hdr;

    if (len > RX_BUF_SIZE) {
        return -1;
    }
 
    acquire(&nic->lock);

    // Allocate descriptor
    idx = virtq_alloc_desc(&nic->tx_q);
    if (idx == -1) {
        release(&nic->lock);
        return -1;
    }

    buf = nic->tx_bufs[idx];
    hdr = buf;

    // Setup virtio-net header.
    hdr->flags = 0; // assume the packet is completely checksummed
    hdr->gso_type = VIRTIO_NET_HDR_GSO_NONE;
    hdr->hdr_len = 0; // unused
    hdr->gso_size = 0; // unused
    hdr->csum_start = 0; // unused
    hdr->csum_offset = 0; // unused
    hdr->num_buffers = 0; // driver must set num_buffers to 0
    memmove(nic->tx_bufs[idx] + sizeof(*hdr), data, len);

    // Configure descriptor
    nic->tx_q.desc[idx].addr = (uint64_t)nic->tx_bufs[idx];
    nic->tx_q.desc[idx].len = sizeof(*hdr) + len;
    nic->tx_q.desc[idx].flags = 0; // read by device

    // Deploy descriptor in the available ring.
    nic->tx_q.avail->ring[nic->tx_q.avail->idx % nic->tx_q.num] = idx;
    __sync_synchronize();
    nic->tx_q.avail->idx++;
    __sync_synchronize();

    release(&nic->lock);

    // Notify the device of a new TX packet.
    *R(VIRTIO_MMIO_QUEUE_NOTIFY) = TXQ;

    return len;
}

static int
virtio_net_transmit(struct net_device *dev, uint16_t type, const uint8_t *packet, size_t len, const void *dst)
{
  return ether_transmit_helper(dev, type, packet, len, dst, virtio_net_write);;
}

static ssize_t
virtio_net_read(struct net_device *dev, uint8_t *buf, size_t size)
{
    struct virtio_net *nic = PRIV(dev);

    int ring_idx = nic->rx_q.last_used_idx % nic->rx_q.num;
    int idx = nic->rx_q.used->ring[ring_idx].id;
    int len = nic->rx_q.used->ring[ring_idx].len;

    // The actual data starts after the virtio-net header.
    int hdrlen = sizeof(struct virtio_net_hdr);
    memcpy(buf, nic->rx_bufs[idx] + hdrlen, len - hdrlen);

    // Recycle the receive buffer descriptor.
    nic->rx_q.desc[idx].addr = (uint64_t)nic->rx_bufs[idx];
    nic->rx_q.desc[idx].len = RX_BUF_SIZE;

    // Return the descriptor to the available ring.
    nic->rx_q.avail->ring[nic->rx_q.avail->idx % nic->rx_q.num] = idx;

    return len - hdrlen;
}

void
virtio_net_intr(void)
{
    struct virtio_net *nic = &_nic0;

    acquire(&nic->lock);

    // Acknowledge the interrupt and clear the status by writing it back.
    *R(VIRTIO_MMIO_INTERRUPT_ACK) = *R(VIRTIO_MMIO_INTERRUPT_STATUS) & 0x3;
    __sync_synchronize();

    // Process completed descriptors from the tx used ring.
    while (nic->tx_q.last_used_idx != nic->tx_q.used->idx) {
        int ring_idx = nic->tx_q.last_used_idx % nic->tx_q.num;
        int idx = nic->tx_q.used->ring[ring_idx].id;
        virtq_free_desc(&nic->tx_q, idx);
        nic->tx_q.last_used_idx++;
    }

    // Process incoming packets from the rx used ring.
    while (nic->rx_q.last_used_idx != nic->rx_q.used->idx) {
        ether_input_helper(nic->dev, virtio_net_read);
        __sync_synchronize();
        nic->rx_q.avail->idx++;
        nic->rx_q.last_used_idx++;
    }
    __sync_synchronize();

    release(&nic->lock);

    // Notify the device of new RX buffers.
    *R(VIRTIO_MMIO_QUEUE_NOTIFY) = RXQ;

    intr_raise_irq(INTR_IRQ_SOFTIRQ);
}

struct net_device_ops virtio_net_ops = {
    .open = virtio_net_open,
    .close = virtio_net_close,
    .transmit = virtio_net_transmit,
};

void
virtio_net_init(void)
{
    struct virtio_net *nic = &_nic0;
    uint8_t addr[6];
    struct net_device *dev;
    char mac[ETHER_ADDR_STR_LEN];

    initlock(&nic->lock, "virtio-net");

    // find virtio-net device
    if (*R(VIRTIO_MMIO_MAGIC_VALUE) != 0x74726976 ||
        *R(VIRTIO_MMIO_VERSION) != 2 ||
        *R(VIRTIO_MMIO_DEVICE_ID) != 1 || // network device
        *R(VIRTIO_MMIO_VENDOR_ID) != 0x554d4551){
        panic("virtio-net: device not found");
    }

    debugf("device found");

    // reset device
    nic->status = 0;
    *R(VIRTIO_MMIO_STATUS) = nic->status;

    // set ACKNOWLEDGE status bit
    nic->status |= VIRTIO_CONFIG_S_ACKNOWLEDGE;
    *R(VIRTIO_MMIO_STATUS) = nic->status;

    // set DRIVER status bit
    nic->status |= VIRTIO_CONFIG_S_DRIVER;
    *R(VIRTIO_MMIO_STATUS) = nic->status;

    // negotiate features
    nic->features = *R(VIRTIO_MMIO_DEVICE_FEATURES);
    nic->features &= ~(1ULL << VIRTIO_RING_F_EVENT_IDX);
    nic->features &= ~(1ULL << VIRTIO_NET_F_CSUM);
    nic->features |= (1ULL << VIRTIO_NET_F_GUEST_CSUM);
    *R(VIRTIO_MMIO_DRIVER_FEATURES) = nic->features;

    // tell device that feature negotiation is complete.
    nic->status |= VIRTIO_CONFIG_S_FEATURES_OK;
    *R(VIRTIO_MMIO_STATUS) = nic->status;

    // re-read status to ensure FEATURES_OK is set.
    if (!(*R(VIRTIO_MMIO_STATUS) & VIRTIO_CONFIG_S_FEATURES_OK)) {
        panic("virtio-net: FEATURES_OK failed");
    }

    // read MAC address
    if (nic->features & (1 << VIRTIO_NET_F_MAC)) {
        for (int i = 0; i < 6; i++) {
            addr[i] = *(volatile uint8_t *)((uint64)(VIRTIO1 + VIRTIO_MMIO_CONFIG + i));
        }
    } else {
        debugf("device does not provide a MAC address");
    }

    // initialize TXQ
    virtq_init(&nic->tx_q, TXQ, QSIZE);

    // initialize RXQ
    virtq_init(&nic->rx_q, RXQ, QSIZE);
    for (int i = 0; i < QSIZE; i++) {
        nic->rx_q.desc[i].addr = (uint64_t)nic->rx_bufs[i];
        nic->rx_q.desc[i].len = RX_BUF_SIZE;
        nic->rx_q.desc[i].flags = VRING_DESC_F_WRITE;
        nic->rx_q.avail->ring[i] = i;
        nic->rx_q.free[i] = 0;
    }
    __sync_synchronize();
    nic->rx_q.avail->idx = QSIZE;

    // tell device we're completely ready.
    nic->status |= VIRTIO_CONFIG_S_DRIVER_OK;
    *R(VIRTIO_MMIO_STATUS) = nic->status;

    // setup device driver structure
    dev = net_device_alloc();
    if (!dev) {
        errorf("net_device_alloc() failure");
        return;
    }
    ether_setup_helper(dev);
    memcpy(dev->addr, addr, sizeof(addr));
    dev->priv = nic;
    dev->ops = &virtio_net_ops;
    if (net_device_register(dev) == -1) {
        errorf("net_device_register() failure");
        memory_free(dev);
        return;
    }
    nic->dev = dev;

    debugf("initialized, addr=%s", ether_addr_ntop(dev->addr, mac, sizeof(mac)));
}
```
</details>

> [!NOTE]
> virtioãƒ‡ãƒã‚¤ã‚¹ã®åˆæœŸåŒ–ã®æµã‚Œã€‚
> - `STATUS`ãƒ¬ã‚¸ã‚¹ã‚¿ã«`0`ã‚’æ›¸ãè¾¼ã‚“ã§ãƒ‡ãƒã‚¤ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹ã€‚
> - `STATUS`ãƒ¬ã‚¸ã‚¹ã‚¿ã«`ACKNOWLEDGE`ãƒ“ãƒƒãƒˆã‚’ã‚»ãƒƒãƒˆã™ã‚‹ã€‚
> - `STATUS`ãƒ¬ã‚¸ã‚¹ã‚¿ã«`DRIVER`ãƒ“ãƒƒãƒˆã‚’ã‚»ãƒƒãƒˆã™ã‚‹ã€‚
> - ãƒ‡ãƒã‚¤ã‚¹ã¨ãƒ‰ãƒ©ã‚¤ãƒã®é–“ã§æ©Ÿèƒ½ã‚’ãƒã‚´ã‚·ã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ã™ã‚‹ã€‚
>     - `DEVICE_FEATURES`ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’èª­ã‚“ã§ãƒ‡ãƒã‚¤ã‚¹ãŒæä¾›ã™ã‚‹æ©Ÿèƒ½ã‚’å–å¾—ã™ã‚‹ã€‚
>     - ãƒ‰ãƒ©ã‚¤ãƒãŒä½¿ç”¨ã—ãŸã„æ©Ÿèƒ½ã‚’è¿½åŠ ã—ãŸã‚Šä½¿ç”¨ã—ãŸããªã„æ©Ÿèƒ½ã‚’å‰Šé™¤ã—ã¦`DRIVER_FEATURES`ã«ã‚»ãƒƒãƒˆã™ã‚‹ã€‚
> - `STATUS`ãƒ¬ã‚¸ã‚¹ã‚¿ã«`FEATURES_OK`ã‚’ã‚»ãƒƒãƒˆã™ã‚‹ã€‚
> - `STATUS`ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’èª­ã¿å–ã£ã¦`FEATURES_OK`ãŒã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹ã€‚
>     - `FEATURES_OK`ãŒã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ãªã‹ãŸã‚‰ãƒã‚´ã‚·ã‚¨ãƒ¼ã‚·ãƒ§ãƒ³å¤±æ•—ã€‚
> - é€å—ä¿¡ã‚­ãƒ¥ãƒ¼ã®åˆæœŸåŒ–
> - å—ä¿¡ã‚­ãƒ¥ãƒ¼ã«ãƒ‘ã‚±ãƒƒãƒˆã‚’æ ¼ç´ã™ã‚‹ãŸã‚ã®ãƒãƒƒãƒ•ã‚¡ã‚’è¨­å®š
> - `STATUS`ãƒ¬ã‚¸ã‚¹ã‚¿ã«`DRIVER_OK`ã‚’ã‚»ãƒƒãƒˆã™ã‚‹ã€‚

> [!NOTE]
> ãƒã‚´ã‚·ã‚¨ãƒ¼ã‚·ãƒ§ãƒ³æ™‚ã®æ³¨æ„ç‚¹ã€‚
> - `VIRTIO_RING_F_EVENT_IDX`ãƒ•ãƒ©ã‚°ã‚’å–ã‚Šé™¤ã„ã¦ã„ã¾ã™ã€‚ã“ã®ãƒ•ãƒ©ã‚°ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã¨ã‚¤ãƒ™ãƒ³ãƒˆé€šçŸ¥ãŒæœ€é©åŒ–ã•ã‚Œã€ãƒ‰ãƒ©ã‚¤ãƒå´ã§é©åˆ‡ã«å¯¾å‡¦ã—ãªã„ã¨æ¬¡ã®ã‚¤ãƒ™ãƒ³ãƒˆé€šçŸ¥ãŒå—ã‘å–ã‚Œãªããªã£ã¦ã—ã¾ã„ã¾ã™ã€‚
> - `VIRTIO_NET_F_CSUM`ãƒ•ãƒ©ã‚°ã‚’å–ã‚Šé™¤ã„ã¦ã„ã¾ã™ã€‚ã“ã®ãƒ•ãƒ©ã‚°ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã¨ãƒ‡ãƒã‚¤ã‚¹å´ã§ã®ãƒã‚§ãƒƒã‚¯ã‚µãƒ è¨ˆç®—ã®ã‚ªãƒ•ãƒ­ãƒ¼ãƒ‰ãŒæœ‰åŠ¹ã«ãªã‚Šã€ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆå±¤ã§å—ä¿¡ãƒ‘ã‚±ãƒƒãƒˆã®ãƒã‚§ãƒƒã‚¯ã‚µãƒ ç•°å¸¸ã‚’æ¤œå‡ºã—ã¦ã—ã¾ã†ã“ã¨ãŒã‚ã‚‹ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚

> [!NOTE]
> é€å—ä¿¡ã‚­ãƒ¥ãƒ¼åˆæœŸåŒ–ã®æµã‚Œã€‚
> - `QUEUE_SEL`ãƒ¬ã‚¸ã‚¹ã‚¿ã«åˆæœŸåŒ–ã—ãŸã„ã‚­ãƒ¥ãƒ¼ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆ`0`ã‹ã‚‰å§‹ã¾ã‚‹ç•ªå·ï¼‰ã‚’æ›¸ãè¾¼ã‚€ã€‚
> - `QUEUE_READY`ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’èª­ã¿å–ã‚‹
>     - èª­ã¿å–ã£ãŸå€¤ãŒ`0`ã§ãªã‹ã£ãŸã‚‰ãã®ã‚­ãƒ¥ãƒ¼ã¯æ—¢ã«åˆæœŸåŒ–æ¸ˆã¿ã§ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã®ã§å¤±æ•—ã€‚
> - `QUEUE_NUM_MAX`ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’èª­ã¿å–ã‚“ã§ãƒ‡ãƒã‚¤ã‚¹ãŒã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚­ãƒ¥ãƒ¼ã®æœ€å¤§ã‚µã‚¤ã‚ºã‚’å–å¾—ã™ã‚‹
>     - å€¤ãŒ`0`ã®å ´åˆã€ãã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ã‚­ãƒ¥ãƒ¼ã¯å­˜åœ¨ã—ãªã„ã€‚
> - ã‚­ãƒ¥ãƒ¼ã‚’æ§‹æˆã™ã‚‹3ã¤ã®é ˜åŸŸï¼ˆDescriptor Table, Available Ring, Used Ringï¼‰ã®ç‰©ç†çš„ã«é€£ç¶šãªãƒ¡ãƒ¢ãƒªã‚’ç¢ºä¿ã™ã‚‹ã€‚
> - `QUEUE_NUM`ãƒ¬ã‚¸ã‚¹ã‚¿ã«ãƒ‰ãƒ©ã‚¤ãƒãŒä½¿ç”¨ã™ã‚‹ã‚­ãƒ¥ãƒ¼ã®ã‚µã‚¤ã‚ºï¼ˆãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿æ•°ï¼‰ã‚’æ›¸ãè¾¼ã‚€ã€‚
> - ç¢ºä¿ã—ãŸå„é ˜åŸŸã®ç‰©ç†ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ã€å¯¾å¿œã™ã‚‹ãƒ¬ã‚¸ã‚¹ã‚¿ã«æ›¸ãè¾¼ã‚“ã§ãƒ‡ãƒã‚¤ã‚¹ã«é€šçŸ¥ã™ã‚‹ã€‚
> - `QUEUE_ENABLE`ãƒ¬ã‚¸ã‚¹ã‚¿ã«`1`ã‚’æ›¸ãè¾¼ã¿ã€ã‚­ãƒ¥ãƒ¼ã‚’æœ‰åŠ¹åŒ–ã™ã‚‹ã€‚

> [!NOTE]
> virtioã®ã‚­ãƒ¥ãƒ¼ã‚’æ§‹æˆã™ã‚‹3ã¤ã®ãƒªãƒ³ã‚°ã«ã¤ã„ã¦ã€‚
> - Descriptor Table
>     - é€å—ä¿¡ã—ãŸã„ãƒ‡ãƒ¼ã‚¿ã®å®Ÿä½“ï¼ˆãƒ‘ã‚±ãƒƒãƒˆãªã©ï¼‰ãŒãƒ¡ãƒ¢ãƒªã®ã©ã“ã«ã‚ã‚‹ã®ã‹ã€ãã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ã‚µã‚¤ã‚ºã‚’ä¿æŒã™ã‚‹ã€‚
> - Available Ring
>     - ãƒ‰ãƒ©ã‚¤ãƒã¯å‡¦ç†ã—ã¦ã»ã—ã„ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®ç•ªå·ã‚’ã“ã®ãƒªãƒ³ã‚°ã«æ›¸ãè¾¼ã¿ã€ãƒ‡ãƒã‚¤ã‚¹ã«æ–°ã—ã„ãå‡¦ç†ã‚’è¦æ±‚ã™ã‚‹ã€‚
> - Used Ring
>     - ãƒ‡ãƒã‚¤ã‚¹ã¯å‡¦ç†ãŒçµ‚ã‚ã£ãŸãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®ç•ªå·ã‚’ã“ã®ãƒªãƒ³ã‚°ã«æ›¸ãè¾¼ã¿ã€ãƒ‰ãƒ©ã‚¤ãƒã«å‡¦ç†ãŒå®Œäº†ã—ãŸã“ã¨ã‚’é€šçŸ¥ã™ã‚‹ã€‚ 

#### ğŸŒŸ ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—å®£è¨€ã®è¿½åŠ 

è¿½åŠ ã—ãŸé–¢æ•°ã®ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—å®£è¨€ã‚’`kernel/defs.h`ã«è¿½åŠ ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/defs.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...

 // net/net.c
 void            netinit(void);
 void            netrun(void);
 int             net_softirq_handler(void);
 int             net_event_handler(void);

+// net/platform/xv6-riscv/virtio_net.c
+void            virtio_net_init(void);
+void            virtio_net_intr(void);

 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
```
</details>

#### ğŸŒŸ ãƒ‰ãƒ©ã‚¤ãƒã®åˆæœŸåŒ–é–¢æ•°ã®å‘¼ã³å‡ºã—

`kernel/main.c`ã®`main()`ã«`virtio_net_init()`ã®å‘¼ã³å‡ºã—ã‚’è¿½åŠ ã—ã¾ã™ã€‚è¿½åŠ ã™ã‚‹å ´æ‰€ã¯`netinit()`ã¨`netrun()`ã®ã‚ã„ã ã§ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/main.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...
 void
 main()
 {
...
     netinit();       // network stack
+    virtio_net_init(); // emulated network card
     netrun();        // start networking
...
 }
```
</details>

#### ğŸŒŸ Makefileã®ä¿®æ­£

ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¿½åŠ ã—ãŸã®ã§`Makefile`ã‚’ä¿®æ­£ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• Makefileï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
 OBJS = \
...
   $K/virtio_disk.o \
   $N/util.o \
   $N/net.o \
   $N/ether.o \
-  $P/std.o
+  $P/std.o \
+  $P/virtio_net.o

...
```
</details>

#### ğŸŒŸ å‹•ä½œç¢ºèª

å†ãƒ“ãƒ«ãƒ‰ã—ãŸå¾Œã€`make qemu`ã‚’å®Ÿè¡Œã—ã¦xv6ã‚’èµ·å‹•ã•ã›ã¾ã™ã€‚

```
xv6 kernel is booting

18:22:19.310 [I] net_init: initialized (kernel/net/net.c:365)
18:22:19.311 [D] virtio_net_init: device found (kernel/net/platform/xv6-riscv/virtio_net.c:349)
18:22:19.312 [I] net_device_register: registered, dev=net0, type=0x0002 (kernel/net/net.c:61)
18:22:19.313 [D] virtio_net_init: initialized, addr=52:54:00:12:34:56 (kernel/net/platform/xv6-riscv/virtio_net.c:424)
18:22:19.313 [D] net_run: open all devices... (kernel/net/net.c:311)
18:22:19.314 [I] net_device_open: dev=net0, state=up (kernel/net/net.c:79)
18:22:19.314 [D] net_run: running... (kernel/net/net.c:315)
hart 1 starting
hart 2 starting
init: starting sh
$
```

> [!NOTE]
> å‡ºåŠ›ã•ã‚Œã¦ã„ã‚‹ãƒ­ã‚°ã‹ã‚‰virtio-netãƒ‡ãƒã‚¤ã‚¹ã®åˆæœŸåŒ–ã¨ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã¸ã®ç™»éŒ²ã«æˆåŠŸã—ã¦ã„ã‚‹ã“ã¨ãŒåˆ†ã‹ã‚Šã¾ã™ã€‚


## 3.4. ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢å‰²ã‚Šè¾¼ã¿

virtio-netãƒ‡ãƒã‚¤ã‚¹ã®åˆæœŸåŒ–ã«æˆåŠŸã—ã¾ã—ãŸãŒã€ã¾ã å‰²ã‚Šè¾¼ã¿ã‚’æ•æ‰ã™ã‚‹ãŸã‚ã®è¨­å®šãŒå‡ºæ¥ã¦ã„ãªã„ãŸã‚ã€ãƒ‡ãƒã‚¤ã‚¹ã«ãƒ‘ã‚±ãƒƒãƒˆãŒå±Šã„ã¦ã‚‚ä½•ã‚‚èµ·ãã¾ã›ã‚“ã€‚ã“ã“ã§ã¯ãƒ‡ãƒã‚¤ã‚¹ã‹ã‚‰ã®é€šçŸ¥ã§ã‚ã‚‹ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢å‰²ã‚Šè¾¼ã¿ã‚’æ•æ‰ã—ã¦ãƒ‰ãƒ©ã‚¤ãƒã®å‰²ã‚Šè¾¼ã¿ãƒãƒ³ãƒ‰ãƒ©ã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«ã—ã¾ã™ã€‚

> [!NOTE]
> RISC-Vã§ã¯ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢å‰²ã‚Šè¾¼ã¿ã«ã€ŒPLICï¼ˆPlatform-Level Interrupt Controllerï¼‰ã€ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ã“ã‚Œã¯x86ã§ã„ã†ã¨ã“ã‚ã®ã€ŒI/O APICã€ã¨åŒã˜ã‚ˆã†ãªã‚‚ã®ã§ã€æ§˜ã€…ãªãƒ‡ãƒã‚¤ã‚¹ã‹ã‚‰ã®å‰²ã‚Šè¾¼ã¿ã‚’å—ã‘ä»˜ã‘ã¾ã™ã€‚

#### ğŸŒŸ PLICã®è¨­å®š

PLICé–¢é€£ã®ã‚³ãƒ¼ãƒ‰ã¯`kernel/plic.c`ã«ã‚ã‚Šã¾ã™ã€‚æ—¢ã«uartã¨virtio-diskã®å‰²ã‚Šè¾¼ã¿ã‚’æ•æ‰ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã®ã‚³ãƒ¼ãƒ‰ãŒã‚ã‚‹ã®ã§ã€ã“ã‚Œã‚’å‚è€ƒã«ã—ã¦virtio-netã®å‰²ã‚Šè¾¼ã¿ã‚’æ•æ‰ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/plic.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
 #include "types.h"
 #include "param.h"
 #include "memlayout.h"
 #include "riscv.h"
 #include "defs.h"

 //
 // the riscv Platform Level Interrupt Controller (PLIC).
 //

 void
 plicinit(void)
 {
   // set desired IRQ priorities non-zero (otherwise disabled).
   *(uint32*)(PLIC + UART0_IRQ*4) = 1;
   *(uint32*)(PLIC + VIRTIO0_IRQ*4) = 1;
+  *(uint32*)(PLIC + VIRTIO1_IRQ*4) = 1;
 }

 void
 plicinithart(void)
 {
   int hart = cpuid();
  
   // set enable bits for this hart's S-mode
-  // for the uart and virtio disk.
+  // for the uart and virtio disk and virtio network
-  *(uint32*)PLIC_SENABLE(hart) = (1 << UART0_IRQ) | (1 << VIRTIO0_IRQ);
+  *(uint32*)PLIC_SENABLE(hart) = (1 << UART0_IRQ) | (1 << VIRTIO0_IRQ) | (1 << VIRTIO1_IRQ);

   // set this hart's S-mode priority threshold to 0.
   *(uint32*)PLIC_SPRIORITY(hart) = 0;
 }

...
```
</details>

> [!NOTE]
> `plicinit()`ã§ã¯å‰²ã‚Šè¾¼ã¿ã®å„ªå…ˆåº¦ã‚’è¨­å®šã—ã€`plicinithart()`ã§ã¯æœ‰åŠ¹ã«ã™ã‚‹å‰²ã‚Šè¾¼ã¿ã‚’è¨­å®šã—ã¾ã™ã€‚

#### ğŸŒŸ å‰²ã‚Šè¾¼ã¿ã®æ•æ‰

å‰²ã‚Šè¾¼ã¿é–¢é€£ã®ã‚³ãƒ¼ãƒ‰ã¯`kernel/trap.c`ã«ã‚ã‚Šã¾ã™ã€‚ã“ã¡ã‚‰ã‚‚`devintr()`ã®ä¸­ã«uartã¨virtio-diskã®å‰²ã‚Šè¾¼ã¿ã‚’æ•æ‰ã™ã‚‹ã‚³ãƒ¼ãƒ‰ãŒã‚ã‚‹ã®ã§ã€ã“ã‚Œã‚’å‚è€ƒã«ã—ã¦virtio-netã®å‰²ã‚Šè¾¼ã¿ã‚’æ•æ‰ã—ãŸã‚‰`virtio_net_intr()`ã‚’å‘¼ã³å‡ºã™å‡¦ç†ã‚’è¿½åŠ ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/trap.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...

 // check if it's an external interrupt or software interrupt,
 // and handle it.
 // returns 2 if timer interrupt,
 // 1 if other device,
 // 0 if not recognized.
 int
 devintr()
 {
   uint64 scause = r_scause();

   if(scause == 0x8000000000000009L){
     // this is a supervisor external interrupt, via PLIC.

     // irq indicates which device interrupted.
     int irq = plic_claim();

     if(irq == UART0_IRQ){
       uartintr();
     } else if(irq == VIRTIO0_IRQ){
       virtio_disk_intr();
+    } else if(irq == VIRTIO1_IRQ){
+      virtio_net_intr();
     } else if(irq){
       printf("unexpected interrupt irq=%d\n", irq);
     }

     // the PLIC allows each device to raise at most one
     // interrupt at a time; tell the PLIC the device is
     // now allowed to interrupt again.
     if(irq)
       plic_complete(irq);

     return 1;
   } else if(scause == 0x8000000000000005L){
     // timer interrupt.
     clockintr();
     return 2;
   } else {
     return 0;
   }
 }
```
</details>

#### ğŸŒŸ å‹•ä½œç¢ºèª

å†ãƒ“ãƒ«ãƒ‰ã—ãŸå¾Œã€`make qemu`ã‚’å®Ÿè¡Œã—ã¦xv6ã‚’èµ·å‹•ã—ã¾ã™ã€‚

```
xv6 kernel is booting

18:28:55.309 [I] net_init: initialized (kernel/net/net.c:365)
18:28:55.310 [D] virtio_net_init: device found (kernel/net/platform/xv6-riscv/virtio_net.c:349)
18:28:55.311 [I] net_device_register: registered, dev=net0, type=0x0002 (kernel/net/net.c:61)
18:28:55.312 [D] virtio_net_init: initialized, addr=52:54:00:12:34:56 (kernel/net/platform/xv6-riscv/virtio_net.c:424)
18:28:55.312 [D] net_run: open all devices... (kernel/net/net.c:311)
18:28:55.313 [I] net_device_open: dev=net0, state=up (kernel/net/net.c:79)
18:28:55.313 [D] net_run: running... (kernel/net/net.c:315)
hart 1 starting
hart 2 starting
init: starting sh
$ 
...
```

é–‹ç™ºç’°å¢ƒã§åˆ¥ã®ã‚·ã‚§ãƒ«ã‚’é–‹ãã€`192.0.2.2`ã«å¯¾ã—ã¦`ping`ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚

```
$ ping -c 3 192.0.2.2
```

å‰²ã‚Šè¾¼ã¿ã®è¨­å®šãŒæ­£ã—ãè¡Œãˆã¦ã„ã‚Œã°virtio-netãƒ‡ãƒã‚¤ã‚¹ã‹ã‚‰ã®å‰²ã‚Šè¾¼ã¿ã‚’æ•æ‰ã—ã¦ãƒ‘ã‚±ãƒƒãƒˆã‚’å—ä¿¡ã§ãã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹ã¯ãšã§ã™ã€‚

```
18:28:55.472 [D] ether_input_helper: dev=net0, type=0x0806, len=42 (kernel/net/ether.c:123)
        src: 16:2a:af:19:b5:91
        dst: ff:ff:ff:ff:ff:ff
       type: 0x0806
+------+-------------------------------------------------+------------------+
| 0000 | ff ff ff ff ff ff 16 2a af 19 b5 91 08 06 00 01 | .......*........ |
| 0010 | 08 00 06 04 00 01 16 2a af 19 b5 91 c0 00 02 01 | .......*........ |
| 0020 | 00 00 00 00 00 00 c0 00 02 02                   | ..........       |
+------+-------------------------------------------------+------------------+
...
```

## 3.5. ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢å‰²ã‚Šè¾¼ã¿

Supervisor Software Interrupt ã‚’åˆ©ç”¨ã—ã¦ã€è‡ªä½œãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ãŒå¿…è¦ã¨ã™ã‚‹ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢å‰²ã‚Šè¾¼ã¿æ©Ÿèƒ½ã‚’ä½œã‚Šã¾ã™ã€‚

#### ğŸŒŸ Supervisor Software Interrupt ã‚’æ‰±ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹

ã‚¹ãƒ¼ãƒ‘ãƒã‚¤ã‚¶ãƒ¬ãƒ™ãƒ«ã§å‡¦ç†å¾…ã¡ã®å‰²ã‚Šè¾¼ã¿ãŒä½•ã‹ã‚’ç¤ºã—ã¾ã™`sip`ãƒ¬ã‚¸ã‚¹ã‚¿ã«ãŠã„ã¦ Supervisor Software Interrupt ãŒä¿ç•™ä¸­ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™ãƒ“ãƒƒãƒˆã‚’`SIP_SSIP`ã¨ã—ã¦å®šç¾©ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/riscv.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...

 // Supervisor Interrupt Pending
+#define SIP_SSIP (1L << 1)
 static inline uint64
 r_sip()
 {
   uint64 x;
   asm volatile("csrr %0, sip" : "=r" (x) );
   return x;
 }

 static inline void 
 w_sip(uint64 x)
 {
   asm volatile("csrw sip, %0" : : "r" (x));
 }

...
```
</details>

> [!NOTE]
> `SIP_SSIP`ã®å€¤ãŒ`(1L << 1)`ã§ã‚ã‚‹ã¨ã„ã†ã“ã¨ã¯RISC-Vã®ä»•æ§˜ã§å®šã‚ã‚‰ã‚Œã¦ã¾ã™ã€‚

#### ğŸŒŸ å‰²ã‚Šè¾¼ã¿ç™ºç”Ÿã®ç†ç”±

Supervisor Software Interruptã ã‘ã§ã¯ç™ºç”Ÿã®æœ‰ç„¡ã—ã‹ã‚ã‹ã‚‰ãšã€ç™ºç”Ÿç†ç”±ï¼ˆç¨®åˆ¥ï¼‰ã‚’åˆ¤åˆ¥ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚è‡ªä½œãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã§ã¯ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢å‰²ã‚Šè¾¼ã¿ã‚’ã€å„ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®å—ä¿¡ã‚­ãƒ¥ãƒ¼ã¸ã®ãƒ‘ã‚±ãƒƒãƒˆã‚’æ ¼ç´ã—ãŸã“ã¨ã‚’é€šçŸ¥ã™ã‚‹ç›®çš„ã¨ã‚¤ãƒ™ãƒ³ãƒˆã‚’é€šçŸ¥ã™ã‚‹ç›®çš„ã§ä½¿ã„åˆ†ã‘ã¦ã„ã‚‹ãŸã‚ã€ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢å‰²ã‚Šè¾¼ã¿ã®ç™ºç”Ÿç†ç”±ã‚’è‡ªå‰ã§ç®¡ç†ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãã®ãŸã‚ã«ã€ç™ºç”Ÿç†ç”±ï¼ˆç¨®åˆ¥ï¼‰ã‚’å®šç¾©ã—ã¦ãŠãã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/softirq.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```c
#define SOFT_IRQ_NET_RX    (1L << 1)
#define SOFT_IRQ_NET_EVENT (1L << 2)
```
</details>

> [!IMPORTANT]
> ç¨®åˆ¥ã”ã¨ã«ã©ã“ã‹ã®ãƒ“ãƒƒãƒˆã‚’ç«‹ã¦ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ä»–ã®ç¨®åˆ¥ã¨ãƒ“ãƒƒãƒˆãŒè¢«ã‚‰ãªã„ã‚ˆã†ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚

#### ğŸŒŸ Supervisor Software Interruptã®æ•æ‰

Supervisor Software Interruptã‚’æ•æ‰ã—ã¦ã€è‡ªå‰ã§ç®¡ç†ã—ã¦ã„ã‚‹ç¨®åˆ¥ã«å¿œã˜ãŸå‰²ã‚Šè¾¼ã¿ãƒãƒ³ãƒ‰ãƒ©ã‚’å‘¼ã³å‡ºã™å‡¦ç†ã‚’è¿½åŠ ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/trap.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
 #include "types.h"
 #include "param.h"
 #include "memlayout.h"
 #include "riscv.h"
 #include "spinlock.h"
 #include "proc.h"
 #include "defs.h"
+#include "softirq.h"

 struct spinlock tickslock;
 uint ticks;
+
+struct spinlock pendinglock;
+uint64 pending;

...

 void
 trapinit(void)
 {
   initlock(&tickslock, "time");
+  initlock(&pendinglock, "softirq");
 }

...

+void
+softintr()
+{
+  acquire(&pendinglock);
+  uint64 irqs = pending;
+  pending = 0;
+  release(&pendinglock);
+
+  if(irqs & SOFT_IRQ_NET_RX) {
+    net_softirq_handler();
+  }
+  if(irqs & SOFT_IRQ_NET_EVENT) {
+    net_event_handler();
+  }
+
+  w_sip(r_sip() & ~SIP_SSIP);
+}

 // check if it's an external interrupt or software interrupt,
 // and handle it.
 // returns 2 if timer interrupt,
 // 1 if other device,
 // 0 if not recognized.
 int
 devintr()
 {
   uint64 scause = r_scause();

   if(scause == 0x8000000000000009L){
...
+  } else if(scause == 0x8000000000000001L){
+    // software interrupt.
+    softintr();
+    return 1;
   } else if(scause == 0x8000000000000005L){
     // timer interrupt.
     clockintr();
     return 2;
   } else {
     return 0;
   }
 }
```
</details>

> [!NOTE]
> `scause`ãŒ`0x8000000000000001L`ãªã‚‰Supervisor Software InterruptãŒç™ºç”Ÿã—ã¦ã„ã¾ã™ã€‚
> - æœ€ä¸Šä½ãƒ“ãƒƒãƒˆãŒ`1` ... å‰²ã‚Šè¾¼ã¿ãŒç™ºç”Ÿã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚`0`ã ã£ãŸå ´åˆã¯ä¾‹å¤–ãŒç™ºç”Ÿã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚
> - `1L` ... Supervisor Software Interrupt ãŒä¿ç•™çŠ¶æ…‹ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚

> [!NOTE]
> `pending`å¤‰æ•°ã«ã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ã‚‹ãƒ“ãƒƒãƒˆã§Supervisor Software Interruptã®ç™ºç”Ÿç†ç”±ã‚’åˆ¤åˆ¥ã—ã¾ã™ã€‚

> [!IMPORTANT]
> Supervisor Software Interruptã‚’å‡¦ç†ã—çµ‚ãˆãŸã‚‰ã€å¿…ãš`w_sip(r_sip() & ~SIP_SSIP)`ã§å‰²ã‚Šè¾¼ã¿å‡¦ç†ã®å®Œäº†ã‚’ä¼ãˆã¾ã™ã€‚

æ–°ãŸã«è¿½åŠ ã—ãŸã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°`pending`ã¨`pendinglock`ã‚’ã€ä»–ã®ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚‚ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ã—ã¦ãŠãã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/defs.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...

 // trap.c
 extern uint     ticks;
+extern uint64   pending;
 void            trapinit(void);
 void            trapinithart(void);
 extern struct spinlock tickslock;
+extern struct spinlock pendinglock;
 void            usertrapret(void);

...
```
</details>

#### ğŸŒŸ ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢å‰²ã‚Šè¾¼ã¿ã®ç™ºç”Ÿ

ã“ã‚Œã¾ã§æš«å®šå¯¾å‡¦ã¨ã—ã¦ç©ºã«ã—ã¦ã„ãŸã€ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢å‰²ã‚Šè¾¼ã¿ã‚’ç™ºç”Ÿã•ã›ã‚‹é–¢æ•°`intr_raise_irq()`ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/net/platform/xv6-riscv/platform.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...

 /*
  * Interrupt
  */
 
+#include "softirq.h"
+
-#define INTR_IRQ_SOFTIRQ 0
-#define INTR_IRQ_EVENT 0
+#define INTR_IRQ_SOFTIRQ SOFT_IRQ_NET_RX
+#define INTR_IRQ_EVENT SOFT_IRQ_NET_EVENT
 
 static inline int
 intr_raise_irq(unsigned int irq)
 {
+    acquire(&pendinglock);
+    pending |= irq;
+    release(&pendinglock);
+    w_sip(r_sip() | SIP_SSIP);
     return 0;
 }

...
```
</details>

> [!WARNING]
> Supervisor Software Interruptã®ç™ºç”Ÿç†ç”±ã‚’`pending`å¤‰æ•°ã«è¨­å®šã™ã‚‹éš›ã«ã¯ä¸Šæ›¸ãã—ã¦ã—ã¾ã‚ãªã„ã‚ˆã†ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚

> [!NOTE]
> `w_sip(r_sip() | SIP_SSIP)`ã§ã€ç¾åœ¨ã®CPUã‚³ã‚¢å¯¾ã—ã¦ã«Supervisor Software Interruptã‚’ä¿ç•™çŠ¶æ…‹ã«è¨­å®šã—ã¾ã™ã€‚

#### ğŸŒŸ ãƒ“ãƒ«ãƒ‰ã®ç¢ºèª

ã“ã“ã§å®Ÿè£…ã—ãŸæ©Ÿèƒ½ãŒä½¿ã‚ã‚Œã‚‹ã®ã¯IPãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¿½åŠ ã—ãŸå¾Œã§ã™ã€‚ã“ã“ã§ã¯ãƒ“ãƒ«ãƒ‰ãŒé€šã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦æ¬¡ã¸é€²ã¿ã¾ã™ã€‚

```
$ make clean
$ make
```

<hr/>

[æ¬¡ã¸](04.md)
