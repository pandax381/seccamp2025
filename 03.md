# 3. 自作プロトコルスタックの移植（前編）

ここから自作プロトコルスタックのコードをxv6に移植していきます。作業量が多いため前編と後編にわけており、前編ではNICから読み取ったパケットをプロトコルスタックの受信キューに格納してソフトウェア割り込みを発生させるところまで進めます。

> [!IMPORTANT]
> 自作プロトコルスタックの全てのモジュールに共通して、下記の修正を加えてあります。
>
> + システムヘッダのインクルード（`#include <>`）を削除
>   + `-nostdinc`への対応
>   + 替わりに`platform.h`を冒頭でインクルード
> 
> + ローカル変数の大きなバッファを動的メモリ確保に変更
>   + 主に送信パケット構築用のバッファ
>   + スタックが溢れてクラッシュしてしまう問題への対処（RISC-V版では問題ないかもしれないがx86版の対策を踏襲）
>   + 本来はmbufのような仕組みを採用すべきだが複雑になってしまうので見送り

プロトコルスタック本体のコードは移植しやすい作りにしていることもあり、本体と分離してあるプラットフォーム固有の処理を除けば他に目立った変更は発生しません。

## 3.1. メインモジュール

自作プロトコルスタックのメインモジュールを移植します。

#### 🌟 暫定コードの削除

ここまで暫定的に作成していた`kernel/net/net.c`を削除します。

```
$ rm kernel/net/net.c
```

#### 🌟 メインモジュールのコードの追加

メインモジュールのコードを追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/net/net.h（クリックしてコードを表示）</span></summary>

```c
#ifndef NET_H
#define NET_H

#include "platform.h"

#ifndef IFNAMSIZ
#define IFNAMSIZ 16
#endif

#define NET_DEVICE_TYPE_DUMMY     0x0000
#define NET_DEVICE_TYPE_LOOPBACK  0x0001
#define NET_DEVICE_TYPE_ETHERNET  0x0002

#define NET_DEVICE_FLAG_UP        0x0001
#define NET_DEVICE_FLAG_LOOPBACK  0x0010
#define NET_DEVICE_FLAG_BROADCAST 0x0020
#define NET_DEVICE_FLAG_P2P       0x0040
#define NET_DEVICE_FLAG_NEED_ARP  0x0100

#define NET_DEVICE_ADDR_LEN 16

#define NET_DEVICE_IS_UP(x) ((x)->flags & NET_DEVICE_FLAG_UP)
#define NET_DEVICE_STATE(x) (NET_DEVICE_IS_UP(x) ? "up" : "down")

/* NOTE: use same value as the Ethernet types */
#define NET_PROTOCOL_TYPE_IP   0x0800
#define NET_PROTOCOL_TYPE_ARP  0x0806
#define NTT_PROTOCOL_TYPE_IPV6 0x86dd

#define NET_IFACE_FAMILY_IP    1
#define NET_IFACE_FAMILY_IPV6  2

#define NET_IFACE(x) ((struct net_iface *)(x))

struct net_device {
    struct net_device *next;
    struct net_iface *ifaces; /* NOTE: if you want to add/delete the entries after net_run(), you need to protect ifaces with a mutex. */
    unsigned int index;
    char name[IFNAMSIZ];
    uint16_t type;
    uint16_t mtu;
    uint16_t flags;
    uint16_t hlen; /* header length */
    uint16_t alen; /* address length */
    uint8_t addr[NET_DEVICE_ADDR_LEN];
    union {
        uint8_t peer[NET_DEVICE_ADDR_LEN];
        uint8_t broadcast[NET_DEVICE_ADDR_LEN];
    };
    struct net_device_ops *ops;
    void *priv;
};

struct net_device_ops {
    int (*open)(struct net_device *dev);
    int (*close)(struct net_device *dev);
    int (*transmit)(struct net_device *dev, uint16_t type, const uint8_t *data, size_t len, const void *dst);
};

struct net_iface {
    struct net_iface *next;
    struct net_device *dev; /* back pointer to parent */
    int family;
    /* depends on implementation of protocols. */
};

extern struct net_device *
net_device_alloc(void);
extern int
net_device_register(struct net_device *dev);
extern int
net_device_add_iface(struct net_device *dev, struct net_iface *iface);
extern struct net_iface *
net_device_get_iface(struct net_device *dev, int family);
extern int
net_device_output(struct net_device *dev, uint16_t type, const uint8_t *data, size_t len, const void *dst);

extern int
net_protocol_register(uint16_t type, void (*handler)(const uint8_t *data, size_t len, struct net_device *dev));

extern int
net_timer_register(struct timeval interval, void (*handler)(void));
extern int
net_timer_handler(void);

extern int
net_input_handler(uint16_t type, const uint8_t *data, size_t len, struct net_device *dev);
extern int
net_softirq_handler(void);

extern int
net_event_subscribe(void (*handler)(void *arg), void *arg);
extern int
net_event_handler(void);
extern void
net_raise_event(void);

extern int
net_run(void);
extern void
net_shutdown(void);
extern int
net_init(void);

#endif
```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/net/net.c（クリックしてコードを表示）</span></summary>

```c
#include "platform.h"

#include "util.h"
#include "net.h"

struct net_protocol {
    struct net_protocol *next;
    uint16_t type;
    struct queue_head queue; /* input queue */
    void (*handler)(const uint8_t *data, size_t len, struct net_device *dev);
};

struct net_protocol_queue_entry {
    struct net_device *dev;
    size_t len;
    uint8_t data[];
};

struct net_timer {
    struct net_timer *next;
    struct timeval interval;
    struct timeval last;
    void (*handler)(void);
};

struct net_event {
    struct net_event *next;
    void (*handler)(void *arg);
    void *arg;
};

/* NOTE: if you want to add/delete the entries after net_run(), you need to protect these lists with a mutex. */
static struct net_device *devices;
static struct net_protocol *protocols;
static struct net_timer *timers;
static struct net_event *events;

struct net_device *
net_device_alloc(void)
{
    struct net_device *dev;

    dev = memory_alloc(sizeof(*dev));
    if (!dev) {
        errorf("memory_alloc() failure");
        return NULL;
    }
    return dev;
}

/* NOTE: must not be call after net_run() */
int
net_device_register(struct net_device *dev)
{
    static unsigned int index = 0;

    dev->index = index++;
    snprintf(dev->name, sizeof(dev->name), "net%d", dev->index);
    dev->next = devices;
    devices = dev;
    infof("registered, dev=%s, type=0x%04x", dev->name, dev->type);
    return 0;
}

static int
net_device_open(struct net_device *dev)
{
    if (NET_DEVICE_IS_UP(dev)) {
        errorf("already opened, dev=%s", dev->name);
        return -1;
    }
    if (dev->ops->open) {
        if (dev->ops->open(dev) == -1) {
            errorf("failure, dev=%s", dev->name);
            return -1;
        }
    }
    dev->flags |= NET_DEVICE_FLAG_UP;
    infof("dev=%s, state=%s", dev->name, NET_DEVICE_STATE(dev));
    return 0;
}

static int
net_device_close(struct net_device *dev)
{
    if (!NET_DEVICE_IS_UP(dev)) {
        errorf("not opened, dev=%s", dev->name);
        return -1;
    }
    if (dev->ops->close) {
        if (dev->ops->close(dev) == -1) {
            errorf("failure, dev=%s", dev->name);
            return -1;
        }
    }
    dev->flags &= ~NET_DEVICE_FLAG_UP;
    infof("dev=%s, state=%s", dev->name, NET_DEVICE_STATE(dev));
    return 0;
}

/* NOTE: must not be call after net_run() */
int
net_device_add_iface(struct net_device *dev, struct net_iface *iface)
{
    struct net_iface *entry;

    for (entry = dev->ifaces; entry; entry = entry->next) {
        if (entry->family == iface->family) {
            /* NOTE: For simplicity, only one iface can be added per family. */
            errorf("already exists, dev=%s, family=%d", dev->name, entry->family);
            return -1;
        }
    }
    iface->next = dev->ifaces;
    iface->dev = dev;
    dev->ifaces = iface;
    return 0;
}

struct net_iface *
net_device_get_iface(struct net_device *dev, int family)
{
    struct net_iface *entry;

    for (entry = dev->ifaces; entry; entry = entry->next) {
        if (entry->family == family) {
            break;
        }
    }
    return entry;
}

int
net_device_output(struct net_device *dev, uint16_t type, const uint8_t *data, size_t len, const void *dst)
{
    if (!NET_DEVICE_IS_UP(dev)) {
        errorf("not opened, dev=%s", dev->name);
        return -1;
    }
    if (len > dev->mtu) {
        errorf("too long, dev=%s, mtu=%u, len=%zu", dev->name, dev->mtu, len);
        return -1;
    }
    debugf("dev=%s, type=0x%04x, len=%zu", dev->name, type, len);
    debugdump(data, len);
    if (dev->ops->transmit(dev, type, data, len, dst) == -1) {
        errorf("device transmit failure, dev=%s, len=%zu", dev->name, len);
        return -1;
    }
    return 0;
}

/* NOTE: must not be call after net_run() */
int
net_protocol_register(uint16_t type, void (*handler)(const uint8_t *data, size_t len, struct net_device *dev))
{
    struct net_protocol *proto;

    for (proto = protocols; proto; proto = proto->next) {
        if (type == proto->type) {
            errorf("already registered, type=0x%04x", type);
            return -1;
        }
    }
    proto = memory_alloc(sizeof(*proto));
    if (!proto) {
        errorf("memory_alloc() failure");
        return -1;
    }
    proto->type = type;
    proto->handler = handler;
    proto->next = protocols;
    protocols = proto;
    infof("registered, type=0x%04x", type);
    return 0;
}

/* NOTE: must not be call after net_run() */
int
net_timer_register(struct timeval interval, void (*handler)(void))
{
    struct net_timer *timer;

    timer = memory_alloc(sizeof(*timer));
    if (!timer) {
        errorf("memory_alloc() failure");
        return -1;
    }
    timer->interval = interval;
    gettimeofday(&timer->last, NULL);
    timer->handler = handler;
    timer->next = timers;
    timers = timer;
    infof("registered: interval={%d, %d}", interval.tv_sec, interval.tv_usec);
    return 0;
}

int
net_timer_handler(void)
{
    struct net_timer *timer;
    struct timeval now, diff;

    for (timer = timers; timer; timer = timer->next) {
        gettimeofday(&now, NULL);
        timersub(&now, &timer->last, &diff);
        if (timercmp(&timer->interval, &diff, <) != 0) { /* true (!0) or false (0) */
            timer->handler();
            timer->last = now;
        }
    }
    return 0;
}

int
net_input_handler(uint16_t type, const uint8_t *data, size_t len, struct net_device *dev)
{
    struct net_protocol *proto;
    struct net_protocol_queue_entry *entry;

    for (proto = protocols; proto; proto = proto->next) {
        if (proto->type == type) {
            entry = memory_alloc(sizeof(*entry) + len);
            if (!entry) {
                errorf("memory_alloc() failure");
                return -1;
            }
            entry->dev = dev;
            entry->len = len;
            memcpy(entry->data, data, len);
            if (!queue_push(&proto->queue, entry)) {
                errorf("queue_push() failure");
                memory_free(entry);
                return -1;
            }
            debugf("queue pushed (num:%u), dev=%s, type=0x%04x, len=%zu", proto->queue.num, dev->name, type, len);
            debugdump(data, len);
            intr_raise_irq(INTR_IRQ_SOFTIRQ);
            return 0;
        }
    }
    /* unsupported protocol */
    return 0;
}

int
net_softirq_handler(void)
{
    struct net_protocol *proto;
    struct net_protocol_queue_entry *entry;

    for (proto = protocols; proto; proto = proto->next) {
        while (1) {
            entry = queue_pop(&proto->queue);
            if (!entry) {
                break;
            }
            debugf("queue popped (num:%u), dev=%s, type=0x%04x, len=%zu", proto->queue.num, entry->dev->name, proto->type, entry->len);
            debugdump(entry->data, entry->len);
            proto->handler(entry->data, entry->len, entry->dev);
            memory_free(entry);
        }
    }
    return 0;
}

/* NOTE: must not be call after net_run() */
int
net_event_subscribe(void (*handler)(void *arg), void *arg)
{
    struct net_event *event;

    event = memory_alloc(sizeof(*event));
    if (!event) {
        errorf("memory_alloc() failure");
        return -1;
    }
    event->handler = handler;
    event->arg = arg;
    event->next = events;
    events = event;
    return 0;
}

int
net_event_handler(void)
{
    struct net_event *event;

    for (event = events; event; event = event->next) {
        event->handler(event->arg);
    }
    return 0;
}

void
net_raise_event()
{
    intr_raise_irq(INTR_IRQ_EVENT);
}

int
net_run(void)
{
    struct net_device *dev;

    if (intr_run() == -1) {
        errorf("intr_run() failure");
        return -1;
    }
    debugf("open all devices...");
    for (dev = devices; dev; dev = dev->next) {
        net_device_open(dev);
    }
    debugf("running...");
    return 0;
}

void
net_shutdown(void)
{
    struct net_device *dev;

    debugf("close all devices...");
    for (dev = devices; dev; dev = dev->next) {
        net_device_close(dev);
    }
    intr_shutdown();
    debugf("shutting down");
}

//#include "ip.h"
//#include "arp.h"
//#include "icmp.h"
//#include "udp.h"
//#include "tcp.h"

int
net_init(void)
{
    if (intr_init() == -1) {
        errorf("intr_init() failure");
        return -1;
    }
//    if (ip_init() == -1) {
//        errorf("ip_init() failure");
//        return -1;
//    }
//    if (arp_init() == -1) {
//        errorf("arp_init() failure");
//        return -1;
//    }
//    if (icmp_init() == -1) {
//        errorf("icmp_init() failure");
//        return -1;
//    }
//    if (udp_init() == -1) {
//        errorf("udp_init() failure");
//        return -1;
//    }
//    if (tcp_init() == -1) {
//        errorf("tcp_init() failure");
//        return -1;
//    }
    infof("initialized");
    return 0;
}

void
netinit(void)
{
    if (net_init() == -1) {
        panic("net_init() failure");
    }
}

void
netrun(void)
{
    if (net_run() == -1) {
        panic("net_run() failure");
    }
}
```
</details>

> [!NOTE]
> 1モジュールづつ移植していく都合上、`net_init()`で行っていた各モジュールの初期化処理を一旦コメントアウトしています。また、xv6から呼び出すための`netinit()`と`netrun()`を追加していますが、どちらも`net_init()`と`net_run()`に対するラッパー関数です。

#### 🌟 プラットフォーム依存の割り込み関連コード（暫定措置）

プラットフォーム依存の割り込み処理についてはもう少し後で追加するため、ここではとりあえずコンパイルを通すための暫定コードを追加しておきます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/net/platform/xv6-riscv/plartform.h（クリックしてコードを表示）</span></summary>

```diff
...

 /*
  * Interrupt
  */

+#define INTR_IRQ_SOFTIRQ 0
+#define INTR_IRQ_EVENT 0
+
+static inline int
+intr_raise_irq(unsigned int irq)
+{
+    return 0;
+}
+
+static inline int
+intr_init(void)
+{
+    return 0;
+}
+
+static inline int
+intr_run(void)
+{
+    return 0;
+}
+
+static inline void
+intr_shutdown(void)
+{
+    return;
+}

...
```
</details>

#### 🌟 プロトタイプ宣言の追加

追加した関数のプロトタイプ宣言を`kernel/defs.h`に追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/defs.h（クリックしてコードを表示）</span></summary>

```diff
...

 // net/net.c
 void            netinit(void);
+void            netrun(void);
+int             net_softirq_handler(void);
+int             net_event_handler(void);

...
```
</details>

#### 🌟 プロトコルスタックの起動

`kernel/main.c`の`main()`の中で、`netinit()`に続けて`netrun()`を呼び出すようにします。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/main.c（クリックしてコードを表示）</span></summary>

```diff
...

 // start() jumps here in supervisor mode on all CPUs.
 void
 main()
 {
   if(cpuid() == 0){
...
     virtio_disk_init(); // emulated hard disk
     netinit();       // network stack
+    netrun();        // start networking
     userinit();      // first user process
     __sync_synchronize();
     started = 1;
...
  }

  scheduler();        
}

...
```
</details>

#### 🌟 動作確認

再ビルドした後、`make qemu`を実行してxv6を起動させます。

```
xv6 kernel is booting

17:38:44.308 [I] net_init: initialized (kernel/net/net.c:365)
17:38:44.309 [D] net_run: open all devices... (kernel/net/net.c:311)
17:38:44.309 [D] net_run: running... (kernel/net/net.c:315)
hart 1 starting
hart 2 starting
init: starting sh
$
```

> [!NOTE]
> プロトコルスタックの初期化に続けて起動処理が実行されていることが確認できます。

## 3.2. Ethernetモジュール

自作プロトコルスタックのEthernetモジュールを移植します。

#### 🌟 Ethernetモジュールのコードの追加

Ethernetモジュールのコードを追加します。

> [!IMPORTANT]
> 送受信ともにローカル変数で持っていた大きなバッファを動的メモリ確保に変更してあります。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/net/ether.h（クリックしてコードを表示）</span></summary>

```c
#ifndef ETHER_H
#define ETHER_H

#include "platform.h"

#include "net.h"

#define ETHER_ADDR_LEN 6
#define ETHER_ADDR_STR_LEN 18 /* "xx:xx:xx:xx:xx:xx\0" */

#define ETHER_HDR_SIZE 14
#define ETHER_FRAME_SIZE_MIN   60 /* without FCS */
#define ETHER_FRAME_SIZE_MAX 1514 /* without FCS */
#define ETHER_PAYLOAD_SIZE_MIN (ETHER_FRAME_SIZE_MIN - ETHER_HDR_SIZE)
#define ETHER_PAYLOAD_SIZE_MAX (ETHER_FRAME_SIZE_MAX - ETHER_HDR_SIZE)

/* see https://www.iana.org/assignments/ieee-802-numbers/ieee-802-numbers.txt */
#define ETHER_TYPE_IP   0x0800
#define ETHER_TYPE_ARP  0x0806
#define ETHER_TYPE_IPV6 0x86dd

extern const uint8_t ETHER_ADDR_ANY[ETHER_ADDR_LEN];
extern const uint8_t ETHER_ADDR_BROADCAST[ETHER_ADDR_LEN];

extern int
ether_addr_pton(const char *p, uint8_t *n);
extern char *
ether_addr_ntop(const uint8_t *n, char *p, size_t size);

typedef ssize_t (*ether_transmit_func_t)(struct net_device *dev, const uint8_t *data, size_t len);
typedef ssize_t (*ether_input_func_t)(struct net_device *dev, uint8_t *buf, size_t size);

extern int
ether_transmit_helper(struct net_device *dev, uint16_t type, const uint8_t *payload, size_t plen, const void *dst, ether_transmit_func_t callback);
extern int
ether_input_helper(struct net_device *dev, ether_input_func_t callback);
extern void
ether_setup_helper(struct net_device *dev);

#endif
```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/net/ether.c（クリックしてコードを表示）</span></summary>

```c
#include "platform.h"

#include "util.h"
#include "net.h"
#include "ether.h"

struct ether_hdr {
    uint8_t dst[ETHER_ADDR_LEN];
    uint8_t src[ETHER_ADDR_LEN];
    uint16_t type;
};

const uint8_t ETHER_ADDR_ANY[ETHER_ADDR_LEN] = {"\x00\x00\x00\x00\x00\x00"};
const uint8_t ETHER_ADDR_BROADCAST[ETHER_ADDR_LEN] = {"\xff\xff\xff\xff\xff\xff"};

int
ether_addr_pton(const char *p, uint8_t *n)
{
    int index;
    char *ep;
    long val;

    if (!p || !n) {
        return -1;
    }
    for (index = 0; index < ETHER_ADDR_LEN; index++) {
        val = strtol(p, &ep, 16);
        if (ep == p || val < 0 || val > 0xff || (index < ETHER_ADDR_LEN - 1 && *ep != ':')) {
            break;
        }
        n[index] = (uint8_t)val;
        p = ep + 1;
    }
    if (index != ETHER_ADDR_LEN || *ep != '\0') {
        return -1;
    }
    return 0;
}

char *
ether_addr_ntop(const uint8_t *n, char *p, size_t size)
{
    if (!n || !p) {
        return NULL;
    }
    snprintf(p, size, "%02x:%02x:%02x:%02x:%02x:%02x", n[0], n[1], n[2], n[3], n[4], n[5]);
    return p;
}

static void
ether_dump(const uint8_t *frame, size_t flen)
{
    struct ether_hdr *hdr;
    char addr[ETHER_ADDR_STR_LEN];

    hdr = (struct ether_hdr *)frame;
    flockfile(stderr);
    fprintf(stderr, "        src: %s\n", ether_addr_ntop(hdr->src, addr, sizeof(addr)));
    fprintf(stderr, "        dst: %s\n", ether_addr_ntop(hdr->dst, addr, sizeof(addr)));
    fprintf(stderr, "       type: 0x%04x\n", ntoh16(hdr->type));
#ifdef HEXDUMP
    hexdump(stderr, frame, flen);
#endif
    funlockfile(stderr);
}

int
ether_transmit_helper(struct net_device *dev, uint16_t type, const uint8_t *data, size_t len, const void *dst, ether_transmit_func_t callback)
{
    uint8_t *frame;
    struct ether_hdr *hdr;
    size_t flen, pad = 0;
    int ret;

    frame = memory_alloc(ETHER_FRAME_SIZE_MAX);
    if (!frame) {
        return -1;
    }
    hdr = (struct ether_hdr *)frame;
    memcpy(hdr->dst, dst, ETHER_ADDR_LEN);
    memcpy(hdr->src, dev->addr, ETHER_ADDR_LEN);
    hdr->type = hton16(type);
    memcpy(hdr+1, data, len);
    if (len < ETHER_PAYLOAD_SIZE_MIN) {
        pad = ETHER_PAYLOAD_SIZE_MIN - len;
    }
    flen = sizeof(*hdr) + len + pad;
    debugf("dev=%s, type=0x%04x, len=%zu", dev->name, type, flen);
    ether_dump(frame, flen);
    ret = callback(dev, frame, flen) == (ssize_t)flen ? 0 : -1;
    memory_free(frame);
    return ret;
}

int
ether_input_helper(struct net_device *dev, ether_input_func_t callback)
{
    uint8_t *frame;
    ssize_t flen;
    struct ether_hdr *hdr;
    uint16_t type;
    int ret;

    frame = memory_alloc(ETHER_FRAME_SIZE_MAX);
    if (!frame) {
        return -1;
    }
    flen = callback(dev, frame, ETHER_FRAME_SIZE_MAX);
    if (flen < (ssize_t)sizeof(*hdr)) {
        errorf("too short");
        memory_free(frame);
        return -1;
    }
    hdr = (struct ether_hdr *)frame;
    if (memcmp(dev->addr, hdr->dst, ETHER_ADDR_LEN) != 0) {
        if (memcmp(ETHER_ADDR_BROADCAST, hdr->dst, ETHER_ADDR_LEN) != 0) {
            /* for other host */
            memory_free(frame);
            return -1;
        }
    }
    type = ntoh16(hdr->type);
    debugf("dev=%s, type=0x%04x, len=%zd", dev->name, type, flen);
    ether_dump(frame, flen);
    ret = net_input_handler(type, (uint8_t *)(hdr+1), flen - sizeof(*hdr), dev);
    memory_free(frame);
    return ret;
}

void
ether_setup_helper(struct net_device *dev)
{
    dev->type = NET_DEVICE_TYPE_ETHERNET;
    dev->mtu = ETHER_PAYLOAD_SIZE_MAX;
    dev->flags = (NET_DEVICE_FLAG_BROADCAST | NET_DEVICE_FLAG_NEED_ARP);
    dev->hlen = ETHER_HDR_SIZE;
    dev->alen = ETHER_ADDR_LEN;
    memcpy(dev->broadcast, ETHER_ADDR_BROADCAST, ETHER_ADDR_LEN);
}
```
</details>

#### 🌟 Makefileの修正

ソースファイルを追加したので`Makefile`を修正します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 Makefile（クリックしてコードを表示）</span></summary>

```diff
 OBJS = \
...
   $K/virtio_disk.o \
   $N/util.o \
   $N/net.o \
+  $N/ether.o \
   $P/std.o

```
</details>

一旦、この状態でビルドが通ることを確認しておきましょう。

```
$ make clean
$ make
```

## 3.3. virtio-netドライバ

QEMUが提供する「virtio-net」デバイスのドライバを作成します。

> [!NOTE]
> virtio-netをはじめとするvirtioデバイスは、物理的なハードウェアをソフトウェアで完全にエミュレートするのとは異なり、ゲストOSが自身が仮想デバイスであることを認識してハイパーバイザーと協調して効率的に動作するように設計されています。

> [!NOTE]
> RISC-V版のxv6では、ディスク装置にvirtio-diskを利用しており、既にvirtioデバイスを扱うためのコードが含まれています。これを参考にしながら、新たにvirtio-netに対応させていきます。

#### 🌟 virtio-netデバイスの接続

まず、QEMUを起動した際にゲストであるxv6に対してvirtio-netデバイスが提供されるように`Makefile`を修正します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 Makefile（クリックしてコードを表示）</span></summary>

```diff
...

+TAPDEV=tap0
+TAPADDR=192.0.2.1/24
+
 QEMUOPTS = -machine virt -bios none -kernel $K/kernel -m 128M -smp $(CPUS) -nographic
 QEMUOPTS += -global virtio-mmio.force-legacy=false
 QEMUOPTS += -drive file=fs.img,if=none,format=raw,id=x0
 QEMUOPTS += -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0
+QEMUOPTS += -netdev tap,ifname=$(TAPDEV),id=en0
+QEMUOPTS += -device virtio-net-device,netdev=en0,csum=off,gso=off,guest_csum=off,bus=virtio-mmio-bus.1
 
+tap:
+       @ip addr show $(TAPDEV) 2>/dev/null || (echo "Create '$(TAPDEV)'"; \
+         sudo ip tuntap add mode tap user $(USER) name $(TAPDEV); \
+         sudo sysctl -w net.ipv6.conf.$(TAPDEV).disable_ipv6=1; \
+         sudo ip addr add $(TAPADDR) dev $(TAPDEV); \
+         sudo ip link set $(TAPDEV) up; \
+         ip addr show $(TAPDEV); \
+       )
+
-qemu: $K/kernel fs.img
+qemu: $K/kernel fs.img tap
        $(QEMU) $(QEMUOPTS)

...
```
</details>

> [!NOTE]
> QEMUの起動オプションを記述する`QEMUOPTS`に対してvirtio-netを用いたネットワークデバイスを追加する設定を加えます。このネットワークデバイスはホスト側のTapデバイスに接続するようにします。

> [!NOTE]
> virtioのトランスポート仕様にはPCIとMMIOがありますが、ここではPCIよりも実装しやすいMMIOを採用しています。

> [!NOTE]
> QEMUは起動時にTapデバイスを作成しますが、IPアドレスの設定まではやってくれません。`make qemu`を実行した際にTapデバイスが存在しなければ作成してIPアドレスを設定する処理も合わせて追加しています。

再ビルドした後、`make qemu`を実行してxv6を起動させます。

> [!NOTE]
> QEMUを起動する前にTapデバイスを作成してIPアドレスが設定されるはずです。

```
Create 'tap0'
net.ipv6.conf.tap0.disable_ipv6 = 1
79: tap0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc fq_codel state DOWN group default qlen 1000
    link/ether 16:2a:af:19:b5:91 brd ff:ff:ff:ff:ff:ff
    inet 192.0.2.1/24 scope global tap0
       valid_lft forever preferred_lft forever
...
```

> [!NOTE]
> 続けてQEMUが起動してくれば大丈夫です。起動に失敗した場合は`QEMUOPT`への追加内容にミスがないか確認してください。

```
xv6 kernel is booting

17:38:44.308 [I] net_init: initialized (kernel/net/net.c:365)
17:38:44.309 [D] net_run: open all devices... (kernel/net/net.c:311)
17:38:44.309 [D] net_run: running... (kernel/net/net.c:315)
hart 1 starting
hart 2 starting
init: starting sh
$
```

#### 🌟 MMIOアドレスのマッピング

QEMUが提供するvirtio-netデバイスをxv6で扱えるようにするための設定を行います。これは同じMMIOデバイスであるGoldfish RTCを扱えるようにした時と同じ作業です。

> [!NOTE]
> Goldfish RTCと同様にvirtioデバイスの物理アドレスもQEMU側で決められており、1つめのvirtioデバイスが`0x10001000`、2つめのvirtioデバイスが`0x10002000`に配置されます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/memlayout.h（クリックしてコードを表示）</span></summary>

```diff
 // Physical memory layout

 // qemu -machine virt is set up like this,
 // based on qemu's hw/riscv/virt.c:
 //
 // 00001000 -- boot ROM, provided by qemu
 // 00101000 -- RTC
 // 02000000 -- CLINT
 // 0C000000 -- PLIC
 // 10000000 -- uart0 
 // 10001000 -- virtio disk
+// 10002000 -- virtio network 
 // 80000000 -- boot ROM jumps here in machine mode
 //             -kernel loads the kernel here
 // unused RAM after 80000000.

 // the kernel uses physical memory thus:
 // 80000000 -- entry.S, then kernel text and data
 // end -- start of kernel page allocation area
 // PHYSTOP -- end RAM used by the kernel

 // Goldfish RTC
 #define RTC 0x00101000L

 // qemu puts UART registers here in physical memory.
 #define UART0 0x10000000L
 #define UART0_IRQ 10

 // virtio mmio interface
 #define VIRTIO0 0x10001000
 #define VIRTIO0_IRQ 1
+#define VIRTIO1 0x10002000L
+#define VIRTIO1_IRQ 2

...
```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/vm.c（クリックしてコードを表示）</span></summary>

```diff
...
 pagetable_t
 kvmmake(void)
 {
...
   // virtio mmio disk interface
   kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
 
+  // virtio mmio network interface
+  kvmmap(kpgtbl, VIRTIO1, VIRTIO1, PGSIZE, PTE_R | PTE_W);
+
   // PLIC
   kvmmap(kpgtbl, PLIC, PLIC, 0x4000000, PTE_R | PTE_W);
...
 }
```
</details>

#### 🌟 virtio-netデバイスのドライバを追加

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/net/platform/xv6-riscv/virtio_net.c（クリックしてコードを表示）</span></summary>

```c
#include "platform.h"
#include "memlayout.h"
#include "virtio.h"

#include "util.h"
#include "net.h"
#include "ether.h"

#define R(r) ((volatile uint32_t *)(VIRTIO1 + (r)))

/*
 * virtq
 */

struct virtq {
    struct virtq_desc *desc;
    struct virtq_avail *avail;
    struct virtq_used *used;
    int num;
    int last_used_idx;
    char *free;
};

void
virtq_init(struct virtq *vq, int sel, int num)
{
    uint32_t max;

    // select queue
    *R(VIRTIO_MMIO_QUEUE_SEL) = sel;

    // ensure selected queue is not in use.
    if (*R(VIRTIO_MMIO_QUEUE_READY)) {
        panic("queue already in use");
    }

    // check maximum queue size.
    max = *R(VIRTIO_MMIO_QUEUE_NUM_MAX);
    if (max == 0) {
        panic("queue not available");
    }
    if (max < num) {
        panic("queue too short");
    }

    // allocate and zero queue memory.
    vq->desc = kalloc();
    vq->avail = kalloc();
    vq->used = kalloc();
    vq->free = kalloc();
    if (!vq->desc || !vq->avail || !vq->used || !vq->free) {
        panic("kalloc failed");
    }
    memset(vq->desc, 0, PGSIZE);
    memset(vq->avail, 0, PGSIZE);
    memset(vq->used, 0, PGSIZE);
    memset(vq->free, 0,  PGSIZE);

    // set queue size.
    vq->num = num;
    *R(VIRTIO_MMIO_QUEUE_NUM) = vq->num;

    // write physical addresses.
    *R(VIRTIO_MMIO_QUEUE_DESC_LOW) = (uint64_t)vq->desc;
    *R(VIRTIO_MMIO_QUEUE_DESC_HIGH) = (uint64_t)vq->desc >> 32;
    *R(VIRTIO_MMIO_DRIVER_DESC_LOW) = (uint64_t)vq->avail;
    *R(VIRTIO_MMIO_DRIVER_DESC_HIGH) = (uint64_t)vq->avail >> 32;
    *R(VIRTIO_MMIO_DEVICE_DESC_LOW) = (uint64_t)vq->used;
    *R(VIRTIO_MMIO_DEVICE_DESC_HIGH) = (uint64_t)vq->used >> 32;

    // queue is ready.
    *R(VIRTIO_MMIO_QUEUE_READY) = 1;

    // all descriptors start out unused.
    for (int i = 0; i < vq->num; i++) {
        vq->free[i] = 1;
    }
    vq->last_used_idx = 0;
}

// find a free descriptor, mark it non-free, return its index.
int
virtq_alloc_desc(struct virtq *vq)
{
    for (int i = 0; i < vq->num; i++) {
        if(vq->free[i]){
            vq->free[i] = 0;
            return i;
        }
    }
    return -1;
}

// mark a descriptor as free.
void
virtq_free_desc(struct virtq *vq, int i)
{
    if (i >= vq->num) {
        panic("virtq_free_desc: invalid index");
    }
    if (vq->free[i]) {
        panic("virtq_free_desc: freeing free descriptor");
    }
    vq->desc[i].addr = 0;
    vq->desc[i].len = 0;
    vq->desc[i].flags = 0;
    vq->desc[i].next = 0;
    vq->free[i] = 1;
}

/*
 * virtio-net
 */

#define RXQ 0
#define TXQ 1

#define QSIZE NUM
#define RX_BUF_SIZE 2048

#define VIRTIO_MMIO_CONFIG 0x100
#define VIRTIO_NET_F_CSUM 0
#define VIRTIO_NET_F_GUEST_CSUM 1
#define VIRTIO_NET_F_MAC 5
#define VIRTIO_F_VERSION_1 32

struct virtio_net {
    struct net_device *dev;
    uint32_t status;
    uint64_t features;
    struct spinlock lock;
    struct virtq rx_q;
    struct virtq tx_q;
    char rx_bufs[QSIZE][RX_BUF_SIZE];
    char tx_bufs[QSIZE][RX_BUF_SIZE];
    char tx_status[QSIZE];
} _nic0;

struct virtio_net_hdr {
#define VIRTIO_NET_HDR_F_NEEDS_CSUM 1
#define VIRTIO_NET_HDR_F_DATA_VALID 2
#define VIRTIO_NET_HDR_F_RSC_INFO 4
    uint8_t flags;
#define VIRTIO_NET_HDR_GSO_NONE 0
#define VIRTIO_NET_HDR_GSO_TCPV4 1
#define VIRTIO_NET_HDR_GSO_UDP 3
#define VIRTIO_NET_HDR_GSO_TCPV6 4
#define VIRTIO_NET_HDR_GSO_ECN 0x80
    uint8_t gso_type;
    uint16_t hdr_len;
    uint16_t gso_size;
    uint16_t csum_start;
    uint16_t csum_offset;
    uint16_t num_buffers;
};

#define PRIV(x) ((struct virtio_net *)(x)->priv)

static int
virtio_net_open(struct net_device *dev)
{
    struct virtio_net *nic = PRIV(dev);

    acquire(&nic->lock);

    // set receive buffers
    for (int i = 0; i < QSIZE; i++) {
        nic->rx_q.desc[i].addr = (uint64)nic->rx_bufs[i];
        nic->rx_q.desc[i].len = RX_BUF_SIZE;
        nic->rx_q.desc[i].flags = VRING_DESC_F_WRITE;
        nic->rx_q.avail->ring[i] = i;
        nic->rx_q.free[i] = 0;
    }
    __sync_synchronize();
    nic->rx_q.avail->idx = QSIZE;
    nic->rx_q.last_used_idx = 0;

    // tell device we're completely ready.
    nic->status |= VIRTIO_CONFIG_S_DRIVER_OK;
    *R(VIRTIO_MMIO_STATUS) = nic->status;

    // Notify the device of new RX buffers.
    *R(VIRTIO_MMIO_QUEUE_NOTIFY) = RXQ;

    release(&nic->lock);

    return 0;
}

static int
virtio_net_close(struct net_device *dev)
{
    struct virtio_net *nic = PRIV(dev);

    acquire(&nic->lock);

    nic->status = *R(VIRTIO_MMIO_STATUS);

    // clear DRIVER_OK bit
    nic->status &= ~VIRTIO_CONFIG_S_DRIVER_OK;
    *R(VIRTIO_MMIO_STATUS) = nic->status;

    release(&nic->lock);
    return 0;
}

static ssize_t 
virtio_net_write(struct net_device *dev, const uint8_t *data, size_t len)
{
    struct virtio_net *nic = PRIV(dev);
    int idx;
    void *buf;
    struct virtio_net_hdr *hdr;

    if (len > RX_BUF_SIZE) {
        return -1;
    }
 
    acquire(&nic->lock);

    // Allocate descriptor
    idx = virtq_alloc_desc(&nic->tx_q);
    if (idx == -1) {
        release(&nic->lock);
        return -1;
    }

    buf = nic->tx_bufs[idx];
    hdr = buf;

    // Setup virtio-net header.
    hdr->flags = 0; // assume the packet is completely checksummed
    hdr->gso_type = VIRTIO_NET_HDR_GSO_NONE;
    hdr->hdr_len = 0; // unused
    hdr->gso_size = 0; // unused
    hdr->csum_start = 0; // unused
    hdr->csum_offset = 0; // unused
    hdr->num_buffers = 0; // driver must set num_buffers to 0
    memmove(nic->tx_bufs[idx] + sizeof(*hdr), data, len);

    // Configure descriptor
    nic->tx_q.desc[idx].addr = (uint64_t)nic->tx_bufs[idx];
    nic->tx_q.desc[idx].len = sizeof(*hdr) + len;
    nic->tx_q.desc[idx].flags = 0; // read by device

    // Deploy descriptor in the available ring.
    nic->tx_q.avail->ring[nic->tx_q.avail->idx % nic->tx_q.num] = idx;
    __sync_synchronize();
    nic->tx_q.avail->idx++;
    __sync_synchronize();

    release(&nic->lock);

    // Notify the device of a new TX packet.
    *R(VIRTIO_MMIO_QUEUE_NOTIFY) = TXQ;

    return len;
}

static int
virtio_net_transmit(struct net_device *dev, uint16_t type, const uint8_t *packet, size_t len, const void *dst)
{
  return ether_transmit_helper(dev, type, packet, len, dst, virtio_net_write);;
}

static ssize_t
virtio_net_read(struct net_device *dev, uint8_t *buf, size_t size)
{
    struct virtio_net *nic = PRIV(dev);

    int ring_idx = nic->rx_q.last_used_idx % nic->rx_q.num;
    int idx = nic->rx_q.used->ring[ring_idx].id;
    int len = nic->rx_q.used->ring[ring_idx].len;

    // The actual data starts after the virtio-net header.
    int hdrlen = sizeof(struct virtio_net_hdr);
    memcpy(buf, nic->rx_bufs[idx] + hdrlen, len - hdrlen);

    // Recycle the receive buffer descriptor.
    nic->rx_q.desc[idx].addr = (uint64_t)nic->rx_bufs[idx];
    nic->rx_q.desc[idx].len = RX_BUF_SIZE;

    // Return the descriptor to the available ring.
    nic->rx_q.avail->ring[nic->rx_q.avail->idx % nic->rx_q.num] = idx;

    return len - hdrlen;
}

void
virtio_net_intr(void)
{
    struct virtio_net *nic = &_nic0;

    acquire(&nic->lock);

    // Acknowledge the interrupt and clear the status by writing it back.
    *R(VIRTIO_MMIO_INTERRUPT_ACK) = *R(VIRTIO_MMIO_INTERRUPT_STATUS) & 0x3;
    __sync_synchronize();

    // Process completed descriptors from the tx used ring.
    while (nic->tx_q.last_used_idx != nic->tx_q.used->idx) {
        int ring_idx = nic->tx_q.last_used_idx % nic->tx_q.num;
        int idx = nic->tx_q.used->ring[ring_idx].id;
        virtq_free_desc(&nic->tx_q, idx);
        nic->tx_q.last_used_idx++;
    }

    // Process incoming packets from the rx used ring.
    while (nic->rx_q.last_used_idx != nic->rx_q.used->idx) {
        ether_input_helper(nic->dev, virtio_net_read);
        __sync_synchronize();
        nic->rx_q.avail->idx++;
        nic->rx_q.last_used_idx++;
    }
    __sync_synchronize();

    release(&nic->lock);

    // Notify the device of new RX buffers.
    *R(VIRTIO_MMIO_QUEUE_NOTIFY) = RXQ;

    intr_raise_irq(INTR_IRQ_SOFTIRQ);
}

struct net_device_ops virtio_net_ops = {
    .open = virtio_net_open,
    .close = virtio_net_close,
    .transmit = virtio_net_transmit,
};

void
virtio_net_init(void)
{
    struct virtio_net *nic = &_nic0;
    uint8_t addr[6];
    struct net_device *dev;
    char mac[ETHER_ADDR_STR_LEN];

    initlock(&nic->lock, "virtio-net");

    // find virtio-net device
    if (*R(VIRTIO_MMIO_MAGIC_VALUE) != 0x74726976 ||
        *R(VIRTIO_MMIO_VERSION) != 2 ||
        *R(VIRTIO_MMIO_DEVICE_ID) != 1 || // network device
        *R(VIRTIO_MMIO_VENDOR_ID) != 0x554d4551){
        panic("virtio-net: device not found");
    }

    debugf("device found");

    // reset device
    nic->status = 0;
    *R(VIRTIO_MMIO_STATUS) = nic->status;

    // set ACKNOWLEDGE status bit
    nic->status |= VIRTIO_CONFIG_S_ACKNOWLEDGE;
    *R(VIRTIO_MMIO_STATUS) = nic->status;

    // set DRIVER status bit
    nic->status |= VIRTIO_CONFIG_S_DRIVER;
    *R(VIRTIO_MMIO_STATUS) = nic->status;

    // negotiate features
    nic->features = *R(VIRTIO_MMIO_DEVICE_FEATURES);
    nic->features &= ~(1ULL << VIRTIO_RING_F_EVENT_IDX);
    nic->features &= ~(1ULL << VIRTIO_NET_F_CSUM);
    nic->features |= (1ULL << VIRTIO_NET_F_GUEST_CSUM);
    *R(VIRTIO_MMIO_DRIVER_FEATURES) = nic->features;

    // tell device that feature negotiation is complete.
    nic->status |= VIRTIO_CONFIG_S_FEATURES_OK;
    *R(VIRTIO_MMIO_STATUS) = nic->status;

    // re-read status to ensure FEATURES_OK is set.
    if (!(*R(VIRTIO_MMIO_STATUS) & VIRTIO_CONFIG_S_FEATURES_OK)) {
        panic("virtio-net: FEATURES_OK failed");
    }

    // read MAC address
    if (nic->features & (1 << VIRTIO_NET_F_MAC)) {
        for (int i = 0; i < 6; i++) {
            addr[i] = *(volatile uint8_t *)((uint64)(VIRTIO1 + VIRTIO_MMIO_CONFIG + i));
        }
    } else {
        debugf("device does not provide a MAC address");
    }

    // initialize TXQ
    virtq_init(&nic->tx_q, TXQ, QSIZE);

    // initialize RXQ
    virtq_init(&nic->rx_q, RXQ, QSIZE);
    for (int i = 0; i < QSIZE; i++) {
        nic->rx_q.desc[i].addr = (uint64_t)nic->rx_bufs[i];
        nic->rx_q.desc[i].len = RX_BUF_SIZE;
        nic->rx_q.desc[i].flags = VRING_DESC_F_WRITE;
        nic->rx_q.avail->ring[i] = i;
        nic->rx_q.free[i] = 0;
    }
    __sync_synchronize();
    nic->rx_q.avail->idx = QSIZE;

    // tell device we're completely ready.
    nic->status |= VIRTIO_CONFIG_S_DRIVER_OK;
    *R(VIRTIO_MMIO_STATUS) = nic->status;

    // setup device driver structure
    dev = net_device_alloc();
    if (!dev) {
        errorf("net_device_alloc() failure");
        return;
    }
    ether_setup_helper(dev);
    memcpy(dev->addr, addr, sizeof(addr));
    dev->priv = nic;
    dev->ops = &virtio_net_ops;
    if (net_device_register(dev) == -1) {
        errorf("net_device_register() failure");
        memory_free(dev);
        return;
    }
    nic->dev = dev;

    debugf("initialized, addr=%s", ether_addr_ntop(dev->addr, mac, sizeof(mac)));
}
```
</details>

> [!NOTE]
> virtioデバイスの初期化の流れ。
> - `STATUS`レジスタに`0`を書き込んでデバイスをリセットする。
> - `STATUS`レジスタに`ACKNOWLEDGE`ビットをセットする。
> - `STATUS`レジスタに`DRIVER`ビットをセットする。
> - デバイスとドライバの間で機能をネゴシエーションする。
>     - `DEVICE_FEATURES`レジスタを読んでデバイスが提供する機能を取得する。
>     - ドライバが使用したい機能を追加したり使用したくない機能を削除して`DRIVER_FEATURES`にセットする。
> - `STATUS`レジスタに`FEATURES_OK`をセットする。
> - `STATUS`レジスタを読み取って`FEATURES_OK`がセットされていることを確認する。
>     - `FEATURES_OK`がセットされていなかたらネゴシエーション失敗。
> - 送受信キューの初期化
> - 受信キューにパケットを格納するためのバッファを設定
> - `STATUS`レジスタに`DRIVER_OK`をセットする。

> [!NOTE]
> ネゴシエーション時の注意点。
> - `VIRTIO_RING_F_EVENT_IDX`フラグを取り除いています。このフラグが設定されているとイベント通知が最適化され、ドライバ側で適切に対処しないと次のイベント通知が受け取れなくなってしまいます。
> - `VIRTIO_NET_F_CSUM`フラグを取り除いています。このフラグが設定されているとデバイス側でのチェックサム計算のオフロードが有効になり、トランスポート層で受信パケットのチェックサム異常を検出してしまうことがあるので注意してください。

> [!NOTE]
> 送受信キュー初期化の流れ。
> - `QUEUE_SEL`レジスタに初期化したいキューのインデックス（`0`から始まる番号）を書き込む。
> - `QUEUE_READY`レジスタを読み取る
>     - 読み取った値が`0`でなかったらそのキューは既に初期化済みで使用されているので失敗。
> - `QUEUE_NUM_MAX`レジスタを読み取んでデバイスがサポートするキューの最大サイズを取得する
>     - 値が`0`の場合、そのインデックスのキューは存在しない。
> - キューを構成する3つの領域（Descriptor Table, Available Ring, Used Ring）の物理的に連続なメモリを確保する。
> - `QUEUE_NUM`レジスタにドライバが使用するキューのサイズ（ディスクリプタ数）を書き込む。
> - 確保した各領域の物理アドレスを、対応するレジスタに書き込んでデバイスに通知する。
> - `QUEUE_ENABLE`レジスタに`1`を書き込み、キューを有効化する。

> [!NOTE]
> virtioのキューを構成する3つのリングについて。
> - Descriptor Table
>     - 送受信したいデータの実体（パケットなど）がメモリのどこにあるのか、そのアドレスとサイズを保持する。
> - Available Ring
>     - ドライバは処理してほしいディスクリプタの番号をこのリングに書き込み、デバイスに新しいく処理を要求する。
> - Used Ring
>     - デバイスは処理が終わったディスクリプタの番号をこのリングに書き込み、ドライバに処理が完了したことを通知する。 

#### 🌟 プロトタイプ宣言の追加

追加した関数のプロトタイプ宣言を`kernel/defs.h`に追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/defs.h（クリックしてコードを表示）</span></summary>

```diff
...

 // net/net.c
 void            netinit(void);
 void            netrun(void);
 int             net_softirq_handler(void);
 int             net_event_handler(void);

+// net/platform/xv6-riscv/virtio_net.c
+void            virtio_net_init(void);
+void            virtio_net_intr(void);

 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
```
</details>

#### 🌟 ドライバの初期化関数の呼び出し

`kernel/main.c`の`main()`に`virtio_net_init()`の呼び出しを追加します。追加する場所は`netinit()`と`netrun()`のあいだです。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/main.c（クリックしてコードを表示）</span></summary>

```diff
...
 void
 main()
 {
...
     netinit();       // network stack
+    virtio_net_init(); // emulated network card
     netrun();        // start networking
...
 }
```
</details>

#### 🌟 Makefileの修正

ソースファイルを追加したので`Makefile`を修正します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 Makefile（クリックしてコードを表示）</span></summary>

```diff
 OBJS = \
...
   $K/virtio_disk.o \
   $N/util.o \
   $N/net.o \
   $N/ether.o \
-  $P/std.o
+  $P/std.o \
+  $P/virtio_net.o

...
```
</details>

#### 🌟 動作確認

再ビルドした後、`make qemu`を実行してxv6を起動させます。

```
xv6 kernel is booting

18:22:19.310 [I] net_init: initialized (kernel/net/net.c:365)
18:22:19.311 [D] virtio_net_init: device found (kernel/net/platform/xv6-riscv/virtio_net.c:349)
18:22:19.312 [I] net_device_register: registered, dev=net0, type=0x0002 (kernel/net/net.c:61)
18:22:19.313 [D] virtio_net_init: initialized, addr=52:54:00:12:34:56 (kernel/net/platform/xv6-riscv/virtio_net.c:424)
18:22:19.313 [D] net_run: open all devices... (kernel/net/net.c:311)
18:22:19.314 [I] net_device_open: dev=net0, state=up (kernel/net/net.c:79)
18:22:19.314 [D] net_run: running... (kernel/net/net.c:315)
hart 1 starting
hart 2 starting
init: starting sh
$
```

> [!NOTE]
> 出力されているログからvirtio-netデバイスの初期化とプロトコルスタックへの登録に成功していることが分かります。


## 3.4. ハードウェア割り込み

virtio-netデバイスの初期化に成功しましたが、まだ割り込みを捕捉するための設定が出来ていないため、デバイスにパケットが届いても何も起きません。ここではデバイスからの通知であるハードウェア割り込みを捕捉してドライバの割り込みハンドラを呼び出すようにします。

> [!NOTE]
> RISC-Vではハードウェア割り込みに「PLIC（Platform-Level Interrupt Controller）」を使用します。これはx86でいうところの「I/O APIC」と同じようなもので、様々なデバイスからの割り込みを受け付けます。

#### 🌟 PLICの設定

PLIC関連のコードは`kernel/plic.c`にあります。既にuartとvirtio-diskの割り込みを捕捉できるようにするためのコードがあるので、これを参考にしてvirtio-netの割り込みを捕捉できるようにします。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/plic.c（クリックしてコードを表示）</span></summary>

```diff
 #include "types.h"
 #include "param.h"
 #include "memlayout.h"
 #include "riscv.h"
 #include "defs.h"

 //
 // the riscv Platform Level Interrupt Controller (PLIC).
 //

 void
 plicinit(void)
 {
   // set desired IRQ priorities non-zero (otherwise disabled).
   *(uint32*)(PLIC + UART0_IRQ*4) = 1;
   *(uint32*)(PLIC + VIRTIO0_IRQ*4) = 1;
+  *(uint32*)(PLIC + VIRTIO1_IRQ*4) = 1;
 }

 void
 plicinithart(void)
 {
   int hart = cpuid();
  
   // set enable bits for this hart's S-mode
-  // for the uart and virtio disk.
+  // for the uart and virtio disk and virtio network
-  *(uint32*)PLIC_SENABLE(hart) = (1 << UART0_IRQ) | (1 << VIRTIO0_IRQ);
+  *(uint32*)PLIC_SENABLE(hart) = (1 << UART0_IRQ) | (1 << VIRTIO0_IRQ) | (1 << VIRTIO1_IRQ);

   // set this hart's S-mode priority threshold to 0.
   *(uint32*)PLIC_SPRIORITY(hart) = 0;
 }

...
```
</details>

> [!NOTE]
> `plicinit()`では割り込みの優先度を設定し、`plicinithart()`では有効にする割り込みを設定します。

#### 🌟 割り込みの捕捉

割り込み関連のコードは`kernel/trap.c`にあります。こちらも`devintr()`の中にuartとvirtio-diskの割り込みを捕捉するコードがあるので、これを参考にしてvirtio-netの割り込みを捕捉したら`virtio_net_intr()`を呼び出す処理を追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/trap.c（クリックしてコードを表示）</span></summary>

```diff
...

 // check if it's an external interrupt or software interrupt,
 // and handle it.
 // returns 2 if timer interrupt,
 // 1 if other device,
 // 0 if not recognized.
 int
 devintr()
 {
   uint64 scause = r_scause();

   if(scause == 0x8000000000000009L){
     // this is a supervisor external interrupt, via PLIC.

     // irq indicates which device interrupted.
     int irq = plic_claim();

     if(irq == UART0_IRQ){
       uartintr();
     } else if(irq == VIRTIO0_IRQ){
       virtio_disk_intr();
+    } else if(irq == VIRTIO1_IRQ){
+      virtio_net_intr();
     } else if(irq){
       printf("unexpected interrupt irq=%d\n", irq);
     }

     // the PLIC allows each device to raise at most one
     // interrupt at a time; tell the PLIC the device is
     // now allowed to interrupt again.
     if(irq)
       plic_complete(irq);

     return 1;
   } else if(scause == 0x8000000000000005L){
     // timer interrupt.
     clockintr();
     return 2;
   } else {
     return 0;
   }
 }
```
</details>

#### 🌟 動作確認

再ビルドした後、`make qemu`を実行してxv6を起動します。

```
xv6 kernel is booting

18:28:55.309 [I] net_init: initialized (kernel/net/net.c:365)
18:28:55.310 [D] virtio_net_init: device found (kernel/net/platform/xv6-riscv/virtio_net.c:349)
18:28:55.311 [I] net_device_register: registered, dev=net0, type=0x0002 (kernel/net/net.c:61)
18:28:55.312 [D] virtio_net_init: initialized, addr=52:54:00:12:34:56 (kernel/net/platform/xv6-riscv/virtio_net.c:424)
18:28:55.312 [D] net_run: open all devices... (kernel/net/net.c:311)
18:28:55.313 [I] net_device_open: dev=net0, state=up (kernel/net/net.c:79)
18:28:55.313 [D] net_run: running... (kernel/net/net.c:315)
hart 1 starting
hart 2 starting
init: starting sh
$ 
...
```

開発環境で別のシェルを開き、`192.0.2.2`に対して`ping`を実行します。

```
$ ping -c 3 192.0.2.2
```

割り込みの設定が正しく行えていればvirtio-netデバイスからの割り込みを捕捉してパケットを受信できるようになっているはずです。

```
18:28:55.472 [D] ether_input_helper: dev=net0, type=0x0806, len=42 (kernel/net/ether.c:123)
        src: 16:2a:af:19:b5:91
        dst: ff:ff:ff:ff:ff:ff
       type: 0x0806
+------+-------------------------------------------------+------------------+
| 0000 | ff ff ff ff ff ff 16 2a af 19 b5 91 08 06 00 01 | .......*........ |
| 0010 | 08 00 06 04 00 01 16 2a af 19 b5 91 c0 00 02 01 | .......*........ |
| 0020 | 00 00 00 00 00 00 c0 00 02 02                   | ..........       |
+------+-------------------------------------------------+------------------+
...
```

## 3.5. ソフトウェア割り込み

Supervisor Software Interrupt を利用して、自作プロトコルスタックが必要とするソフトウェア割り込み機能を作ります。

#### 🌟 Supervisor Software Interrupt を扱えるようにする

スーパバイザレベルで処理待ちの割り込みが何かを示します`sip`レジスタにおいて Supervisor Software Interrupt が保留中であることを示すビットを`SIP_SSIP`として定義します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/riscv.h（クリックしてコードを表示）</span></summary>

```diff
...

 // Supervisor Interrupt Pending
+#define SIP_SSIP (1L << 1)
 static inline uint64
 r_sip()
 {
   uint64 x;
   asm volatile("csrr %0, sip" : "=r" (x) );
   return x;
 }

 static inline void 
 w_sip(uint64 x)
 {
   asm volatile("csrw sip, %0" : : "r" (x));
 }

...
```
</details>

> [!NOTE]
> `SIP_SSIP`の値が`(1L << 1)`であるということはRISC-Vの仕様で定められてます。

#### 🌟 割り込み発生の理由

Supervisor Software Interruptだけでは発生の有無しかわからず、発生理由（種別）を判別することはできません。自作プロトコルスタックではソフトウェア割り込みを、各プロトコルの受信キューへのパケットを格納したことを通知する目的とイベントを通知する目的で使い分けているため、ソフトウェア割り込みの発生理由を自前で管理する必要があります。そのために、発生理由（種別）を定義しておきます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/softirq.h（クリックしてコードを表示）</span></summary>

```c
#define SOFT_IRQ_NET_RX    (1L << 1)
#define SOFT_IRQ_NET_EVENT (1L << 2)
```
</details>

> [!IMPORTANT]
> 種別ごとにどこかのビットを立てるようにします。他の種別とビットが被らないように注意してください。

#### 🌟 Supervisor Software Interruptの捕捉

Supervisor Software Interruptを捕捉して、自前で管理している種別に応じた割り込みハンドラを呼び出す処理を追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/trap.c（クリックしてコードを表示）</span></summary>

```diff
 #include "types.h"
 #include "param.h"
 #include "memlayout.h"
 #include "riscv.h"
 #include "spinlock.h"
 #include "proc.h"
 #include "defs.h"
+#include "softirq.h"

 struct spinlock tickslock;
 uint ticks;
+
+struct spinlock pendinglock;
+uint64 pending;

...

 void
 trapinit(void)
 {
   initlock(&tickslock, "time");
+  initlock(&pendinglock, "softirq");
 }

...

+void
+softintr()
+{
+  acquire(&pendinglock);
+  uint64 irqs = pending;
+  pending = 0;
+  release(&pendinglock);
+
+  if(irqs & SOFT_IRQ_NET_RX) {
+    net_softirq_handler();
+  }
+  if(irqs & SOFT_IRQ_NET_EVENT) {
+    net_event_handler();
+  }
+
+  w_sip(r_sip() & ~SIP_SSIP);
+}

 // check if it's an external interrupt or software interrupt,
 // and handle it.
 // returns 2 if timer interrupt,
 // 1 if other device,
 // 0 if not recognized.
 int
 devintr()
 {
   uint64 scause = r_scause();

   if(scause == 0x8000000000000009L){
...
+  } else if(scause == 0x8000000000000001L){
+    // software interrupt.
+    softintr();
+    return 1;
   } else if(scause == 0x8000000000000005L){
     // timer interrupt.
     clockintr();
     return 2;
   } else {
     return 0;
   }
 }
```
</details>

> [!NOTE]
> `scause`が`0x8000000000000001L`ならSupervisor Software Interruptが発生しています。
> - 最上位ビットが`1` ... 割り込みが発生していることを示しています。`0`だった場合は例外が発生していることを示しています。
> - `1L` ... Supervisor Software Interrupt が保留状態であることを示しています。

> [!NOTE]
> `pending`変数にセットされているビットでSupervisor Software Interruptの発生理由を判別します。

> [!IMPORTANT]
> Supervisor Software Interruptを処理し終えたら、必ず`w_sip(r_sip() & ~SIP_SSIP)`で割り込み処理の完了を伝えます。

新たに追加したグローバル変数`pending`と`pendinglock`を、他のソースファイルからもアクセスできるようにしておきます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/defs.h（クリックしてコードを表示）</span></summary>

```diff
...

 // trap.c
 extern uint     ticks;
+extern uint64   pending;
 void            trapinit(void);
 void            trapinithart(void);
 extern struct spinlock tickslock;
+extern struct spinlock pendinglock;
 void            usertrapret(void);

...
```
</details>

#### 🌟 ソフトウェア割り込みの発生

これまで暫定対処として空にしていた、ソフトウェア割り込みを発生させる関数`intr_raise_irq()`を実装します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/net/platform/xv6-riscv/platform.h（クリックしてコードを表示）</span></summary>

```diff
...

 /*
  * Interrupt
  */
 
+#include "softirq.h"
+
-#define INTR_IRQ_SOFTIRQ 0
-#define INTR_IRQ_EVENT 0
+#define INTR_IRQ_SOFTIRQ SOFT_IRQ_NET_RX
+#define INTR_IRQ_EVENT SOFT_IRQ_NET_EVENT
 
 static inline int
 intr_raise_irq(unsigned int irq)
 {
+    acquire(&pendinglock);
+    pending |= irq;
+    release(&pendinglock);
+    w_sip(r_sip() | SIP_SSIP);
     return 0;
 }

...
```
</details>

> [!WARNING]
> Supervisor Software Interruptの発生理由を`pending`変数に設定する際には上書きしてしまわないように注意してください。

> [!NOTE]
> `w_sip(r_sip() | SIP_SSIP)`で、現在のCPUコア対してにSupervisor Software Interruptを保留状態に設定します。

#### 🌟 ビルドの確認

ここで実装した機能が使われるのはIPモジュールを追加した後です。ここではビルドが通ることを確認して次へ進みます。

```
$ make clean
$ make
```

<hr/>

[次へ](04.md)
