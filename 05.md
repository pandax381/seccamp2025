# 5. ソケット

自作プロトコルスタックの移植が終わったので、次は「ソケット」を実装してアプリケーションがプロトコルスタックの機能を利用して通信できるようにします。

## 5.1. ファイルディスクリプタとの互換性

Linuxを含むUNIX系のOSでは、ソケットのディスクリプタはファイルディスクリプタと互換性があり、ファイルと同じように扱うことができます。例えば、ストリーム通信用のソケットは`send()`/`recv()`の代わりに`write()`/`read()`のシステムコールを使用してデータを送受信することができます。また、ソケットを閉じる際にもファイルと同様に`close()`システムコールを使用しています。

> [!NOTE]
> カーネル内でファイルを扱う構造体（`struct file`）は、ファイルに加えてパイプにも対応しています。これを拡張してソケットにも対応できるようにします。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/file.h（クリックしてコードを表示）</span></summary>

```diff
 struct file {
-  enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE } type;
+  enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE, FD_SOCKET } type;
   int ref; // reference count
   char readable;
   char writable;
   struct pipe *pipe; // FD_PIPE
   struct inode *ip;  // FD_INODE and FD_DEVICE
+  struct socket *socket; // FD_SOCKET
   uint off;          // FD_INODE
   short major;       // FD_DEVICE
 };
```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/file.c（クリックしてコードを表示）</span></summary>

```diff
...
 // Close file f.  (Decrement ref count, close when reaches 0.)
 void
 fileclose(struct file *f)
 {
   struct file ff;

   acquire(&ftable.lock);
   if(f->ref < 1)
     panic("fileclose");
   if(--f->ref > 0){
     release(&ftable.lock);
     return;
   }
   ff = *f;
   f->ref = 0;
   f->type = FD_NONE;
   release(&ftable.lock);

   if(ff.type == FD_PIPE){
     pipeclose(ff.pipe, ff.writable);
   } else if(ff.type == FD_INODE || ff.type == FD_DEVICE){
     begin_op();
     iput(ff.ip);
     end_op();
+  } else if(ff.type == FD_SOCKET){
+    socket_close(ff.socket);
   }
 }
...
```
</details>

> [!NOTE]
> `fileclose()`は`close()`システムコールのカーネル関数（`sys_close()`）から呼び出される関数ですが、ソケットだった場合には`socketclose()`を呼び出してソケットのためのクローズ処理を実行するようにします。

## 5.2. ソケットの内部実装

システムコールのカーネル関数から呼び出されて具体的な処理を行うソケット関数のコードを追加します。

#### 🌟 ソケット用の定数とアドレス構造体

ソケットで使用する定数とアドレス構造体を追加します。

> [!IMPORTANT]
> このファイルはカーネル内どユーザ空間どちらからも使用します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/net/socket.h（クリックしてコードを表示）</span></summary>

```c
#define PF_INET 1

#define AF_INET PF_INET

#define SOCK_DGRAM 1
#define SOCK_STREAM 2

#define IPPROTO_UDP 0
#define IPPROTO_TCP 0

#define INADDR_ANY ((uint32_t)0)

struct in_addr {
    uint32_t s_addr;
};

struct sockaddr {
    unsigned short sa_family;
    char sa_data[14];
};

struct sockaddr_in {
    unsigned short sin_family;
    uint16_t sin_port;
    struct in_addr sin_addr;
};
```
</details>

> [!NOTE]
> `struct sockaddr`は汎用的なアドレス構造体で、`struct sockaddr_in`はIPv4用のアドレス構造体です。ユーザ空間のプログラムは送信元や宛先のアドレスをこれらの構造体で扱います。ソケット関連のシステムコールにもソケットアドレス構造体が渡されます。

#### 🌟 ソケットのコード

ソケットのコードを追加します。自作プロトコルスタックでは、UDPやTCPのモジュールにアプリケーションに提供するためのユーザコマンドが既に実装されています。そのため、ソケットの各関数はソケットの種別に応じてUDPまたはTCPのユーザコマンドを呼び出すことで対応できます。

> [!NOTE]
> ここで示すのはUDPで使用するデータグラムソケットだけを扱えるコードとなっており、TCPのためのストリームソケットは応用課題としています。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/net/socket.c（クリックしてコードを表示）</span></summary>

```c
#include "platform.h"

#include "fs.h"
#include "sleeplock.h"
#include "file.h"
#include "socket.h"

#include "udp.h"

struct socket {
    int type;
    int desc;
};

struct file*
socket_alloc(int domain, int type, int protocol)
{
    struct file *f;
    struct socket *s;

    if (domain != AF_INET || protocol != 0) {
        return NULL;
    }
    f = filealloc();
    if (!f) {
        return NULL;
    }
    s = (struct socket *)kalloc();
    if (!s) {
        fileclose(f);
        return NULL;
    }
    s->type = type;
    switch(type) {
    case SOCK_DGRAM:
        s->desc = udp_open();
        break;
    default:
        fileclose(f);
        memory_free(s);
        return NULL;
    }
    f->type = FD_SOCKET;
    f->readable = 1;
    f->writable = 1;
    f->socket = s;
    return f;
}

int
socket_close(struct socket *s)
{
    switch (s->type) {
    case SOCK_DGRAM:
        udp_close(s->desc);
    default:
        return -1;
    }
    memory_free(s);
    return 0;
}

int
socket_bind(struct socket *s, struct sockaddr *addr, int addrlen)
{
    struct ip_endpoint local;

    local.addr = ((struct sockaddr_in *)addr)->sin_addr.s_addr;
    local.port = ((struct sockaddr_in *)addr)->sin_port;
    switch (s->type) {
    case SOCK_DGRAM:
        return udp_bind(s->desc, &local);
    default:
        return -1;
    }
}

int
socket_recvfrom(struct socket *s, char *buf, int n, struct sockaddr *addr, int *addrlen)
{
    struct ip_endpoint foreign;
    int ret;

    if (s->type != SOCK_DGRAM) {
        return -1;
    }
    ret = udp_recvfrom(s->desc, (uint8_t *)buf, n, &foreign);
    if (addr) {
        ((struct sockaddr_in *)addr)->sin_family = AF_INET;
        ((struct sockaddr_in *)addr)->sin_addr.s_addr = foreign.addr;
        ((struct sockaddr_in *)addr)->sin_port = foreign.port;
    }
    return ret;
}

int
socket_sendto(struct socket *s, char *buf, int n, struct sockaddr *addr, int addrlen)
{
    struct ip_endpoint foreign;

    if (s->type != SOCK_DGRAM) {
        return -1;
    }
    foreign.addr = ((struct sockaddr_in *)addr)->sin_addr.s_addr;
    foreign.port = ((struct sockaddr_in *)addr)->sin_port;
    return udp_sendto(s->desc, (uint8_t *)buf, n, &foreign);
}
```
</details>

> [!IMPORTANT]
> 自作プロトコルスタック内では送信元や宛先を表現するためにソケットアドレスとは異なるエンドポイント構造体を使用しているため、構造体間で値の詰替えが必要な点に注意してください。

#### 🌟 プロトタイプ宣言の追加

ソケットの関数のプロトタイプ宣言を`kernel/defs.h`に追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/defs.h（クリックしてコードを表示）</span></summary>

```diff
...
 struct buf;
 struct context;
 struct file;
 struct inode;
 struct pipe;
 struct proc;
 struct spinlock;
 struct sleeplock;
 struct stat;
 struct superblock;
 struct timeval;
 struct tm;
+struct socket;
+struct sockaddr;

...

 // net/net.c
 void            netinit(void);
 void            netrun(void);
 int             net_softirq_handler(void);
 int             net_event_handler(void);

+// net/socket.c
+struct file *   socket_alloc(int, int, int);
+int             socket_close(struct socket*);
+int             socket_bind(struct socket*, struct sockaddr*, int);
+int             socket_recvfrom(struct socket*, char*, int, struct sockaddr*, int*);
+int             socket_sendto(struct socket*, char*, int, struct sockaddr*, int);
+int             socket_connect(struct socket*, struct sockaddr*, int);
+int             socket_listen(struct socket*, int);
+struct file *   socket_accept(struct socket*, struct sockaddr*, int*);
+int             socket_read(struct socket*, char*, int);
+int             socket_write(struct socket*, char*, int);

 // net/platform/xv6-riscv/virtio_net.c
 void            virtio_net_init(void);
 void            virtio_net_intr(void);

...
```
</details>

#### 🌟 Makefileの修正

ソースファイルを追加したので`Makefile`を修正します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 Makefile（クリックしてコードを表示）</span></summary>

```diff
 OBJS = \
...
   $N/util.o \
   $N/net.o \
   $N/ether.o \
   $N/ip.o \
   $N/arp.o \
   $N/icmp.o \
   $N/udp.o \
   $N/tcp.o \
+  $N/socket.o \
   $P/std.o \
   $P/virtio_net.o


```
</details>

一旦、この状態でビルドが通ることを確認しておきましょう。

```
$ make clean
$ make
```

## 5.1. システムコールの追加

xv6の既存のシステムコールを参考にしてソケット用のシステムコールを追加していきます。

#### 🌟 システムコール番号の追加

新しく追加するシステムコールに番号を割り当てます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/syscall.h（クリックしてコードを表示）</span></summary>

```diff
 // System call numbers
 #define SYS_fork    1
 #define SYS_exit    2
 #define SYS_wait    3
 #define SYS_pipe    4
 #define SYS_read    5
 #define SYS_kill    6
 #define SYS_exec    7
 #define SYS_fstat   8
 #define SYS_chdir   9
 #define SYS_dup    10
 #define SYS_getpid 11
 #define SYS_sbrk   12
 #define SYS_sleep  13
 #define SYS_uptime 14
 #define SYS_open   15
 #define SYS_write  16
 #define SYS_mknod  17
 #define SYS_unlink 18
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_socket 22
+#define SYS_bind   23
+#define SYS_recvfrom 24
+#define SYS_sendto 25
```
</details>

#### 🌟 システムコール番号とカーネル関数の対応付け

ユーザ空間のプログラムがシステムコールを発行した際にカーネル内で実行される関数の対応付けをします。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/syscall.c（クリックしてコードを表示）</span></summary>

```diff
...

 // Prototypes for the functions that handle system calls.
 extern uint64 sys_chdir(void);
 extern uint64 sys_close(void);
 extern uint64 sys_dup(void);
 extern uint64 sys_exec(void);
 extern uint64 sys_exit(void);
 extern uint64 sys_fork(void);
 extern uint64 sys_fstat(void);
 extern uint64 sys_getpid(void);
 extern uint64 sys_kill(void);
 extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_mknod(void);
 extern uint64 sys_open(void);
 extern uint64 sys_pipe(void);
 extern uint64 sys_read(void);
 extern uint64 sys_sbrk(void);
 extern uint64 sys_sleep(void);
 extern uint64 sys_unlink(void);
 extern uint64 sys_wait(void);
 extern uint64 sys_write(void);
 extern uint64 sys_uptime(void);
+extern uint64 sys_socket(void);
+extern uint64 sys_bind(void);
+extern uint64 sys_recvfrom(void);
+extern uint64 sys_sendto(void);

 // An array mapping syscall numbers from syscall.h
 // to the function that handles the system call.
 static uint64 (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
 [SYS_exit]    sys_exit,
 [SYS_wait]    sys_wait,
 [SYS_pipe]    sys_pipe,
 [SYS_read]    sys_read,
 [SYS_kill]    sys_kill,
 [SYS_exec]    sys_exec,
 [SYS_fstat]   sys_fstat,
 [SYS_chdir]   sys_chdir,
 [SYS_dup]     sys_dup,
 [SYS_getpid]  sys_getpid,
 [SYS_sbrk]    sys_sbrk,
 [SYS_sleep]   sys_sleep,
 [SYS_uptime]  sys_uptime,
 [SYS_open]    sys_open,
 [SYS_write]   sys_write,
 [SYS_mknod]   sys_mknod,
 [SYS_unlink]  sys_unlink,
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_socket]   sys_socket,
+[SYS_bind]     sys_bind,
+[SYS_recvfrom] sys_recvfrom,
+[SYS_sendto]   sys_sendto,
 };

...
```
</details>

> [!NOTE]
> 関数ポインタの配列（`syscalls[]`）に、システムコール番号に対応するカーネル内の関数のアドレスを設定します。

#### 🌟 カーネル関数の実装

システムコールが発行された際にカーネル内で呼び出される関数を追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/syssocket.c（クリックしてコードを表示）</span></summary>

```c
#include "types.h"
#include "riscv.h"
#include "defs.h"
#include "param.h"
#include "fs.h"
#include "spinlock.h"
#include "sleeplock.h"
#include "file.h"
#include "proc.h"

#include "socket.h"

int
sys_socket(void)
{
  int fd, domain, type, protocol;
  struct file *f;

  argint(0, &domain);
  argint(1, &type);
  argint(2, &protocol);
  if ((f = socket_alloc(domain, type, protocol)) == 0 || (fd = fdalloc(f)) < 0){
    if (f)
      fileclose(f);
    return -1;
  }
  return fd;
}

int
sys_bind(void)
{
  struct file *f;
  uint64 addr_p;
  struct sockaddr_in addr;
  int addrlen;
  struct proc *p = myproc();

  if (argfd(0, 0, &f) < 0 || f->type != FD_SOCKET){
    return -1;
  }
  argaddr(1, &addr_p);
  argint(2, &addrlen);
  if (!addr_p || addrlen < 0) {
    return -1;
  }
  if (copyin(p->pagetable, (char *)&addr, addr_p, addrlen) < 0) {
    return -1;
  }
  return socket_bind(f->socket, (struct sockaddr *)&addr, addrlen);
}

int
sys_recvfrom(void)
{
  struct file *f;
  uint64 buf_p;
  char buf[2048];
  int buflen;
  uint64 addr_p;
  struct sockaddr_in addr;
  uint64 addrlen_p;
  int addrlen = 0;
  int ret;
  struct proc *p = myproc();

  if (argfd(0, 0, &f) < 0 || f->type != FD_SOCKET){
    return -1;
  }
  argaddr(1, &buf_p);
  argint(2, &buflen);
  if (!buf_p || buflen < 0 || buflen > sizeof(buf)) {
    return -1;
  }
  argaddr(3, (void*)&addr_p);
  argaddr(4, (void*)&addrlen_p);
  if (addrlen_p) {
    if (copyin(p->pagetable, (char *)&addrlen, addrlen_p, sizeof(addrlen)) < 0) {
      return -1;
    }
    if (addrlen && addrlen != sizeof(addr)) {
      return -1;
    }
  }
  if (addrlen && !addr_p) {
    return -1;
  }
  ret = socket_recvfrom(f->socket, buf, buflen, (struct sockaddr *)&addr, &addrlen);
  if (copyout(p->pagetable, buf_p, buf, buflen) < 0) {
    return -1;
  }
  if (addr_p) {
    if (copyout(p->pagetable, addr_p, (char *)&addr, addrlen) < 0) {
      return -1;
    }
    if (copyout(p->pagetable, addrlen_p, (char *)&addrlen, sizeof(addrlen)) < 0) {
      return -1;
    }
  }
  return ret;
}

int
sys_sendto(void)
{
  struct file *f;
  uint64 buf_p;
  char buf[2048];
  int buflen;
  uint64 addr_p;
  struct sockaddr_in addr;
  int addrlen;
  struct proc *p = myproc();

  if (argfd(0, 0, &f) < 0 || f->type != FD_SOCKET){
    return -1;
  }
  argaddr(1, &buf_p);
  argint(2, &buflen);
  if (!buf_p || buflen < 0 || buflen > sizeof(buf)) {
    return -1;
  }
  if (copyin(p->pagetable, buf, buf_p, buflen) < 0) {
    return -1;
  }
  argaddr(3, &addr_p);
  argint(4, &addrlen);
  if (!addr_p || addrlen < 0) {
    return -1;
  }
  if (copyin(p->pagetable, (char *)&addr, addr_p, addrlen) < 0) {
    return -1;
  }
  return socket_sendto(f->socket, buf, buflen, (struct sockaddr *)&addr, addrlen);
}
```
</details>

> [!IMPORTANT]
> 全ての関数の引数が`void`であることからもわかるように、通常の関数とは引数の受け取り方が異なります。
>
> システムコールのカーネル関数では、次のような関数を使用して引数を受け取ります。
>
> + `argint()` ... 整数
> + `argaddr()` ... ポインタ
> + `argfd()` ... ファイルディスクリプタ
> + `argstr()` ... 文字列
>
> これらの関数は、いずれも最初の引数には「0からはじまる引数の番号」を指定します。`argaddr()`ではポインタとして渡された引数のアドレスを取得しますが、このアドレスから直接データを読み出したり書き出すことはでません。必ず`copyin()`または`copyout()`を使ってカーネル空間とユーザ空間の間でデータのコピーします。
>
> 例えば `void *data`, `int len` のような形でポインタに続けて長さを受け取る場合には、先に長さの引数を受け取り、その後にポインタの引数のアドレスをもとに`copyin()`でデータを読み出します。

> [!NOTE]
> ソケットの具体的な処理は、先に実装しておいた`kernel/net/socket.c`の中で行うようにしています。`kernel/syssocket.c`の関数はシステムコールの引数を受け取ったら、それらの関数を呼び出してその結果を返します。

#### 🌟 `sysfile.c`内の関数の利用

`kernel/syssocket.c`の関数は`kernel/sysfile.c`に実装されている関数を呼び出していますが、これらはもともと`sysfile.c`の中だけで使用されている関数で`static`修飾子が付いています。このままだと他のファイルから呼び出せないので`static`修飾子を削除し、`kernel/defs.h`にプロトタイプ宣言を追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/sysfile.c（クリックしてコードを表示）</span></summary>

```diff
...

-static int
+int
 argfd(int n, int *pfd, struct file **pf)
 {
...
 }

-static int
+int
 fdalloc(struct file *f)
 {
...
 }

...
```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 kernel/defs.h（クリックしてコードを表示）</span></summary>

```diff
...

 // syscall.c
 void            argint(int, int*);
 int             argstr(int, char*, int);
 void            argaddr(int, uint64 *);
 int             fetchstr(uint64, char*, int);
 int             fetchaddr(uint64, uint64*);
 void            syscall();

+// sysfile.c
+int             argfd(int, int*, struct file**);
+int             fdalloc(struct file*);

 // time.c
 time_t          time(time_t*);
 int             gettimeofday(struct timeval*, void*);
 time_t          mktime(struct tm*);
 struct tm*      localtime_r(const time_t*, struct tm*);

...
```
</details>

#### 🌟 ユーザ空間へのシステムコールの提供

ユーザ空間のプログラムが呼び出すシステムコールのアセンブリコードを追加します。

> [!NOTE]
> アセンブリコードを追加すると言っても難しいことはなく、あらかじめ用意されているPerlスクリプトを利用することで簡単にシステムコールを追加できます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 user/usys.pl（クリックしてコードを表示）</span></summary>

```diff
...
	
 entry("fork");
 entry("exit");
 entry("wait");
 entry("pipe");
 entry("read");
 entry("write");
 entry("close");
 entry("kill");
 entry("exec");
 entry("open");
 entry("mknod");
 entry("unlink");
 entry("fstat");
 entry("link");
 entry("mkdir");
 entry("chdir");
 entry("dup");
 entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("socket");
+entry("bind");
+entry("recvfrom");
+entry("sendto");
```
</details>

次に、追加したシステムコールのプロトタイプ宣言を追加します。

> [!IMPORTANT]
> カーネル内の関数は`kernel/defs.h`に記述していましたが、ユーザ空間の関数は`user/user.h`に記述します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 user/user.h（クリックしてコードを表示）</span></summary>

```diff
 struct stat;
+struct sockaddr;

 // system calls
 int fork(void);
 int exit(int) __attribute__((noreturn));
 int wait(int*);
 int pipe(int*);
 int write(int, const void*, int);
 int read(int, void*, int);
 int close(int);
 int kill(int);
 int exec(const char*, char**);
 int open(const char*, int);
 int mknod(const char*, short, short);
 int unlink(const char*);
 int fstat(int fd, struct stat*);
 int link(const char*, const char*);
 int mkdir(const char*);
 int chdir(const char*);
 int dup(int);
 int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int socket(int, int, int);
+int bind(int, struct sockaddr*, int);
+int recvfrom(int, char*, int, struct sockaddr*, int*);
+int sendto(int, char*, int, struct sockaddr*, int);

...
```
</details>

#### 🌟 Makefileの修正

ソースファイルを追加したので`Makefile`を修正します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 Makefile（クリックしてコードを表示）</span></summary>

```diff
 OBJS = \
...
   $K/virtio_disk.o \
+  $K/syssocket.o \
   $N/util.o \
   $N/net.o \
   $N/ether.o \
   $N/ip.o \
   $N/arp.o \
   $N/icmp.o \
   $N/udp.o \
   $N/tcp.o \
   $P/std.o \
   $P/virtio_net.o

...
```
</details>

この段階でビルドが通ることを確認しておきましょう。

```
$ make clean
$ make
```

## 5.4. 通信アプリケーション

最後に、実際にソケットを使用する通信アプリケーションを作成します。

#### 🌟 ユーザライブラリへ関数の追加

通信プログラムを作成するの不足してる関数をユーザライブラリへ追加します。

> [!NOTE]
> バイトオーダー変換の関数郡は`kernel/net/util.c`からのコピペです。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 user/ulib.c（クリックしてコードを表示）</span></summary>

```diff
...

 void *
 memcpy(void *dst, const void *src, uint n)
 {
   return memmove(dst, src, n);
 }
+
+#ifndef __BIG_ENDIAN
+#define __BIG_ENDIAN 4321
+#endif
+#ifndef __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN 1234
+#endif
+
+static int endian;
+
+static int
+byteorder(void)
+{
+    uint32_t x = 0x00000001;
+
+    return *(uint8_t *)&x ? __LITTLE_ENDIAN : __BIG_ENDIAN;
+}
+
+static uint16_t
+byteswap16(uint16_t v)
+{
+    return (v & 0x00ff) << 8 | (v & 0xff00 ) >> 8;
+}
+
+static uint32_t
+byteswap32(uint32_t v)
+{
+    return (v & 0x000000ff) << 24 | (v & 0x0000ff00) << 8 | (v & 0x00ff0000) >> 8 | (v & 0xff000000) >> 24;
+}
+
+uint16_t
+htons(uint16_t h)
+{
+    if (!endian) {
+        endian = byteorder();
+    }
+    return endian == __LITTLE_ENDIAN ? byteswap16(h) : h;
+}
+
+uint16_t
+ntohs(uint16_t n)
+{
+    if (!endian) {
+        endian = byteorder();
+    }
+    return endian == __LITTLE_ENDIAN ? byteswap16(n) : n;
+}
+
+uint32_t
+htonl(uint32_t h)
+{
+    if (!endian) {
+        endian = byteorder();
+    }
+    return endian == __LITTLE_ENDIAN ? byteswap32(h) : h;
+}
+
+uint32_t
+ntohl(uint32_t n)
+{
+    if (!endian) {
+        endian = byteorder();
+    }
+    return endian == __LITTLE_ENDIAN ? byteswap32(n) : n;
+}
```
</details>

`user/ulib.c`に関数を追加したら`user/user.h`にプロトタイプ宣言を追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 user/user.h（クリックしてコードを表示）</span></summary>

```diff
...

 // ulib.c
 int stat(const char*, struct stat*);
 char* strcpy(char*, const char*);
 void *memmove(void*, const void*, int);
 char* strchr(const char*, char c);
 int strcmp(const char*, const char*);
 void fprintf(int, const char*, ...) __attribute__ ((format (printf, 2, 3)));
 void printf(const char*, ...) __attribute__ ((format (printf, 1, 2)));
 char* gets(char*, int max);
 uint strlen(const char*);
 void* memset(void*, int, uint);
 int atoi(const char*);
 int memcmp(const void *, const void *, uint);
 void *memcpy(void *, const void *, uint);
+uint16_t htons(uint16_t);
+uint16_t ntohs(uint16_t);
+uint32_t htonl(uint32_t);
+uint32_t ntohl(uint32_t);
+int inet_pton(int, const char*, void*);

 // umalloc.c
 void* malloc(uint);
 void free(void*);
```
</details>

#### 🌟 UDPエコーサーバのコード

本命のUDPエコーサーバのコードを追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 user/udpecho.c（クリックしてコードを表示）</span></summary>

```c
#include "kernel/types.h"
#include "user/user.h"
#include "kernel/net/socket.h"

int
main (int argc, char *argv[])
{
    int soc, peerlen, ret;
    struct sockaddr_in self, peer;
    unsigned char *addr;
    char buf[2048];

    printf("Starting UDP Echo Server\n");
    soc = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (soc == -1) {
        printf("socket: failure\n");
        exit(1);
    }
    printf("socket: success, soc=%d\n", soc);
    self.sin_family = AF_INET;
    self.sin_addr.s_addr = INADDR_ANY;
    self.sin_port = htons(7);
    if (bind(soc, (struct sockaddr *)&self, sizeof(self)) == -1) {
        printf("bind: failure\n");
        close(soc);
        exit(1);
    }
    addr = (unsigned char *)&self.sin_addr.s_addr;
    printf("bind: success, self=%d.%d.%d.%d:%d\n",
        addr[0], addr[1], addr[2], addr[3], ntohs(self.sin_port));
    printf("waiting for message...\n");
    while (1) {
        peerlen = sizeof(peer);
        ret = recvfrom(soc, buf, sizeof(buf), (struct sockaddr *)&peer, &peerlen);
        if (ret <= 0) {
            printf("EOF\n");
            break;
        }
        if (ret == 2 && buf[0] == '.' && buf[1] == '\n') {
            printf("quit\n");
            break;  
        }
        addr = (unsigned char *)&peer.sin_addr.s_addr;
        printf("recvfrom: %d bytes data received, peer=%d.%d.%d.%d:%d\n",
            ret, addr[0], addr[1], addr[2], addr[3], ntohs(peer.sin_port));
        sendto(soc, buf, ret, (struct sockaddr *)&peer, peerlen);
    }
    close(soc);  
    exit(0);
}
```
</details>

> [!NOTE]
> このくらいの単純なものであれば、Linux向けのコードとほとんど差がないことが見て取れます。

#### 🌟 Makefileの修正

ユーザプログラムを追加したので`Makefile`を修正します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">📕 Makefile（クリックしてコードを表示）</span></summary>

```diff
...

 UPROGS=\
 	$U/_cat\
 	$U/_echo\
 	$U/_forktest\
 	$U/_grep\
 	$U/_init\
 	$U/_kill\
 	$U/_ln\
 	$U/_ls\
 	$U/_mkdir\
 	$U/_rm\
 	$U/_sh\
 	$U/_stressfs\
+	$U/_udpecho\
 	$U/_usertests\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\

...
```
</details>

> [!IMPORTANT]
> ユーザプログラムは`UPROGS`に列挙します。この際、頭に`_`を付け、末尾の拡張子は取り除きます。

#### 🌟 動作確認

> [!WARNING]
> ユーザプログラムは`make qemu`でxv6を立ち上げる直前にコンパイルされます。単純に`make`を実行しただけではユーザプログラムはコンパイルされないので注意してください。

再ビルドしてxv6を起動します。シェルが立ち上がったら、UDPエコーサーバのプログラム（`udpecho`）を実行します。

```
$ udpecho
Starting UDP Echo Server
socket: success, soc=3
19:56:57.349 [D] udp_bind: bound, id=0, local=0.0.0.0:7 (kernel/net/udp.c:340)
bind: success, self=0.0.0.0:7
waiting for message...
```

`0.0.0.0`の`7`番ポートでデータが送られてくるのを待っているので、別のシェルで`nc`コマンドを立ち上げて適当なメッセージを送信します。

```
$ nc -u 192.0.2.2 7
hoge
hoge
fuga
fuga
.
```

> [!NOTE]
> 正常に動作していれば、送信したメッセージがそのまま送り返されてくるはずです。なお、エコーサーバのプログラムを終了させるには`.`だけのメッセージを送信します。

エコーサーバ側のログメッセージも確認してみましょう。

```
19:57:03.416 [D] ether_input_helper: dev=net0, type=0x0806, len=42 (kernel/net/ether.c:123)
        src: 16:2a:af:19:b5:91
        dst: ff:ff:ff:ff:ff:ff
       type: 0x0806
19:57:03.417 [D] net_input_handler: queue pushed (num:1), dev=net0, type=0x0806, len=28 (kernel/net/net.c:236)
19:57:03.418 [D] net_softirq_handler: queue popped (num:0), dev=net0, type=0x0806, len=28 (kernel/net/net.c:258)
19:57:03.419 [D] arp_input: dev=net0, len=28 (kernel/net/arp.c:236)
        hrd: 0x0001
        pro: 0x0800
        hln: 6
        pln: 4
         op: 1 (Request)
        sha: 16:2a:af:19:b5:91
        spa: 192.0.2.1
        tha: 00:00:00:00:00:00
        tpa: 192.0.2.2
19:57:03.421 [D] arp_cache_insert: INSERT: pa=192.0.2.1, ha=16:2a:af:19:b5:91 (kernel/net/arp.c:173)
19:57:03.422 [D] arp_reply: dev=net0, len=28 (kernel/net/arp.c:210)
        hrd: 0x0001
        pro: 0x0800
        hln: 6
        pln: 4
         op: 2 (Reply)
        sha: 52:54:00:12:34:56
        spa: 192.0.2.2
        tha: 16:2a:af:19:b5:91
        tpa: 192.0.2.1
19:57:03.423 [D] net_device_output: dev=net0, type=0x0806, len=28 (kernel/net/net.c:144)
19:57:03.424 [D] ether_transmit_helper: dev=net0, type=0x0806, len=60 (kernel/net/ether.c:88)
        src: 52:54:00:12:34:56
        dst: 16:2a:af:19:b5:91
       type: 0x0806
19:57:03.425 [D] ether_input_helper: dev=net0, type=0x0800, len=47 (kernel/net/ether.c:123)
        src: 16:2a:af:19:b5:91
        dst: 52:54:00:12:34:56
       type: 0x0800
19:57:03.426 [D] net_input_handler: queue pushed (num:1), dev=net0, type=0x0800, len=33 (kernel/net/net.c:236)
19:57:03.427 [D] net_softirq_handler: queue popped (num:0), dev=net0, type=0x0800, len=33 (kernel/net/net.c:258)
19:57:03.428 [D] ip_input: dev=net0, iface=192.0.2.2, protocol=17, total=33 (kernel/net/ip.c:357)
        vhl: 0x45 [v: 4, hl: 5 (20)]
        tos: 0x00
      total: 33 (payload: 13)
         id: 32443
     offset: 0x4000 [flags=2, offset=0]
        ttl: 64
   protocol: 17
        sum: 0x380d
        src: 192.0.2.1
        dst: 192.0.2.2
19:57:03.430 [D] udp_input: 192.0.2.1:33182 => 192.0.2.2:7, len=13 (payload=5) (kernel/net/udp.c:175)
        src: 33182
        dst: 7
        len: 13
        sum: 0x2056
19:57:03.431 [D] udp_input: queue pushed: id=0, num=1 (kernel/net/udp.c:202)
recvfrom: 5 bytes data received, peer=192.0.2.1:33182
19:57:03.439 [D] udp_sendto: select local address, addr=192.0.2.2 (kernel/net/udp.c:371)
19:57:03.439 [D] udp_output: 192.0.2.2:7 => 192.0.2.1:33182, len=13 (payload=5) (kernel/net/udp.c:241)
        src: 7
        dst: 33182
        len: 13
        sum: 0x2056
19:57:03.440 [D] ip_output_core: dev=net0, dst=192.0.2.1, protocol=17, len=33 (kernel/net/ip.c:416)
        vhl: 0x45 [v: 4, hl: 5 (20)]
        tos: 0x00
      total: 33 (payload: 13)
         id: 128
     offset: 0x0000 [flags=0, offset=0]
        ttl: 255
   protocol: 17
        sum: 0x3748
        src: 192.0.2.2
        dst: 192.0.2.1
19:57:03.442 [D] arp_resolve: resolved, pa=192.0.2.1, ha=16:2a:af:19:b5:91 (kernel/net/arp.c:298)
19:57:03.443 [D] net_device_output: dev=net0, type=0x0800, len=33 (kernel/net/net.c:144)
19:57:03.443 [D] ether_transmit_helper: dev=net0, type=0x0800, len=60 (kernel/net/ether.c:88)
        src: 52:54:00:12:34:56
        dst: 16:2a:af:19:b5:91
       type: 0x0800
...
```

ここまでに実装したUDP用のソケットが問題なく動作していることが確認できるはずです。最低限ではありますが「xv6にネットワーク機能を追加」することができました🎉

是非、応用課題でTCP用のソケットにもチャレンジしてみてください。

<hr/>

[次へ](06.md)
