# 5. ã‚½ã‚±ãƒƒãƒˆ

è‡ªä½œãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã®ç§»æ¤ãŒçµ‚ã‚ã£ãŸã®ã§ã€æ¬¡ã¯ã€Œã‚½ã‚±ãƒƒãƒˆã€ã‚’å®Ÿè£…ã—ã¦ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã®æ©Ÿèƒ½ã‚’åˆ©ç”¨ã—ã¦é€šä¿¡ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

## 5.1. ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¨ã®äº’æ›æ€§

Linuxã‚’å«ã‚€UNIXç³»ã®OSã§ã¯ã€ã‚½ã‚±ãƒƒãƒˆã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¯ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¨äº’æ›æ€§ãŒã‚ã‚Šã€ãƒ•ã‚¡ã‚¤ãƒ«ã¨åŒã˜ã‚ˆã†ã«æ‰±ã†ã“ã¨ãŒã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ é€šä¿¡ç”¨ã®ã‚½ã‚±ãƒƒãƒˆã¯`send()`/`recv()`ã®ä»£ã‚ã‚Šã«`write()`/`read()`ã®ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã—ã¦ãƒ‡ãƒ¼ã‚¿ã‚’é€å—ä¿¡ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã¾ãŸã€ã‚½ã‚±ãƒƒãƒˆã‚’é–‰ã˜ã‚‹éš›ã«ã‚‚ãƒ•ã‚¡ã‚¤ãƒ«ã¨åŒæ§˜ã«`close()`ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚

> [!NOTE]
> ã‚«ãƒ¼ãƒãƒ«å†…ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ‰±ã†æ§‹é€ ä½“ï¼ˆ`struct file`ï¼‰ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã«åŠ ãˆã¦ãƒ‘ã‚¤ãƒ—ã«ã‚‚å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚’æ‹¡å¼µã—ã¦ã‚½ã‚±ãƒƒãƒˆã«ã‚‚å¯¾å¿œã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/file.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
 struct file {
-  enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE } type;
+  enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE, FD_SOCKET } type;
   int ref; // reference count
   char readable;
   char writable;
   struct pipe *pipe; // FD_PIPE
   struct inode *ip;  // FD_INODE and FD_DEVICE
+  struct socket *socket; // FD_SOCKET
   uint off;          // FD_INODE
   short major;       // FD_DEVICE
 };
```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/file.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...
 // Close file f.  (Decrement ref count, close when reaches 0.)
 void
 fileclose(struct file *f)
 {
   struct file ff;

   acquire(&ftable.lock);
   if(f->ref < 1)
     panic("fileclose");
   if(--f->ref > 0){
     release(&ftable.lock);
     return;
   }
   ff = *f;
   f->ref = 0;
   f->type = FD_NONE;
   release(&ftable.lock);

   if(ff.type == FD_PIPE){
     pipeclose(ff.pipe, ff.writable);
   } else if(ff.type == FD_INODE || ff.type == FD_DEVICE){
     begin_op();
     iput(ff.ip);
     end_op();
+  } else if(ff.type == FD_SOCKET){
+    socket_close(ff.socket);
   }
 }
...
```
</details>

> [!NOTE]
> `fileclose()`ã¯`close()`ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã®ã‚«ãƒ¼ãƒãƒ«é–¢æ•°ï¼ˆ`sys_close()`ï¼‰ã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã‚‹é–¢æ•°ã§ã™ãŒã€ã‚½ã‚±ãƒƒãƒˆã ã£ãŸå ´åˆã«ã¯`socketclose()`ã‚’å‘¼ã³å‡ºã—ã¦ã‚½ã‚±ãƒƒãƒˆã®ãŸã‚ã®ã‚¯ãƒ­ãƒ¼ã‚ºå‡¦ç†ã‚’å®Ÿè¡Œã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

## 5.2. ã‚½ã‚±ãƒƒãƒˆã®å†…éƒ¨å®Ÿè£…

ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã®ã‚«ãƒ¼ãƒãƒ«é–¢æ•°ã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã¦å…·ä½“çš„ãªå‡¦ç†ã‚’è¡Œã†ã‚½ã‚±ãƒƒãƒˆé–¢æ•°ã®ã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ã¾ã™ã€‚

#### ğŸŒŸ ã‚½ã‚±ãƒƒãƒˆç”¨ã®å®šæ•°ã¨ã‚¢ãƒ‰ãƒ¬ã‚¹æ§‹é€ ä½“

ã‚½ã‚±ãƒƒãƒˆã§ä½¿ç”¨ã™ã‚‹å®šæ•°ã¨ã‚¢ãƒ‰ãƒ¬ã‚¹æ§‹é€ ä½“ã‚’è¿½åŠ ã—ã¾ã™ã€‚

> [!IMPORTANT]
> ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚«ãƒ¼ãƒãƒ«å†…ã©ãƒ¦ãƒ¼ã‚¶ç©ºé–“ã©ã¡ã‚‰ã‹ã‚‰ã‚‚ä½¿ç”¨ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/net/socket.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```c
#define PF_INET 1

#define AF_INET PF_INET

#define SOCK_DGRAM 1
#define SOCK_STREAM 2

#define IPPROTO_UDP 0
#define IPPROTO_TCP 0

#define INADDR_ANY ((uint32_t)0)

struct in_addr {
    uint32_t s_addr;
};

struct sockaddr {
    unsigned short sa_family;
    char sa_data[14];
};

struct sockaddr_in {
    unsigned short sin_family;
    uint16_t sin_port;
    struct in_addr sin_addr;
};
```
</details>

> [!NOTE]
> `struct sockaddr`ã¯æ±ç”¨çš„ãªã‚¢ãƒ‰ãƒ¬ã‚¹æ§‹é€ ä½“ã§ã€`struct sockaddr_in`ã¯IPv4ç”¨ã®ã‚¢ãƒ‰ãƒ¬ã‚¹æ§‹é€ ä½“ã§ã™ã€‚ãƒ¦ãƒ¼ã‚¶ç©ºé–“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯é€ä¿¡å…ƒã‚„å®›å…ˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ã“ã‚Œã‚‰ã®æ§‹é€ ä½“ã§æ‰±ã„ã¾ã™ã€‚ã‚½ã‚±ãƒƒãƒˆé–¢é€£ã®ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã«ã‚‚ã‚½ã‚±ãƒƒãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹æ§‹é€ ä½“ãŒæ¸¡ã•ã‚Œã¾ã™ã€‚

#### ğŸŒŸ ã‚½ã‚±ãƒƒãƒˆã®ã‚³ãƒ¼ãƒ‰

ã‚½ã‚±ãƒƒãƒˆã®ã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ã¾ã™ã€‚è‡ªä½œãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã§ã¯ã€UDPã‚„TCPã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«æä¾›ã™ã‚‹ãŸã‚ã®ãƒ¦ãƒ¼ã‚¶ã‚³ãƒãƒ³ãƒ‰ãŒæ—¢ã«å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚ãã®ãŸã‚ã€ã‚½ã‚±ãƒƒãƒˆã®å„é–¢æ•°ã¯ã‚½ã‚±ãƒƒãƒˆã®ç¨®åˆ¥ã«å¿œã˜ã¦UDPã¾ãŸã¯TCPã®ãƒ¦ãƒ¼ã‚¶ã‚³ãƒãƒ³ãƒ‰ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§å¯¾å¿œã§ãã¾ã™ã€‚

> [!NOTE]
> ã“ã“ã§ç¤ºã™ã®ã¯UDPã§ä½¿ç”¨ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚°ãƒ©ãƒ ã‚½ã‚±ãƒƒãƒˆã ã‘ã‚’æ‰±ãˆã‚‹ã‚³ãƒ¼ãƒ‰ã¨ãªã£ã¦ãŠã‚Šã€TCPã®ãŸã‚ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚½ã‚±ãƒƒãƒˆã¯å¿œç”¨èª²é¡Œã¨ã—ã¦ã„ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/net/socket.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```c
#include "platform.h"

#include "fs.h"
#include "sleeplock.h"
#include "file.h"
#include "socket.h"

#include "udp.h"

struct socket {
    int type;
    int desc;
};

struct file*
socket_alloc(int domain, int type, int protocol)
{
    struct file *f;
    struct socket *s;

    if (domain != AF_INET || protocol != 0) {
        return NULL;
    }
    f = filealloc();
    if (!f) {
        return NULL;
    }
    s = (struct socket *)kalloc();
    if (!s) {
        fileclose(f);
        return NULL;
    }
    s->type = type;
    switch(type) {
    case SOCK_DGRAM:
        s->desc = udp_open();
        break;
    default:
        fileclose(f);
        memory_free(s);
        return NULL;
    }
    f->type = FD_SOCKET;
    f->readable = 1;
    f->writable = 1;
    f->socket = s;
    return f;
}

int
socket_close(struct socket *s)
{
    switch (s->type) {
    case SOCK_DGRAM:
        udp_close(s->desc);
    default:
        return -1;
    }
    memory_free(s);
    return 0;
}

int
socket_bind(struct socket *s, struct sockaddr *addr, int addrlen)
{
    struct ip_endpoint local;

    local.addr = ((struct sockaddr_in *)addr)->sin_addr.s_addr;
    local.port = ((struct sockaddr_in *)addr)->sin_port;
    switch (s->type) {
    case SOCK_DGRAM:
        return udp_bind(s->desc, &local);
    default:
        return -1;
    }
}

int
socket_recvfrom(struct socket *s, char *buf, int n, struct sockaddr *addr, int *addrlen)
{
    struct ip_endpoint foreign;
    int ret;

    if (s->type != SOCK_DGRAM) {
        return -1;
    }
    ret = udp_recvfrom(s->desc, (uint8_t *)buf, n, &foreign);
    if (addr) {
        ((struct sockaddr_in *)addr)->sin_family = AF_INET;
        ((struct sockaddr_in *)addr)->sin_addr.s_addr = foreign.addr;
        ((struct sockaddr_in *)addr)->sin_port = foreign.port;
    }
    return ret;
}

int
socket_sendto(struct socket *s, char *buf, int n, struct sockaddr *addr, int addrlen)
{
    struct ip_endpoint foreign;

    if (s->type != SOCK_DGRAM) {
        return -1;
    }
    foreign.addr = ((struct sockaddr_in *)addr)->sin_addr.s_addr;
    foreign.port = ((struct sockaddr_in *)addr)->sin_port;
    return udp_sendto(s->desc, (uint8_t *)buf, n, &foreign);
}
```
</details>

> [!IMPORTANT]
> è‡ªä½œãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚¹ã‚¿ãƒƒã‚¯å†…ã§ã¯é€ä¿¡å…ƒã‚„å®›å…ˆã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã«ã‚½ã‚±ãƒƒãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ã¯ç•°ãªã‚‹ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆæ§‹é€ ä½“ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ãŸã‚ã€æ§‹é€ ä½“é–“ã§å€¤ã®è©°æ›¿ãˆãŒå¿…è¦ãªç‚¹ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚

#### ğŸŒŸ ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—å®£è¨€ã®è¿½åŠ 

ã‚½ã‚±ãƒƒãƒˆã®é–¢æ•°ã®ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—å®£è¨€ã‚’`kernel/defs.h`ã«è¿½åŠ ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/defs.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...
 struct buf;
 struct context;
 struct file;
 struct inode;
 struct pipe;
 struct proc;
 struct spinlock;
 struct sleeplock;
 struct stat;
 struct superblock;
 struct timeval;
 struct tm;
+struct socket;
+struct sockaddr;

...

 // net/net.c
 void            netinit(void);
 void            netrun(void);
 int             net_softirq_handler(void);
 int             net_event_handler(void);

+// net/socket.c
+struct file *   socket_alloc(int, int, int);
+int             socket_close(struct socket*);
+int             socket_bind(struct socket*, struct sockaddr*, int);
+int             socket_recvfrom(struct socket*, char*, int, struct sockaddr*, int*);
+int             socket_sendto(struct socket*, char*, int, struct sockaddr*, int);
+int             socket_connect(struct socket*, struct sockaddr*, int);
+int             socket_listen(struct socket*, int);
+struct file *   socket_accept(struct socket*, struct sockaddr*, int*);
+int             socket_read(struct socket*, char*, int);
+int             socket_write(struct socket*, char*, int);

 // net/platform/xv6-riscv/virtio_net.c
 void            virtio_net_init(void);
 void            virtio_net_intr(void);

...
```
</details>

#### ğŸŒŸ Makefileã®ä¿®æ­£

ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¿½åŠ ã—ãŸã®ã§`Makefile`ã‚’ä¿®æ­£ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• Makefileï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
 OBJS = \
...
   $N/util.o \
   $N/net.o \
   $N/ether.o \
   $N/ip.o \
   $N/arp.o \
   $N/icmp.o \
   $N/udp.o \
   $N/tcp.o \
+  $N/socket.o \
   $P/std.o \
   $P/virtio_net.o


```
</details>

ä¸€æ—¦ã€ã“ã®çŠ¶æ…‹ã§ãƒ“ãƒ«ãƒ‰ãŒé€šã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãŠãã¾ã—ã‚‡ã†ã€‚

```
$ make clean
$ make
```

## 5.1. ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã®è¿½åŠ 

xv6ã®æ—¢å­˜ã®ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã‚’å‚è€ƒã«ã—ã¦ã‚½ã‚±ãƒƒãƒˆç”¨ã®ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã‚’è¿½åŠ ã—ã¦ã„ãã¾ã™ã€‚

#### ğŸŒŸ ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ç•ªå·ã®è¿½åŠ 

æ–°ã—ãè¿½åŠ ã™ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã«ç•ªå·ã‚’å‰²ã‚Šå½“ã¦ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/syscall.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
 // System call numbers
 #define SYS_fork    1
 #define SYS_exit    2
 #define SYS_wait    3
 #define SYS_pipe    4
 #define SYS_read    5
 #define SYS_kill    6
 #define SYS_exec    7
 #define SYS_fstat   8
 #define SYS_chdir   9
 #define SYS_dup    10
 #define SYS_getpid 11
 #define SYS_sbrk   12
 #define SYS_sleep  13
 #define SYS_uptime 14
 #define SYS_open   15
 #define SYS_write  16
 #define SYS_mknod  17
 #define SYS_unlink 18
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_socket 22
+#define SYS_bind   23
+#define SYS_recvfrom 24
+#define SYS_sendto 25
```
</details>

#### ğŸŒŸ ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ç•ªå·ã¨ã‚«ãƒ¼ãƒãƒ«é–¢æ•°ã®å¯¾å¿œä»˜ã‘

ãƒ¦ãƒ¼ã‚¶ç©ºé–“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã‚’ç™ºè¡Œã—ãŸéš›ã«ã‚«ãƒ¼ãƒãƒ«å†…ã§å®Ÿè¡Œã•ã‚Œã‚‹é–¢æ•°ã®å¯¾å¿œä»˜ã‘ã‚’ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/syscall.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...

 // Prototypes for the functions that handle system calls.
 extern uint64 sys_chdir(void);
 extern uint64 sys_close(void);
 extern uint64 sys_dup(void);
 extern uint64 sys_exec(void);
 extern uint64 sys_exit(void);
 extern uint64 sys_fork(void);
 extern uint64 sys_fstat(void);
 extern uint64 sys_getpid(void);
 extern uint64 sys_kill(void);
 extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_mknod(void);
 extern uint64 sys_open(void);
 extern uint64 sys_pipe(void);
 extern uint64 sys_read(void);
 extern uint64 sys_sbrk(void);
 extern uint64 sys_sleep(void);
 extern uint64 sys_unlink(void);
 extern uint64 sys_wait(void);
 extern uint64 sys_write(void);
 extern uint64 sys_uptime(void);
+extern uint64 sys_socket(void);
+extern uint64 sys_bind(void);
+extern uint64 sys_recvfrom(void);
+extern uint64 sys_sendto(void);

 // An array mapping syscall numbers from syscall.h
 // to the function that handles the system call.
 static uint64 (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
 [SYS_exit]    sys_exit,
 [SYS_wait]    sys_wait,
 [SYS_pipe]    sys_pipe,
 [SYS_read]    sys_read,
 [SYS_kill]    sys_kill,
 [SYS_exec]    sys_exec,
 [SYS_fstat]   sys_fstat,
 [SYS_chdir]   sys_chdir,
 [SYS_dup]     sys_dup,
 [SYS_getpid]  sys_getpid,
 [SYS_sbrk]    sys_sbrk,
 [SYS_sleep]   sys_sleep,
 [SYS_uptime]  sys_uptime,
 [SYS_open]    sys_open,
 [SYS_write]   sys_write,
 [SYS_mknod]   sys_mknod,
 [SYS_unlink]  sys_unlink,
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_socket]   sys_socket,
+[SYS_bind]     sys_bind,
+[SYS_recvfrom] sys_recvfrom,
+[SYS_sendto]   sys_sendto,
 };

...
```
</details>

> [!NOTE]
> é–¢æ•°ãƒã‚¤ãƒ³ã‚¿ã®é…åˆ—ï¼ˆ`syscalls[]`ï¼‰ã«ã€ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ç•ªå·ã«å¯¾å¿œã™ã‚‹ã‚«ãƒ¼ãƒãƒ«å†…ã®é–¢æ•°ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¨­å®šã—ã¾ã™ã€‚

#### ğŸŒŸ ã‚«ãƒ¼ãƒãƒ«é–¢æ•°ã®å®Ÿè£…

ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ãŒç™ºè¡Œã•ã‚ŒãŸéš›ã«ã‚«ãƒ¼ãƒãƒ«å†…ã§å‘¼ã³å‡ºã•ã‚Œã‚‹é–¢æ•°ã‚’è¿½åŠ ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/syssocket.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```c
#include "types.h"
#include "riscv.h"
#include "defs.h"
#include "param.h"
#include "fs.h"
#include "spinlock.h"
#include "sleeplock.h"
#include "file.h"
#include "proc.h"

#include "socket.h"

int
sys_socket(void)
{
  int fd, domain, type, protocol;
  struct file *f;

  argint(0, &domain);
  argint(1, &type);
  argint(2, &protocol);
  if ((f = socket_alloc(domain, type, protocol)) == 0 || (fd = fdalloc(f)) < 0){
    if (f)
      fileclose(f);
    return -1;
  }
  return fd;
}

int
sys_bind(void)
{
  struct file *f;
  uint64 addr_p;
  struct sockaddr_in addr;
  int addrlen;
  struct proc *p = myproc();

  if (argfd(0, 0, &f) < 0 || f->type != FD_SOCKET){
    return -1;
  }
  argaddr(1, &addr_p);
  argint(2, &addrlen);
  if (!addr_p || addrlen < 0) {
    return -1;
  }
  if (copyin(p->pagetable, (char *)&addr, addr_p, addrlen) < 0) {
    return -1;
  }
  return socket_bind(f->socket, (struct sockaddr *)&addr, addrlen);
}

int
sys_recvfrom(void)
{
  struct file *f;
  uint64 buf_p;
  char buf[2048];
  int buflen;
  uint64 addr_p;
  struct sockaddr_in addr;
  uint64 addrlen_p;
  int addrlen = 0;
  int ret;
  struct proc *p = myproc();

  if (argfd(0, 0, &f) < 0 || f->type != FD_SOCKET){
    return -1;
  }
  argaddr(1, &buf_p);
  argint(2, &buflen);
  if (!buf_p || buflen < 0 || buflen > sizeof(buf)) {
    return -1;
  }
  argaddr(3, (void*)&addr_p);
  argaddr(4, (void*)&addrlen_p);
  if (addrlen_p) {
    if (copyin(p->pagetable, (char *)&addrlen, addrlen_p, sizeof(addrlen)) < 0) {
      return -1;
    }
    if (addrlen && addrlen != sizeof(addr)) {
      return -1;
    }
  }
  if (addrlen && !addr_p) {
    return -1;
  }
  ret = socket_recvfrom(f->socket, buf, buflen, (struct sockaddr *)&addr, &addrlen);
  if (copyout(p->pagetable, buf_p, buf, buflen) < 0) {
    return -1;
  }
  if (addr_p) {
    if (copyout(p->pagetable, addr_p, (char *)&addr, addrlen) < 0) {
      return -1;
    }
    if (copyout(p->pagetable, addrlen_p, (char *)&addrlen, sizeof(addrlen)) < 0) {
      return -1;
    }
  }
  return ret;
}

int
sys_sendto(void)
{
  struct file *f;
  uint64 buf_p;
  char buf[2048];
  int buflen;
  uint64 addr_p;
  struct sockaddr_in addr;
  int addrlen;
  struct proc *p = myproc();

  if (argfd(0, 0, &f) < 0 || f->type != FD_SOCKET){
    return -1;
  }
  argaddr(1, &buf_p);
  argint(2, &buflen);
  if (!buf_p || buflen < 0 || buflen > sizeof(buf)) {
    return -1;
  }
  if (copyin(p->pagetable, buf, buf_p, buflen) < 0) {
    return -1;
  }
  argaddr(3, &addr_p);
  argint(4, &addrlen);
  if (!addr_p || addrlen < 0) {
    return -1;
  }
  if (copyin(p->pagetable, (char *)&addr, addr_p, addrlen) < 0) {
    return -1;
  }
  return socket_sendto(f->socket, buf, buflen, (struct sockaddr *)&addr, addrlen);
}
```
</details>

> [!IMPORTANT]
> å…¨ã¦ã®é–¢æ•°ã®å¼•æ•°ãŒ`void`ã§ã‚ã‚‹ã“ã¨ã‹ã‚‰ã‚‚ã‚ã‹ã‚‹ã‚ˆã†ã«ã€é€šå¸¸ã®é–¢æ•°ã¨ã¯å¼•æ•°ã®å—ã‘å–ã‚Šæ–¹ãŒç•°ãªã‚Šã¾ã™ã€‚
>
> ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã®ã‚«ãƒ¼ãƒãƒ«é–¢æ•°ã§ã¯ã€æ¬¡ã®ã‚ˆã†ãªé–¢æ•°ã‚’ä½¿ç”¨ã—ã¦å¼•æ•°ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚
>
> + `argint()` ... æ•´æ•°
> + `argaddr()` ... ãƒã‚¤ãƒ³ã‚¿
> + `argfd()` ... ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿
> + `argstr()` ... æ–‡å­—åˆ—
>
> ã“ã‚Œã‚‰ã®é–¢æ•°ã¯ã€ã„ãšã‚Œã‚‚æœ€åˆã®å¼•æ•°ã«ã¯ã€Œ0ã‹ã‚‰ã¯ã˜ã¾ã‚‹å¼•æ•°ã®ç•ªå·ã€ã‚’æŒ‡å®šã—ã¾ã™ã€‚`argaddr()`ã§ã¯ãƒã‚¤ãƒ³ã‚¿ã¨ã—ã¦æ¸¡ã•ã‚ŒãŸå¼•æ•°ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã—ã¾ã™ãŒã€ã“ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰ç›´æ¥ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿å‡ºã—ãŸã‚Šæ›¸ãå‡ºã™ã“ã¨ã¯ã§ã¾ã›ã‚“ã€‚å¿…ãš`copyin()`ã¾ãŸã¯`copyout()`ã‚’ä½¿ã£ã¦ã‚«ãƒ¼ãƒãƒ«ç©ºé–“ã¨ãƒ¦ãƒ¼ã‚¶ç©ºé–“ã®é–“ã§ãƒ‡ãƒ¼ã‚¿ã®ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚
>
> ä¾‹ãˆã° `void *data`, `int len` ã®ã‚ˆã†ãªå½¢ã§ãƒã‚¤ãƒ³ã‚¿ã«ç¶šã‘ã¦é•·ã•ã‚’å—ã‘å–ã‚‹å ´åˆã«ã¯ã€å…ˆã«é•·ã•ã®å¼•æ•°ã‚’å—ã‘å–ã‚Šã€ãã®å¾Œã«ãƒã‚¤ãƒ³ã‚¿ã®å¼•æ•°ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ã‚‚ã¨ã«`copyin()`ã§ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿å‡ºã—ã¾ã™ã€‚

> [!NOTE]
> ã‚½ã‚±ãƒƒãƒˆã®å…·ä½“çš„ãªå‡¦ç†ã¯ã€å…ˆã«å®Ÿè£…ã—ã¦ãŠã„ãŸ`kernel/net/socket.c`ã®ä¸­ã§è¡Œã†ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚`kernel/syssocket.c`ã®é–¢æ•°ã¯ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã®å¼•æ•°ã‚’å—ã‘å–ã£ãŸã‚‰ã€ãã‚Œã‚‰ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ãã®çµæœã‚’è¿”ã—ã¾ã™ã€‚

#### ğŸŒŸ `sysfile.c`å†…ã®é–¢æ•°ã®åˆ©ç”¨

`kernel/syssocket.c`ã®é–¢æ•°ã¯`kernel/sysfile.c`ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã„ã¾ã™ãŒã€ã“ã‚Œã‚‰ã¯ã‚‚ã¨ã‚‚ã¨`sysfile.c`ã®ä¸­ã ã‘ã§ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹é–¢æ•°ã§`static`ä¿®é£¾å­ãŒä»˜ã„ã¦ã„ã¾ã™ã€‚ã“ã®ã¾ã¾ã ã¨ä»–ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å‘¼ã³å‡ºã›ãªã„ã®ã§`static`ä¿®é£¾å­ã‚’å‰Šé™¤ã—ã€`kernel/defs.h`ã«ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—å®£è¨€ã‚’è¿½åŠ ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/sysfile.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...

-static int
+int
 argfd(int n, int *pfd, struct file **pf)
 {
...
 }

-static int
+int
 fdalloc(struct file *f)
 {
...
 }

...
```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• kernel/defs.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...

 // syscall.c
 void            argint(int, int*);
 int             argstr(int, char*, int);
 void            argaddr(int, uint64 *);
 int             fetchstr(uint64, char*, int);
 int             fetchaddr(uint64, uint64*);
 void            syscall();

+// sysfile.c
+int             argfd(int, int*, struct file**);
+int             fdalloc(struct file*);

 // time.c
 time_t          time(time_t*);
 int             gettimeofday(struct timeval*, void*);
 time_t          mktime(struct tm*);
 struct tm*      localtime_r(const time_t*, struct tm*);

...
```
</details>

#### ğŸŒŸ ãƒ¦ãƒ¼ã‚¶ç©ºé–“ã¸ã®ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã®æä¾›

ãƒ¦ãƒ¼ã‚¶ç©ºé–“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒå‘¼ã³å‡ºã™ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã®ã‚¢ã‚»ãƒ³ãƒ–ãƒªã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ã¾ã™ã€‚

> [!NOTE]
> ã‚¢ã‚»ãƒ³ãƒ–ãƒªã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ ã™ã‚‹ã¨è¨€ã£ã¦ã‚‚é›£ã—ã„ã“ã¨ã¯ãªãã€ã‚ã‚‰ã‹ã˜ã‚ç”¨æ„ã•ã‚Œã¦ã„ã‚‹Perlã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ç°¡å˜ã«ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã‚’è¿½åŠ ã§ãã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• user/usys.plï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...
	
 entry("fork");
 entry("exit");
 entry("wait");
 entry("pipe");
 entry("read");
 entry("write");
 entry("close");
 entry("kill");
 entry("exec");
 entry("open");
 entry("mknod");
 entry("unlink");
 entry("fstat");
 entry("link");
 entry("mkdir");
 entry("chdir");
 entry("dup");
 entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("socket");
+entry("bind");
+entry("recvfrom");
+entry("sendto");
```
</details>

æ¬¡ã«ã€è¿½åŠ ã—ãŸã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«ã®ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—å®£è¨€ã‚’è¿½åŠ ã—ã¾ã™ã€‚

> [!IMPORTANT]
> ã‚«ãƒ¼ãƒãƒ«å†…ã®é–¢æ•°ã¯`kernel/defs.h`ã«è¨˜è¿°ã—ã¦ã„ã¾ã—ãŸãŒã€ãƒ¦ãƒ¼ã‚¶ç©ºé–“ã®é–¢æ•°ã¯`user/user.h`ã«è¨˜è¿°ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• user/user.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
 struct stat;
+struct sockaddr;

 // system calls
 int fork(void);
 int exit(int) __attribute__((noreturn));
 int wait(int*);
 int pipe(int*);
 int write(int, const void*, int);
 int read(int, void*, int);
 int close(int);
 int kill(int);
 int exec(const char*, char**);
 int open(const char*, int);
 int mknod(const char*, short, short);
 int unlink(const char*);
 int fstat(int fd, struct stat*);
 int link(const char*, const char*);
 int mkdir(const char*);
 int chdir(const char*);
 int dup(int);
 int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int socket(int, int, int);
+int bind(int, struct sockaddr*, int);
+int recvfrom(int, char*, int, struct sockaddr*, int*);
+int sendto(int, char*, int, struct sockaddr*, int);

...
```
</details>

#### ğŸŒŸ Makefileã®ä¿®æ­£

ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¿½åŠ ã—ãŸã®ã§`Makefile`ã‚’ä¿®æ­£ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• Makefileï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
 OBJS = \
...
   $K/virtio_disk.o \
+  $K/syssocket.o \
   $N/util.o \
   $N/net.o \
   $N/ether.o \
   $N/ip.o \
   $N/arp.o \
   $N/icmp.o \
   $N/udp.o \
   $N/tcp.o \
   $P/std.o \
   $P/virtio_net.o

...
```
</details>

ã“ã®æ®µéšã§ãƒ“ãƒ«ãƒ‰ãŒé€šã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãŠãã¾ã—ã‚‡ã†ã€‚

```
$ make clean
$ make
```

## 5.4. é€šä¿¡ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³

æœ€å¾Œã«ã€å®Ÿéš›ã«ã‚½ã‚±ãƒƒãƒˆã‚’ä½¿ç”¨ã™ã‚‹é€šä¿¡ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œæˆã—ã¾ã™ã€‚

#### ğŸŒŸ ãƒ¦ãƒ¼ã‚¶ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¸é–¢æ•°ã®è¿½åŠ 

é€šä¿¡ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä½œæˆã™ã‚‹ã®ä¸è¶³ã—ã¦ã‚‹é–¢æ•°ã‚’ãƒ¦ãƒ¼ã‚¶ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¸è¿½åŠ ã—ã¾ã™ã€‚

> [!NOTE]
> ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãƒ¼å¤‰æ›ã®é–¢æ•°éƒ¡ã¯`kernel/net/util.c`ã‹ã‚‰ã®ã‚³ãƒ”ãƒšã§ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• user/ulib.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...

 void *
 memcpy(void *dst, const void *src, uint n)
 {
   return memmove(dst, src, n);
 }
+
+#ifndef __BIG_ENDIAN
+#define __BIG_ENDIAN 4321
+#endif
+#ifndef __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN 1234
+#endif
+
+static int endian;
+
+static int
+byteorder(void)
+{
+    uint32_t x = 0x00000001;
+
+    return *(uint8_t *)&x ? __LITTLE_ENDIAN : __BIG_ENDIAN;
+}
+
+static uint16_t
+byteswap16(uint16_t v)
+{
+    return (v & 0x00ff) << 8 | (v & 0xff00 ) >> 8;
+}
+
+static uint32_t
+byteswap32(uint32_t v)
+{
+    return (v & 0x000000ff) << 24 | (v & 0x0000ff00) << 8 | (v & 0x00ff0000) >> 8 | (v & 0xff000000) >> 24;
+}
+
+uint16_t
+htons(uint16_t h)
+{
+    if (!endian) {
+        endian = byteorder();
+    }
+    return endian == __LITTLE_ENDIAN ? byteswap16(h) : h;
+}
+
+uint16_t
+ntohs(uint16_t n)
+{
+    if (!endian) {
+        endian = byteorder();
+    }
+    return endian == __LITTLE_ENDIAN ? byteswap16(n) : n;
+}
+
+uint32_t
+htonl(uint32_t h)
+{
+    if (!endian) {
+        endian = byteorder();
+    }
+    return endian == __LITTLE_ENDIAN ? byteswap32(h) : h;
+}
+
+uint32_t
+ntohl(uint32_t n)
+{
+    if (!endian) {
+        endian = byteorder();
+    }
+    return endian == __LITTLE_ENDIAN ? byteswap32(n) : n;
+}
```
</details>

`user/ulib.c`ã«é–¢æ•°ã‚’è¿½åŠ ã—ãŸã‚‰`user/user.h`ã«ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—å®£è¨€ã‚’è¿½åŠ ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• user/user.hï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...

 // ulib.c
 int stat(const char*, struct stat*);
 char* strcpy(char*, const char*);
 void *memmove(void*, const void*, int);
 char* strchr(const char*, char c);
 int strcmp(const char*, const char*);
 void fprintf(int, const char*, ...) __attribute__ ((format (printf, 2, 3)));
 void printf(const char*, ...) __attribute__ ((format (printf, 1, 2)));
 char* gets(char*, int max);
 uint strlen(const char*);
 void* memset(void*, int, uint);
 int atoi(const char*);
 int memcmp(const void *, const void *, uint);
 void *memcpy(void *, const void *, uint);
+uint16_t htons(uint16_t);
+uint16_t ntohs(uint16_t);
+uint32_t htonl(uint32_t);
+uint32_t ntohl(uint32_t);
+int inet_pton(int, const char*, void*);

 // umalloc.c
 void* malloc(uint);
 void free(void*);
```
</details>

#### ğŸŒŸ UDPã‚¨ã‚³ãƒ¼ã‚µãƒ¼ãƒã®ã‚³ãƒ¼ãƒ‰

æœ¬å‘½ã®UDPã‚¨ã‚³ãƒ¼ã‚µãƒ¼ãƒã®ã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• user/udpecho.cï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```c
#include "kernel/types.h"
#include "user/user.h"
#include "kernel/net/socket.h"

int
main (int argc, char *argv[])
{
    int soc, peerlen, ret;
    struct sockaddr_in self, peer;
    unsigned char *addr;
    char buf[2048];

    printf("Starting UDP Echo Server\n");
    soc = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (soc == -1) {
        printf("socket: failure\n");
        exit(1);
    }
    printf("socket: success, soc=%d\n", soc);
    self.sin_family = AF_INET;
    self.sin_addr.s_addr = INADDR_ANY;
    self.sin_port = htons(7);
    if (bind(soc, (struct sockaddr *)&self, sizeof(self)) == -1) {
        printf("bind: failure\n");
        close(soc);
        exit(1);
    }
    addr = (unsigned char *)&self.sin_addr.s_addr;
    printf("bind: success, self=%d.%d.%d.%d:%d\n",
        addr[0], addr[1], addr[2], addr[3], ntohs(self.sin_port));
    printf("waiting for message...\n");
    while (1) {
        peerlen = sizeof(peer);
        ret = recvfrom(soc, buf, sizeof(buf), (struct sockaddr *)&peer, &peerlen);
        if (ret <= 0) {
            printf("EOF\n");
            break;
        }
        if (ret == 2 && buf[0] == '.' && buf[1] == '\n') {
            printf("quit\n");
            break;  
        }
        addr = (unsigned char *)&peer.sin_addr.s_addr;
        printf("recvfrom: %d bytes data received, peer=%d.%d.%d.%d:%d\n",
            ret, addr[0], addr[1], addr[2], addr[3], ntohs(peer.sin_port));
        sendto(soc, buf, ret, (struct sockaddr *)&peer, peerlen);
    }
    close(soc);  
    exit(0);
}
```
</details>

> [!NOTE]
> ã“ã®ãã‚‰ã„ã®å˜ç´”ãªã‚‚ã®ã§ã‚ã‚Œã°ã€Linuxå‘ã‘ã®ã‚³ãƒ¼ãƒ‰ã¨ã»ã¨ã‚“ã©å·®ãŒãªã„ã“ã¨ãŒè¦‹ã¦å–ã‚Œã¾ã™ã€‚

#### ğŸŒŸ Makefileã®ä¿®æ­£

ãƒ¦ãƒ¼ã‚¶ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è¿½åŠ ã—ãŸã®ã§`Makefile`ã‚’ä¿®æ­£ã—ã¾ã™ã€‚

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ğŸ“• Makefileï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼‰</span></summary>

```diff
...

 UPROGS=\
 	$U/_cat\
 	$U/_echo\
 	$U/_forktest\
 	$U/_grep\
 	$U/_init\
 	$U/_kill\
 	$U/_ln\
 	$U/_ls\
 	$U/_mkdir\
 	$U/_rm\
 	$U/_sh\
 	$U/_stressfs\
+	$U/_udpecho\
 	$U/_usertests\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\

...
```
</details>

> [!IMPORTANT]
> ãƒ¦ãƒ¼ã‚¶ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯`UPROGS`ã«åˆ—æŒ™ã—ã¾ã™ã€‚ã“ã®éš›ã€é ­ã«`_`ã‚’ä»˜ã‘ã€æœ«å°¾ã®æ‹¡å¼µå­ã¯å–ã‚Šé™¤ãã¾ã™ã€‚

#### ğŸŒŸ å‹•ä½œç¢ºèª

> [!WARNING]
> ãƒ¦ãƒ¼ã‚¶ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯`make qemu`ã§xv6ã‚’ç«‹ã¡ä¸Šã’ã‚‹ç›´å‰ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¾ã™ã€‚å˜ç´”ã«`make`ã‚’å®Ÿè¡Œã—ãŸã ã‘ã§ã¯ãƒ¦ãƒ¼ã‚¶ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œãªã„ã®ã§æ³¨æ„ã—ã¦ãã ã•ã„ã€‚

å†ãƒ“ãƒ«ãƒ‰ã—ã¦xv6ã‚’èµ·å‹•ã—ã¾ã™ã€‚ã‚·ã‚§ãƒ«ãŒç«‹ã¡ä¸ŠãŒã£ãŸã‚‰ã€UDPã‚¨ã‚³ãƒ¼ã‚µãƒ¼ãƒã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ï¼ˆ`udpecho`ï¼‰ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚

```
$ udpecho
Starting UDP Echo Server
socket: success, soc=3
19:56:57.349 [D] udp_bind: bound, id=0, local=0.0.0.0:7 (kernel/net/udp.c:340)
bind: success, self=0.0.0.0:7
waiting for message...
```

`0.0.0.0`ã®`7`ç•ªãƒãƒ¼ãƒˆã§ãƒ‡ãƒ¼ã‚¿ãŒé€ã‚‰ã‚Œã¦ãã‚‹ã®ã‚’å¾…ã£ã¦ã„ã‚‹ã®ã§ã€åˆ¥ã®ã‚·ã‚§ãƒ«ã§`nc`ã‚³ãƒãƒ³ãƒ‰ã‚’ç«‹ã¡ä¸Šã’ã¦é©å½“ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã—ã¾ã™ã€‚

```
$ nc -u 192.0.2.2 7
hoge
hoge
fuga
fuga
.
```

> [!NOTE]
> æ­£å¸¸ã«å‹•ä½œã—ã¦ã„ã‚Œã°ã€é€ä¿¡ã—ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒãã®ã¾ã¾é€ã‚Šè¿”ã•ã‚Œã¦ãã‚‹ã¯ãšã§ã™ã€‚ãªãŠã€ã‚¨ã‚³ãƒ¼ã‚µãƒ¼ãƒã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’çµ‚äº†ã•ã›ã‚‹ã«ã¯`.`ã ã‘ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã—ã¾ã™ã€‚

ã‚¨ã‚³ãƒ¼ã‚µãƒ¼ãƒå´ã®ãƒ­ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚‚ç¢ºèªã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```
19:57:03.416 [D] ether_input_helper: dev=net0, type=0x0806, len=42 (kernel/net/ether.c:123)
        src: 16:2a:af:19:b5:91
        dst: ff:ff:ff:ff:ff:ff
       type: 0x0806
19:57:03.417 [D] net_input_handler: queue pushed (num:1), dev=net0, type=0x0806, len=28 (kernel/net/net.c:236)
19:57:03.418 [D] net_softirq_handler: queue popped (num:0), dev=net0, type=0x0806, len=28 (kernel/net/net.c:258)
19:57:03.419 [D] arp_input: dev=net0, len=28 (kernel/net/arp.c:236)
        hrd: 0x0001
        pro: 0x0800
        hln: 6
        pln: 4
         op: 1 (Request)
        sha: 16:2a:af:19:b5:91
        spa: 192.0.2.1
        tha: 00:00:00:00:00:00
        tpa: 192.0.2.2
19:57:03.421 [D] arp_cache_insert: INSERT: pa=192.0.2.1, ha=16:2a:af:19:b5:91 (kernel/net/arp.c:173)
19:57:03.422 [D] arp_reply: dev=net0, len=28 (kernel/net/arp.c:210)
        hrd: 0x0001
        pro: 0x0800
        hln: 6
        pln: 4
         op: 2 (Reply)
        sha: 52:54:00:12:34:56
        spa: 192.0.2.2
        tha: 16:2a:af:19:b5:91
        tpa: 192.0.2.1
19:57:03.423 [D] net_device_output: dev=net0, type=0x0806, len=28 (kernel/net/net.c:144)
19:57:03.424 [D] ether_transmit_helper: dev=net0, type=0x0806, len=60 (kernel/net/ether.c:88)
        src: 52:54:00:12:34:56
        dst: 16:2a:af:19:b5:91
       type: 0x0806
19:57:03.425 [D] ether_input_helper: dev=net0, type=0x0800, len=47 (kernel/net/ether.c:123)
        src: 16:2a:af:19:b5:91
        dst: 52:54:00:12:34:56
       type: 0x0800
19:57:03.426 [D] net_input_handler: queue pushed (num:1), dev=net0, type=0x0800, len=33 (kernel/net/net.c:236)
19:57:03.427 [D] net_softirq_handler: queue popped (num:0), dev=net0, type=0x0800, len=33 (kernel/net/net.c:258)
19:57:03.428 [D] ip_input: dev=net0, iface=192.0.2.2, protocol=17, total=33 (kernel/net/ip.c:357)
        vhl: 0x45 [v: 4, hl: 5 (20)]
        tos: 0x00
      total: 33 (payload: 13)
         id: 32443
     offset: 0x4000 [flags=2, offset=0]
        ttl: 64
   protocol: 17
        sum: 0x380d
        src: 192.0.2.1
        dst: 192.0.2.2
19:57:03.430 [D] udp_input: 192.0.2.1:33182 => 192.0.2.2:7, len=13 (payload=5) (kernel/net/udp.c:175)
        src: 33182
        dst: 7
        len: 13
        sum: 0x2056
19:57:03.431 [D] udp_input: queue pushed: id=0, num=1 (kernel/net/udp.c:202)
recvfrom: 5 bytes data received, peer=192.0.2.1:33182
19:57:03.439 [D] udp_sendto: select local address, addr=192.0.2.2 (kernel/net/udp.c:371)
19:57:03.439 [D] udp_output: 192.0.2.2:7 => 192.0.2.1:33182, len=13 (payload=5) (kernel/net/udp.c:241)
        src: 7
        dst: 33182
        len: 13
        sum: 0x2056
19:57:03.440 [D] ip_output_core: dev=net0, dst=192.0.2.1, protocol=17, len=33 (kernel/net/ip.c:416)
        vhl: 0x45 [v: 4, hl: 5 (20)]
        tos: 0x00
      total: 33 (payload: 13)
         id: 128
     offset: 0x0000 [flags=0, offset=0]
        ttl: 255
   protocol: 17
        sum: 0x3748
        src: 192.0.2.2
        dst: 192.0.2.1
19:57:03.442 [D] arp_resolve: resolved, pa=192.0.2.1, ha=16:2a:af:19:b5:91 (kernel/net/arp.c:298)
19:57:03.443 [D] net_device_output: dev=net0, type=0x0800, len=33 (kernel/net/net.c:144)
19:57:03.443 [D] ether_transmit_helper: dev=net0, type=0x0800, len=60 (kernel/net/ether.c:88)
        src: 52:54:00:12:34:56
        dst: 16:2a:af:19:b5:91
       type: 0x0800
...
```

ã“ã“ã¾ã§ã«å®Ÿè£…ã—ãŸUDPç”¨ã®ã‚½ã‚±ãƒƒãƒˆãŒå•é¡Œãªãå‹•ä½œã—ã¦ã„ã‚‹ã“ã¨ãŒç¢ºèªã§ãã‚‹ã¯ãšã§ã™ã€‚æœ€ä½é™ã§ã¯ã‚ã‚Šã¾ã™ãŒã€Œxv6ã«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ©Ÿèƒ½ã‚’è¿½åŠ ã€ã™ã‚‹ã“ã¨ãŒã§ãã¾ã—ãŸğŸ‰

æ˜¯éã€å¿œç”¨èª²é¡Œã§TCPç”¨ã®ã‚½ã‚±ãƒƒãƒˆã«ã‚‚ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã—ã¦ã¿ã¦ãã ã•ã„ã€‚

<hr/>

[æ¬¡ã¸](06.md)
